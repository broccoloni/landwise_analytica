/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/analysis/page",{

/***/ "?b5cf":
/*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "?69f2":
/*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "?5a99":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "(app-pages-browser)/./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanM/OTI4NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"(app-pages-browser)/./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"(app-pages-browser)/./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"(app-pages-browser)/./node_modules/buffer/node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = __webpack_require__.g.TYPED_ARRAY_SUPPORT !== undefined\n  ? __webpack_require__.g.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsd0ZBQVM7O0FBRS9CLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQkFBTTtBQUNuQyxJQUFJLHFCQUFNO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQW9EO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RCxPQUFPO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzPzE2M2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/buffer/node_modules/isarray/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/buffer/node_modules/isarray/index.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcz8yZTRjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/buffer/node_modules/isarray/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/node_modules/xml-utils/count-substring.js":
/*!************************************************************************!*\
  !*** ./node_modules/geotiff/node_modules/xml-utils/count-substring.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function countSubstring(string, substring) {\n  const pattern = new RegExp(substring, \"g\");\n  const match = string.match(pattern);\n  return match ? match.length : 0;\n}\n\nmodule.exports = countSubstring;\nmodule.exports[\"default\"] = countSubstring;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL25vZGVfbW9kdWxlcy94bWwtdXRpbHMvY291bnQtc3Vic3RyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvbm9kZV9tb2R1bGVzL3htbC11dGlscy9jb3VudC1zdWJzdHJpbmcuanM/NDY2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjb3VudFN1YnN0cmluZyhzdHJpbmcsIHN1YnN0cmluZykge1xuICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cChzdWJzdHJpbmcsIFwiZ1wiKTtcbiAgY29uc3QgbWF0Y2ggPSBzdHJpbmcubWF0Y2gocGF0dGVybik7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoLmxlbmd0aCA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY291bnRTdWJzdHJpbmc7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gY291bnRTdWJzdHJpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/node_modules/xml-utils/count-substring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/node_modules/xml-utils/find-tag-by-name.js":
/*!*************************************************************************!*\
  !*** ./node_modules/geotiff/node_modules/xml-utils/find-tag-by-name.js ***!
  \*************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("const indexOfMatch = __webpack_require__(/*! ./index-of-match.js */ \"(app-pages-browser)/./node_modules/geotiff/node_modules/xml-utils/index-of-match.js\");\nconst indexOfMatchEnd = __webpack_require__(/*! ./index-of-match-end.js */ \"(app-pages-browser)/./node_modules/geotiff/node_modules/xml-utils/index-of-match-end.js\");\nconst countSubstring = __webpack_require__(/*! ./count-substring.js */ \"(app-pages-browser)/./node_modules/geotiff/node_modules/xml-utils/count-substring.js\");\n\nfunction findTagByName(xml, tagName, options) {\n  const debug = (options && options.debug) || false;\n  const nested = !(options && typeof options.nested === false);\n\n  const startIndex = (options && options.startIndex) || 0;\n\n  if (debug) console.log(\"[xml-utils] starting findTagByName with\", tagName, \" and \", options);\n\n  const start = indexOfMatch(xml, `\\<${tagName}[ \\n\\>\\/]`, startIndex);\n  if (debug) console.log(\"[xml-utils] start:\", start);\n  if (start === -1) return undefined;\n\n  const afterStart = xml.slice(start + tagName.length);\n\n  let relativeEnd = indexOfMatchEnd(afterStart, \"^[^<]*[ /]>\", 0);\n\n  const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === \"/\";\n  if (debug) console.log(\"[xml-utils] selfClosing:\", selfClosing);\n\n  if (selfClosing === false) {\n    // check if tag has subtags with the same name\n    if (nested) {\n      let startIndex = 0;\n      let openings = 1;\n      let closings = 0;\n      while ((relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", startIndex)) !== -1) {\n        const clip = afterStart.substring(startIndex, relativeEnd + 1);\n        openings += countSubstring(clip, \"<\" + tagName + \"[ \\n\\t>]\");\n        closings += countSubstring(clip, \"</\" + tagName + \">\");\n        // we can't have more openings than closings\n        if (closings >= openings) break;\n        startIndex = relativeEnd;\n      }\n    } else {\n      relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", 0);\n    }\n  }\n\n  const end = start + tagName.length + relativeEnd + 1;\n  if (debug) console.log(\"[xml-utils] end:\", end);\n  if (end === -1) return undefined;\n\n  const outer = xml.slice(start, end);\n  // tag is like <gml:identifier codeSpace=\"OGP\">urn:ogc:def:crs:EPSG::32617</gml:identifier>\n\n  let inner;\n  if (selfClosing) {\n    inner = null;\n  } else {\n    inner = outer.slice(outer.indexOf(\">\") + 1, outer.lastIndexOf(\"<\"));\n  }\n\n  return { inner, outer, start, end };\n}\n\nmodule.exports = findTagByName;\nmodule.exports[\"default\"] = findTagByName;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL25vZGVfbW9kdWxlcy94bWwtdXRpbHMvZmluZC10YWctYnktbmFtZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxQkFBcUIsbUJBQU8sQ0FBQyxnSEFBcUI7QUFDbEQsd0JBQXdCLG1CQUFPLENBQUMsd0hBQXlCO0FBQ3pELHVCQUF1QixtQkFBTyxDQUFDLGtIQUFzQjs7QUFFckQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSx5QkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvbm9kZV9tb2R1bGVzL3htbC11dGlscy9maW5kLXRhZy1ieS1uYW1lLmpzP2YzMGMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaW5kZXhPZk1hdGNoID0gcmVxdWlyZShcIi4vaW5kZXgtb2YtbWF0Y2guanNcIik7XG5jb25zdCBpbmRleE9mTWF0Y2hFbmQgPSByZXF1aXJlKFwiLi9pbmRleC1vZi1tYXRjaC1lbmQuanNcIik7XG5jb25zdCBjb3VudFN1YnN0cmluZyA9IHJlcXVpcmUoXCIuL2NvdW50LXN1YnN0cmluZy5qc1wiKTtcblxuZnVuY3Rpb24gZmluZFRhZ0J5TmFtZSh4bWwsIHRhZ05hbWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGVidWcgPSAob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnKSB8fCBmYWxzZTtcbiAgY29uc3QgbmVzdGVkID0gIShvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm5lc3RlZCA9PT0gZmFsc2UpO1xuXG4gIGNvbnN0IHN0YXJ0SW5kZXggPSAob3B0aW9ucyAmJiBvcHRpb25zLnN0YXJ0SW5kZXgpIHx8IDA7XG5cbiAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcIlt4bWwtdXRpbHNdIHN0YXJ0aW5nIGZpbmRUYWdCeU5hbWUgd2l0aFwiLCB0YWdOYW1lLCBcIiBhbmQgXCIsIG9wdGlvbnMpO1xuXG4gIGNvbnN0IHN0YXJ0ID0gaW5kZXhPZk1hdGNoKHhtbCwgYFxcPCR7dGFnTmFtZX1bIFxcblxcPlxcL11gLCBzdGFydEluZGV4KTtcbiAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcIlt4bWwtdXRpbHNdIHN0YXJ0OlwiLCBzdGFydCk7XG4gIGlmIChzdGFydCA9PT0gLTEpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgY29uc3QgYWZ0ZXJTdGFydCA9IHhtbC5zbGljZShzdGFydCArIHRhZ05hbWUubGVuZ3RoKTtcblxuICBsZXQgcmVsYXRpdmVFbmQgPSBpbmRleE9mTWF0Y2hFbmQoYWZ0ZXJTdGFydCwgXCJeW148XSpbIC9dPlwiLCAwKTtcblxuICBjb25zdCBzZWxmQ2xvc2luZyA9IHJlbGF0aXZlRW5kICE9PSAtMSAmJiBhZnRlclN0YXJ0W3JlbGF0aXZlRW5kIC0gMV0gPT09IFwiL1wiO1xuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiW3htbC11dGlsc10gc2VsZkNsb3Npbmc6XCIsIHNlbGZDbG9zaW5nKTtcblxuICBpZiAoc2VsZkNsb3NpbmcgPT09IGZhbHNlKSB7XG4gICAgLy8gY2hlY2sgaWYgdGFnIGhhcyBzdWJ0YWdzIHdpdGggdGhlIHNhbWUgbmFtZVxuICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgIGxldCBzdGFydEluZGV4ID0gMDtcbiAgICAgIGxldCBvcGVuaW5ncyA9IDE7XG4gICAgICBsZXQgY2xvc2luZ3MgPSAwO1xuICAgICAgd2hpbGUgKChyZWxhdGl2ZUVuZCA9IGluZGV4T2ZNYXRjaEVuZChhZnRlclN0YXJ0LCBcIlsgL11cIiArIHRhZ05hbWUgKyBcIj5cIiwgc3RhcnRJbmRleCkpICE9PSAtMSkge1xuICAgICAgICBjb25zdCBjbGlwID0gYWZ0ZXJTdGFydC5zdWJzdHJpbmcoc3RhcnRJbmRleCwgcmVsYXRpdmVFbmQgKyAxKTtcbiAgICAgICAgb3BlbmluZ3MgKz0gY291bnRTdWJzdHJpbmcoY2xpcCwgXCI8XCIgKyB0YWdOYW1lICsgXCJbIFxcblxcdD5dXCIpO1xuICAgICAgICBjbG9zaW5ncyArPSBjb3VudFN1YnN0cmluZyhjbGlwLCBcIjwvXCIgKyB0YWdOYW1lICsgXCI+XCIpO1xuICAgICAgICAvLyB3ZSBjYW4ndCBoYXZlIG1vcmUgb3BlbmluZ3MgdGhhbiBjbG9zaW5nc1xuICAgICAgICBpZiAoY2xvc2luZ3MgPj0gb3BlbmluZ3MpIGJyZWFrO1xuICAgICAgICBzdGFydEluZGV4ID0gcmVsYXRpdmVFbmQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbGF0aXZlRW5kID0gaW5kZXhPZk1hdGNoRW5kKGFmdGVyU3RhcnQsIFwiWyAvXVwiICsgdGFnTmFtZSArIFwiPlwiLCAwKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBlbmQgPSBzdGFydCArIHRhZ05hbWUubGVuZ3RoICsgcmVsYXRpdmVFbmQgKyAxO1xuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiW3htbC11dGlsc10gZW5kOlwiLCBlbmQpO1xuICBpZiAoZW5kID09PSAtMSkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICBjb25zdCBvdXRlciA9IHhtbC5zbGljZShzdGFydCwgZW5kKTtcbiAgLy8gdGFnIGlzIGxpa2UgPGdtbDppZGVudGlmaWVyIGNvZGVTcGFjZT1cIk9HUFwiPnVybjpvZ2M6ZGVmOmNyczpFUFNHOjozMjYxNzwvZ21sOmlkZW50aWZpZXI+XG5cbiAgbGV0IGlubmVyO1xuICBpZiAoc2VsZkNsb3NpbmcpIHtcbiAgICBpbm5lciA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgaW5uZXIgPSBvdXRlci5zbGljZShvdXRlci5pbmRleE9mKFwiPlwiKSArIDEsIG91dGVyLmxhc3RJbmRleE9mKFwiPFwiKSk7XG4gIH1cblxuICByZXR1cm4geyBpbm5lciwgb3V0ZXIsIHN0YXJ0LCBlbmQgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kVGFnQnlOYW1lO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGZpbmRUYWdCeU5hbWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/node_modules/xml-utils/find-tag-by-name.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/node_modules/xml-utils/find-tags-by-name.js":
/*!**************************************************************************!*\
  !*** ./node_modules/geotiff/node_modules/xml-utils/find-tags-by-name.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("const findTagByName = __webpack_require__(/*! ./find-tag-by-name.js */ \"(app-pages-browser)/./node_modules/geotiff/node_modules/xml-utils/find-tag-by-name.js\");\n\nfunction findTagsByName(xml, tagName, options) {\n  const tags = [];\n  const debug = (options && options.debug) || false;\n  const nested = options && typeof options.nested === \"boolean\" ? options.nested : true;\n  let startIndex = (options && options.startIndex) || 0;\n  let tag;\n  while ((tag = findTagByName(xml, tagName, { debug, startIndex }))) {\n    if (nested) {\n      startIndex = tag.start + 1 + tagName.length;\n    } else {\n      startIndex = tag.end;\n    }\n    tags.push(tag);\n  }\n  if (debug) console.log(\"findTagsByName found\", tags.length, \"tags\");\n  return tags;\n}\n\nmodule.exports = findTagsByName;\nmodule.exports[\"default\"] = findTagsByName;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL25vZGVfbW9kdWxlcy94bWwtdXRpbHMvZmluZC10YWdzLWJ5LW5hbWUuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0JBQXNCLG1CQUFPLENBQUMsb0hBQXVCOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsbUJBQW1CO0FBQ2pFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvbm9kZV9tb2R1bGVzL3htbC11dGlscy9maW5kLXRhZ3MtYnktbmFtZS5qcz80MjI4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGZpbmRUYWdCeU5hbWUgPSByZXF1aXJlKFwiLi9maW5kLXRhZy1ieS1uYW1lLmpzXCIpO1xuXG5mdW5jdGlvbiBmaW5kVGFnc0J5TmFtZSh4bWwsIHRhZ05hbWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgdGFncyA9IFtdO1xuICBjb25zdCBkZWJ1ZyA9IChvcHRpb25zICYmIG9wdGlvbnMuZGVidWcpIHx8IGZhbHNlO1xuICBjb25zdCBuZXN0ZWQgPSBvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm5lc3RlZCA9PT0gXCJib29sZWFuXCIgPyBvcHRpb25zLm5lc3RlZCA6IHRydWU7XG4gIGxldCBzdGFydEluZGV4ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5zdGFydEluZGV4KSB8fCAwO1xuICBsZXQgdGFnO1xuICB3aGlsZSAoKHRhZyA9IGZpbmRUYWdCeU5hbWUoeG1sLCB0YWdOYW1lLCB7IGRlYnVnLCBzdGFydEluZGV4IH0pKSkge1xuICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgIHN0YXJ0SW5kZXggPSB0YWcuc3RhcnQgKyAxICsgdGFnTmFtZS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0SW5kZXggPSB0YWcuZW5kO1xuICAgIH1cbiAgICB0YWdzLnB1c2godGFnKTtcbiAgfVxuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiZmluZFRhZ3NCeU5hbWUgZm91bmRcIiwgdGFncy5sZW5ndGgsIFwidGFnc1wiKTtcbiAgcmV0dXJuIHRhZ3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZFRhZ3NCeU5hbWU7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZmluZFRhZ3NCeU5hbWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/node_modules/xml-utils/find-tags-by-name.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/node_modules/xml-utils/get-attribute.js":
/*!**********************************************************************!*\
  !*** ./node_modules/geotiff/node_modules/xml-utils/get-attribute.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function getAttribute(tag, attributeName, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) console.log(\"[xml-utils] getting \" + attributeName + \" in \" + tag);\n\n  const xml = typeof tag === \"object\" ? tag.outer : tag;\n\n  // only search for attributes in the opening tag\n  const opening = xml.slice(0, xml.indexOf(\">\") + 1);\n\n  const quotechars = ['\"', \"'\"];\n  for (let i = 0; i < quotechars.length; i++) {\n    const char = quotechars[i];\n    const pattern = attributeName + \"\\\\=\" + char + \"([^\" + char + \"]*)\" + char;\n    if (debug) console.log(\"[xml-utils] pattern:\", pattern);\n\n    const re = new RegExp(pattern);\n    const match = re.exec(opening);\n    if (debug) console.log(\"[xml-utils] match:\", match);\n    if (match) return match[1];\n  }\n}\n\nmodule.exports = getAttribute;\nmodule.exports[\"default\"] = getAttribute;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL25vZGVfbW9kdWxlcy94bWwtdXRpbHMvZ2V0LWF0dHJpYnV0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2dldC1hdHRyaWJ1dGUuanM/MTVjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBnZXRBdHRyaWJ1dGUodGFnLCBhdHRyaWJ1dGVOYW1lLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRlYnVnID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZykgfHwgZmFsc2U7XG4gIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJbeG1sLXV0aWxzXSBnZXR0aW5nIFwiICsgYXR0cmlidXRlTmFtZSArIFwiIGluIFwiICsgdGFnKTtcblxuICBjb25zdCB4bWwgPSB0eXBlb2YgdGFnID09PSBcIm9iamVjdFwiID8gdGFnLm91dGVyIDogdGFnO1xuXG4gIC8vIG9ubHkgc2VhcmNoIGZvciBhdHRyaWJ1dGVzIGluIHRoZSBvcGVuaW5nIHRhZ1xuICBjb25zdCBvcGVuaW5nID0geG1sLnNsaWNlKDAsIHhtbC5pbmRleE9mKFwiPlwiKSArIDEpO1xuXG4gIGNvbnN0IHF1b3RlY2hhcnMgPSBbJ1wiJywgXCInXCJdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHF1b3RlY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gcXVvdGVjaGFyc1tpXTtcbiAgICBjb25zdCBwYXR0ZXJuID0gYXR0cmlidXRlTmFtZSArIFwiXFxcXD1cIiArIGNoYXIgKyBcIihbXlwiICsgY2hhciArIFwiXSopXCIgKyBjaGFyO1xuICAgIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJbeG1sLXV0aWxzXSBwYXR0ZXJuOlwiLCBwYXR0ZXJuKTtcblxuICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgICBjb25zdCBtYXRjaCA9IHJlLmV4ZWMob3BlbmluZyk7XG4gICAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcIlt4bWwtdXRpbHNdIG1hdGNoOlwiLCBtYXRjaCk7XG4gICAgaWYgKG1hdGNoKSByZXR1cm4gbWF0Y2hbMV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBdHRyaWJ1dGU7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0QXR0cmlidXRlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/node_modules/xml-utils/get-attribute.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/node_modules/xml-utils/index-of-match-end.js":
/*!***************************************************************************!*\
  !*** ./node_modules/geotiff/node_modules/xml-utils/index-of-match-end.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function indexOfMatchEnd(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index + match[0].length - 1;\n  else return -1;\n}\n\nmodule.exports = indexOfMatchEnd;\nmodule.exports[\"default\"] = indexOfMatchEnd;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL25vZGVfbW9kdWxlcy94bWwtdXRpbHMvaW5kZXgtb2YtbWF0Y2gtZW5kLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2luZGV4LW9mLW1hdGNoLWVuZC5qcz82NGM0Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGluZGV4T2ZNYXRjaEVuZCh4bWwsIHBhdHRlcm4sIHN0YXJ0SW5kZXgpIHtcbiAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xuICBjb25zdCBtYXRjaCA9IHJlLmV4ZWMoeG1sLnNsaWNlKHN0YXJ0SW5kZXgpKTtcbiAgaWYgKG1hdGNoKSByZXR1cm4gc3RhcnRJbmRleCArIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIC0gMTtcbiAgZWxzZSByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5kZXhPZk1hdGNoRW5kO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGluZGV4T2ZNYXRjaEVuZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/node_modules/xml-utils/index-of-match-end.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/node_modules/xml-utils/index-of-match.js":
/*!***********************************************************************!*\
  !*** ./node_modules/geotiff/node_modules/xml-utils/index-of-match.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function indexOfMatch(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index;\n  else return -1;\n}\n\nmodule.exports = indexOfMatch;\nmodule.exports[\"default\"] = indexOfMatch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL25vZGVfbW9kdWxlcy94bWwtdXRpbHMvaW5kZXgtb2YtbWF0Y2guanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL25vZGVfbW9kdWxlcy94bWwtdXRpbHMvaW5kZXgtb2YtbWF0Y2guanM/OGYzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBpbmRleE9mTWF0Y2goeG1sLCBwYXR0ZXJuLCBzdGFydEluZGV4KSB7XG4gIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgY29uc3QgbWF0Y2ggPSByZS5leGVjKHhtbC5zbGljZShzdGFydEluZGV4KSk7XG4gIGlmIChtYXRjaCkgcmV0dXJuIHN0YXJ0SW5kZXggKyBtYXRjaC5pbmRleDtcbiAgZWxzZSByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5kZXhPZk1hdGNoO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGluZGV4T2ZNYXRjaDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/node_modules/xml-utils/index-of-match.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBLFNBQVMsVUFBVTs7QUFFbkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz9kMDgwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/native-url/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/native-url/index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={452:function(e){\"use strict\";e.exports=__webpack_require__(/*! next/dist/compiled/querystring-es3 */ \"(app-pages-browser)/./node_modules/next/dist/compiled/querystring-es3/index.js\")}};var t={};function __nccwpck_require__(o){var a=t[o];if(a!==undefined){return a.exports}var s=t[o]={exports:{}};var n=true;try{e[o](s,s.exports,__nccwpck_require__);n=false}finally{if(n)delete t[o]}return s.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var o={};!function(){var e=o;var t,a=(t=__nccwpck_require__(452))&&\"object\"==typeof t&&\"default\"in t?t.default:t,s=/https?|ftp|gopher|file/;function r(e){\"string\"==typeof e&&(e=d(e));var t=function(e,t,o){var a=e.auth,s=e.hostname,n=e.protocol||\"\",p=e.pathname||\"\",c=e.hash||\"\",i=e.query||\"\",u=!1;a=a?encodeURIComponent(a).replace(/%3A/i,\":\")+\"@\":\"\",e.host?u=a+e.host:s&&(u=a+(~s.indexOf(\":\")?\"[\"+s+\"]\":s),e.port&&(u+=\":\"+e.port)),i&&\"object\"==typeof i&&(i=t.encode(i));var f=e.search||i&&\"?\"+i||\"\";return n&&\":\"!==n.substr(-1)&&(n+=\":\"),e.slashes||(!n||o.test(n))&&!1!==u?(u=\"//\"+(u||\"\"),p&&\"/\"!==p[0]&&(p=\"/\"+p)):u||(u=\"\"),c&&\"#\"!==c[0]&&(c=\"#\"+c),f&&\"?\"!==f[0]&&(f=\"?\"+f),{protocol:n,host:u,pathname:p=p.replace(/[?#]/g,encodeURIComponent),search:f=f.replace(\"#\",\"%23\"),hash:c}}(e,a,s);return\"\"+t.protocol+t.host+t.pathname+t.search+t.hash}var n=\"http://\",p=\"w.w\",c=n+p,i=/^([a-z0-9.+-]*:\\/\\/\\/)([a-z0-9.+-]:\\/*)?/i,u=/https?|ftp|gopher|file/;function h(e,t){var o=\"string\"==typeof e?d(e):e;e=\"object\"==typeof e?r(e):e;var a=d(t),s=\"\";o.protocol&&!o.slashes&&(s=o.protocol,e=e.replace(o.protocol,\"\"),s+=\"/\"===t[0]||\"/\"===e[0]?\"/\":\"\"),s&&a.protocol&&(s=\"\",a.slashes||(s=a.protocol,t=t.replace(a.protocol,\"\")));var p=e.match(i);p&&!a.protocol&&(e=e.substr((s=p[1]+(p[2]||\"\")).length),/^\\/\\/[^/]/.test(t)&&(s=s.slice(0,-1)));var f=new URL(e,c+\"/\"),m=new URL(t,f).toString().replace(c,\"\"),v=a.protocol||o.protocol;return v+=o.slashes||a.slashes?\"//\":\"\",!s&&v?m=m.replace(n,v):s&&(m=m.replace(n,\"\")),u.test(m)||~t.indexOf(\".\")||\"/\"===e.slice(-1)||\"/\"===t.slice(-1)||\"/\"!==m.slice(-1)||(m=m.slice(0,-1)),s&&(m=s+(\"/\"===m[0]?m.substr(1):m)),m}function l(){}l.prototype.parse=d,l.prototype.format=r,l.prototype.resolve=h,l.prototype.resolveObject=h;var f=/^https?|ftp|gopher|file/,m=/^(.*?)([#?].*)/,v=/^([a-z0-9.+-]*:)(\\/{0,3})(.*)/i,_=/^([a-z0-9.+-]*:)?\\/\\/\\/*/i,b=/^([a-z0-9.+-]*:)(\\/{0,2})\\[(.*)\\]$/i;function d(e,t,o){if(void 0===t&&(t=!1),void 0===o&&(o=!1),e&&\"object\"==typeof e&&e instanceof l)return e;var s=(e=e.trim()).match(m);e=s?s[1].replace(/\\\\/g,\"/\")+s[2]:e.replace(/\\\\/g,\"/\"),b.test(e)&&\"/\"!==e.slice(-1)&&(e+=\"/\");var n=!/(^javascript)/.test(e)&&e.match(v),i=_.test(e),u=\"\";n&&(f.test(n[1])||(u=n[1].toLowerCase(),e=\"\"+n[2]+n[3]),n[2]||(i=!1,f.test(n[1])?(u=n[1],e=\"\"+n[3]):e=\"//\"+n[3]),3!==n[2].length&&1!==n[2].length||(u=n[1],e=\"/\"+n[3]));var g,y=(s?s[1]:e).match(/^https?:\\/\\/[^/]+(:[0-9]+)(?=\\/|$)/),w=y&&y[1],x=new l,C=\"\",U=\"\";try{g=new URL(e)}catch(t){C=t,u||o||!/^\\/\\//.test(e)||/^\\/\\/.+[@.]/.test(e)||(U=\"/\",e=e.substr(1));try{g=new URL(e,c)}catch(e){return x.protocol=u,x.href=u,x}}x.slashes=i&&!U,x.host=g.host===p?\"\":g.host,x.hostname=g.hostname===p?\"\":g.hostname.replace(/(\\[|\\])/g,\"\"),x.protocol=C?u||null:g.protocol,x.search=g.search.replace(/\\\\/g,\"%5C\"),x.hash=g.hash.replace(/\\\\/g,\"%5C\");var j=e.split(\"#\");!x.search&&~j[0].indexOf(\"?\")&&(x.search=\"?\"),x.hash||\"\"!==j[1]||(x.hash=\"#\"),x.query=t?a.decode(g.search.substr(1)):x.search.substr(1),x.pathname=U+(n?function(e){return e.replace(/['^|`]/g,(function(e){return\"%\"+e.charCodeAt().toString(16).toUpperCase()})).replace(/((?:%[0-9A-F]{2})+)/g,(function(e,t){try{return decodeURIComponent(t).split(\"\").map((function(e){var t=e.charCodeAt();return t>256||/^[a-z0-9]$/i.test(e)?e:\"%\"+t.toString(16).toUpperCase()})).join(\"\")}catch(e){return t}}))}(g.pathname):g.pathname),\"about:\"===x.protocol&&\"blank\"===x.pathname&&(x.protocol=\"\",x.pathname=\"\"),C&&\"/\"!==e[0]&&(x.pathname=x.pathname.substr(1)),u&&!f.test(u)&&\"/\"!==e.slice(-1)&&\"/\"===x.pathname&&(x.pathname=\"\"),x.path=x.pathname+x.search,x.auth=[g.username,g.password].map(decodeURIComponent).filter(Boolean).join(\":\"),x.port=g.port,w&&!x.host.endsWith(w)&&(x.host+=w,x.port=w.slice(1)),x.href=U?\"\"+x.pathname+x.search+x.hash:r(x);var q=/^(file)/.test(x.href)?[\"host\",\"hostname\"]:[];return Object.keys(x).forEach((function(e){~q.indexOf(e)||(x[e]=x[e]||null)})),x}e.parse=d,e.format=r,e.resolve=h,e.resolveObject=function(e,t){return d(h(e,t))},e.Url=l}();module.exports=o})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbmF0aXZlLXVybC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGdCQUFnQixhQUFhLFVBQVUsbUJBQU8sQ0FBQywwSEFBb0MsSUFBSSxTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSyxTQUFTLFlBQVksUUFBUSwrR0FBK0csY0FBYyw2QkFBNkIsc0JBQXNCLDRGQUE0Riw2S0FBNkssNkJBQTZCLGlMQUFpTCx5R0FBeUcsUUFBUSxzREFBc0QsdUdBQXVHLGdCQUFnQixnQ0FBZ0MsNEJBQTRCLGdCQUFnQiw4S0FBOEssaUJBQWlCLGdHQUFnRyx3RkFBd0Ysa09BQWtPLGNBQWMsMkZBQTJGLDBFQUEwRSxJQUFJLDZEQUE2RCxJQUFJLGFBQWEsa0JBQWtCLHdGQUF3Riw0QkFBNEIsNkZBQTZGLDREQUE0RCx3S0FBd0ssMkZBQTJGLElBQUksYUFBYSxTQUFTLHlFQUF5RSxJQUFJLGVBQWUsU0FBUyxnQ0FBZ0MscU5BQXFOLG1CQUFtQixvS0FBb0ssd0NBQXdDLG9EQUFvRCwwQkFBMEIsRUFBRSxxQkFBcUIsSUFBSSx3REFBd0QscUJBQXFCLHVFQUF1RSxZQUFZLFNBQVMsVUFBVSxHQUFHLHFiQUFxYixvREFBb0QsMkNBQTJDLGlDQUFpQyxLQUFLLCtEQUErRCxpQkFBaUIsU0FBUyxHQUFHLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL25hdGl2ZS11cmwvaW5kZXguanM/ZWYxZiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17NDUyOmZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1yZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3F1ZXJ5c3RyaW5nLWVzM1wiKX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18obyl7dmFyIGE9dFtvXTtpZihhIT09dW5kZWZpbmVkKXtyZXR1cm4gYS5leHBvcnRzfXZhciBzPXRbb109e2V4cG9ydHM6e319O3ZhciBuPXRydWU7dHJ5e2Vbb10ocyxzLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bj1mYWxzZX1maW5hbGx5e2lmKG4pZGVsZXRlIHRbb119cmV0dXJuIHMuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIG89e307IWZ1bmN0aW9uKCl7dmFyIGU9bzt2YXIgdCxhPSh0PV9fbmNjd3Bja19yZXF1aXJlX18oNDUyKSkmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZcImRlZmF1bHRcImluIHQ/dC5kZWZhdWx0OnQscz0vaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS87ZnVuY3Rpb24gcihlKXtcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9ZChlKSk7dmFyIHQ9ZnVuY3Rpb24oZSx0LG8pe3ZhciBhPWUuYXV0aCxzPWUuaG9zdG5hbWUsbj1lLnByb3RvY29sfHxcIlwiLHA9ZS5wYXRobmFtZXx8XCJcIixjPWUuaGFzaHx8XCJcIixpPWUucXVlcnl8fFwiXCIsdT0hMTthPWE/ZW5jb2RlVVJJQ29tcG9uZW50KGEpLnJlcGxhY2UoLyUzQS9pLFwiOlwiKStcIkBcIjpcIlwiLGUuaG9zdD91PWErZS5ob3N0OnMmJih1PWErKH5zLmluZGV4T2YoXCI6XCIpP1wiW1wiK3MrXCJdXCI6cyksZS5wb3J0JiYodSs9XCI6XCIrZS5wb3J0KSksaSYmXCJvYmplY3RcIj09dHlwZW9mIGkmJihpPXQuZW5jb2RlKGkpKTt2YXIgZj1lLnNlYXJjaHx8aSYmXCI/XCIraXx8XCJcIjtyZXR1cm4gbiYmXCI6XCIhPT1uLnN1YnN0cigtMSkmJihuKz1cIjpcIiksZS5zbGFzaGVzfHwoIW58fG8udGVzdChuKSkmJiExIT09dT8odT1cIi8vXCIrKHV8fFwiXCIpLHAmJlwiL1wiIT09cFswXSYmKHA9XCIvXCIrcCkpOnV8fCh1PVwiXCIpLGMmJlwiI1wiIT09Y1swXSYmKGM9XCIjXCIrYyksZiYmXCI/XCIhPT1mWzBdJiYoZj1cIj9cIitmKSx7cHJvdG9jb2w6bixob3N0OnUscGF0aG5hbWU6cD1wLnJlcGxhY2UoL1s/I10vZyxlbmNvZGVVUklDb21wb25lbnQpLHNlYXJjaDpmPWYucmVwbGFjZShcIiNcIixcIiUyM1wiKSxoYXNoOmN9fShlLGEscyk7cmV0dXJuXCJcIit0LnByb3RvY29sK3QuaG9zdCt0LnBhdGhuYW1lK3Quc2VhcmNoK3QuaGFzaH12YXIgbj1cImh0dHA6Ly9cIixwPVwidy53XCIsYz1uK3AsaT0vXihbYS16MC05ListXSo6XFwvXFwvXFwvKShbYS16MC05ListXTpcXC8qKT8vaSx1PS9odHRwcz98ZnRwfGdvcGhlcnxmaWxlLztmdW5jdGlvbiBoKGUsdCl7dmFyIG89XCJzdHJpbmdcIj09dHlwZW9mIGU/ZChlKTplO2U9XCJvYmplY3RcIj09dHlwZW9mIGU/cihlKTplO3ZhciBhPWQodCkscz1cIlwiO28ucHJvdG9jb2wmJiFvLnNsYXNoZXMmJihzPW8ucHJvdG9jb2wsZT1lLnJlcGxhY2Uoby5wcm90b2NvbCxcIlwiKSxzKz1cIi9cIj09PXRbMF18fFwiL1wiPT09ZVswXT9cIi9cIjpcIlwiKSxzJiZhLnByb3RvY29sJiYocz1cIlwiLGEuc2xhc2hlc3x8KHM9YS5wcm90b2NvbCx0PXQucmVwbGFjZShhLnByb3RvY29sLFwiXCIpKSk7dmFyIHA9ZS5tYXRjaChpKTtwJiYhYS5wcm90b2NvbCYmKGU9ZS5zdWJzdHIoKHM9cFsxXSsocFsyXXx8XCJcIikpLmxlbmd0aCksL15cXC9cXC9bXi9dLy50ZXN0KHQpJiYocz1zLnNsaWNlKDAsLTEpKSk7dmFyIGY9bmV3IFVSTChlLGMrXCIvXCIpLG09bmV3IFVSTCh0LGYpLnRvU3RyaW5nKCkucmVwbGFjZShjLFwiXCIpLHY9YS5wcm90b2NvbHx8by5wcm90b2NvbDtyZXR1cm4gdis9by5zbGFzaGVzfHxhLnNsYXNoZXM/XCIvL1wiOlwiXCIsIXMmJnY/bT1tLnJlcGxhY2Uobix2KTpzJiYobT1tLnJlcGxhY2UobixcIlwiKSksdS50ZXN0KG0pfHx+dC5pbmRleE9mKFwiLlwiKXx8XCIvXCI9PT1lLnNsaWNlKC0xKXx8XCIvXCI9PT10LnNsaWNlKC0xKXx8XCIvXCIhPT1tLnNsaWNlKC0xKXx8KG09bS5zbGljZSgwLC0xKSkscyYmKG09cysoXCIvXCI9PT1tWzBdP20uc3Vic3RyKDEpOm0pKSxtfWZ1bmN0aW9uIGwoKXt9bC5wcm90b3R5cGUucGFyc2U9ZCxsLnByb3RvdHlwZS5mb3JtYXQ9cixsLnByb3RvdHlwZS5yZXNvbHZlPWgsbC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdD1oO3ZhciBmPS9eaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS8sbT0vXiguKj8pKFsjP10uKikvLHY9L14oW2EtejAtOS4rLV0qOikoXFwvezAsM30pKC4qKS9pLF89L14oW2EtejAtOS4rLV0qOik/XFwvXFwvXFwvKi9pLGI9L14oW2EtejAtOS4rLV0qOikoXFwvezAsMn0pXFxbKC4qKVxcXSQvaTtmdW5jdGlvbiBkKGUsdCxvKXtpZih2b2lkIDA9PT10JiYodD0hMSksdm9pZCAwPT09byYmKG89ITEpLGUmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlIGluc3RhbmNlb2YgbClyZXR1cm4gZTt2YXIgcz0oZT1lLnRyaW0oKSkubWF0Y2gobSk7ZT1zP3NbMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKStzWzJdOmUucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSxiLnRlc3QoZSkmJlwiL1wiIT09ZS5zbGljZSgtMSkmJihlKz1cIi9cIik7dmFyIG49IS8oXmphdmFzY3JpcHQpLy50ZXN0KGUpJiZlLm1hdGNoKHYpLGk9Xy50ZXN0KGUpLHU9XCJcIjtuJiYoZi50ZXN0KG5bMV0pfHwodT1uWzFdLnRvTG93ZXJDYXNlKCksZT1cIlwiK25bMl0rblszXSksblsyXXx8KGk9ITEsZi50ZXN0KG5bMV0pPyh1PW5bMV0sZT1cIlwiK25bM10pOmU9XCIvL1wiK25bM10pLDMhPT1uWzJdLmxlbmd0aCYmMSE9PW5bMl0ubGVuZ3RofHwodT1uWzFdLGU9XCIvXCIrblszXSkpO3ZhciBnLHk9KHM/c1sxXTplKS5tYXRjaCgvXmh0dHBzPzpcXC9cXC9bXi9dKyg6WzAtOV0rKSg/PVxcL3wkKS8pLHc9eSYmeVsxXSx4PW5ldyBsLEM9XCJcIixVPVwiXCI7dHJ5e2c9bmV3IFVSTChlKX1jYXRjaCh0KXtDPXQsdXx8b3x8IS9eXFwvXFwvLy50ZXN0KGUpfHwvXlxcL1xcLy4rW0AuXS8udGVzdChlKXx8KFU9XCIvXCIsZT1lLnN1YnN0cigxKSk7dHJ5e2c9bmV3IFVSTChlLGMpfWNhdGNoKGUpe3JldHVybiB4LnByb3RvY29sPXUseC5ocmVmPXUseH19eC5zbGFzaGVzPWkmJiFVLHguaG9zdD1nLmhvc3Q9PT1wP1wiXCI6Zy5ob3N0LHguaG9zdG5hbWU9Zy5ob3N0bmFtZT09PXA/XCJcIjpnLmhvc3RuYW1lLnJlcGxhY2UoLyhcXFt8XFxdKS9nLFwiXCIpLHgucHJvdG9jb2w9Qz91fHxudWxsOmcucHJvdG9jb2wseC5zZWFyY2g9Zy5zZWFyY2gucmVwbGFjZSgvXFxcXC9nLFwiJTVDXCIpLHguaGFzaD1nLmhhc2gucmVwbGFjZSgvXFxcXC9nLFwiJTVDXCIpO3ZhciBqPWUuc3BsaXQoXCIjXCIpOyF4LnNlYXJjaCYmfmpbMF0uaW5kZXhPZihcIj9cIikmJih4LnNlYXJjaD1cIj9cIikseC5oYXNofHxcIlwiIT09alsxXXx8KHguaGFzaD1cIiNcIikseC5xdWVyeT10P2EuZGVjb2RlKGcuc2VhcmNoLnN1YnN0cigxKSk6eC5zZWFyY2guc3Vic3RyKDEpLHgucGF0aG5hbWU9VSsobj9mdW5jdGlvbihlKXtyZXR1cm4gZS5yZXBsYWNlKC9bJ158YF0vZywoZnVuY3Rpb24oZSl7cmV0dXJuXCIlXCIrZS5jaGFyQ29kZUF0KCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCl9KSkucmVwbGFjZSgvKCg/OiVbMC05QS1GXXsyfSkrKS9nLChmdW5jdGlvbihlLHQpe3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHQpLnNwbGl0KFwiXCIpLm1hcCgoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jaGFyQ29kZUF0KCk7cmV0dXJuIHQ+MjU2fHwvXlthLXowLTldJC9pLnRlc3QoZSk/ZTpcIiVcIit0LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfSkpLmpvaW4oXCJcIil9Y2F0Y2goZSl7cmV0dXJuIHR9fSkpfShnLnBhdGhuYW1lKTpnLnBhdGhuYW1lKSxcImFib3V0OlwiPT09eC5wcm90b2NvbCYmXCJibGFua1wiPT09eC5wYXRobmFtZSYmKHgucHJvdG9jb2w9XCJcIix4LnBhdGhuYW1lPVwiXCIpLEMmJlwiL1wiIT09ZVswXSYmKHgucGF0aG5hbWU9eC5wYXRobmFtZS5zdWJzdHIoMSkpLHUmJiFmLnRlc3QodSkmJlwiL1wiIT09ZS5zbGljZSgtMSkmJlwiL1wiPT09eC5wYXRobmFtZSYmKHgucGF0aG5hbWU9XCJcIikseC5wYXRoPXgucGF0aG5hbWUreC5zZWFyY2gseC5hdXRoPVtnLnVzZXJuYW1lLGcucGFzc3dvcmRdLm1hcChkZWNvZGVVUklDb21wb25lbnQpLmZpbHRlcihCb29sZWFuKS5qb2luKFwiOlwiKSx4LnBvcnQ9Zy5wb3J0LHcmJiF4Lmhvc3QuZW5kc1dpdGgodykmJih4Lmhvc3QrPXcseC5wb3J0PXcuc2xpY2UoMSkpLHguaHJlZj1VP1wiXCIreC5wYXRobmFtZSt4LnNlYXJjaCt4Lmhhc2g6cih4KTt2YXIgcT0vXihmaWxlKS8udGVzdCh4LmhyZWYpP1tcImhvc3RcIixcImhvc3RuYW1lXCJdOltdO3JldHVybiBPYmplY3Qua2V5cyh4KS5mb3JFYWNoKChmdW5jdGlvbihlKXt+cS5pbmRleE9mKGUpfHwoeFtlXT14W2VdfHxudWxsKX0pKSx4fWUucGFyc2U9ZCxlLmZvcm1hdD1yLGUucmVzb2x2ZT1oLGUucmVzb2x2ZU9iamVjdD1mdW5jdGlvbihlLHQpe3JldHVybiBkKGgoZSx0KSl9LGUuVXJsPWx9KCk7bW9kdWxlLmV4cG9ydHM9b30pKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/native-url/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/querystring-es3/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/querystring-es3/index.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){\"use strict\";var e={815:function(e){function hasOwnProperty(e,r){return Object.prototype.hasOwnProperty.call(e,r)}e.exports=function(e,n,t,o){n=n||\"&\";t=t||\"=\";var a={};if(typeof e!==\"string\"||e.length===0){return a}var i=/\\+/g;e=e.split(n);var u=1e3;if(o&&typeof o.maxKeys===\"number\"){u=o.maxKeys}var c=e.length;if(u>0&&c>u){c=u}for(var p=0;p<c;++p){var f=e[p].replace(i,\"%20\"),s=f.indexOf(t),_,l,y,d;if(s>=0){_=f.substr(0,s);l=f.substr(s+1)}else{_=f;l=\"\"}y=decodeURIComponent(_);d=decodeURIComponent(l);if(!hasOwnProperty(a,y)){a[y]=d}else if(r(a[y])){a[y].push(d)}else{a[y]=[a[y],d]}}return a};var r=Array.isArray||function(e){return Object.prototype.toString.call(e)===\"[object Array]\"}},577:function(e){var stringifyPrimitive=function(e){switch(typeof e){case\"string\":return e;case\"boolean\":return e?\"true\":\"false\";case\"number\":return isFinite(e)?e:\"\";default:return\"\"}};e.exports=function(e,t,o,a){t=t||\"&\";o=o||\"=\";if(e===null){e=undefined}if(typeof e===\"object\"){return map(n(e),(function(n){var a=encodeURIComponent(stringifyPrimitive(n))+o;if(r(e[n])){return map(e[n],(function(e){return a+encodeURIComponent(stringifyPrimitive(e))})).join(t)}else{return a+encodeURIComponent(stringifyPrimitive(e[n]))}})).join(t)}if(!a)return\"\";return encodeURIComponent(stringifyPrimitive(a))+o+encodeURIComponent(stringifyPrimitive(e))};var r=Array.isArray||function(e){return Object.prototype.toString.call(e)===\"[object Array]\"};function map(e,r){if(e.map)return e.map(r);var n=[];for(var t=0;t<e.length;t++){n.push(r(e[t],t))}return n}var n=Object.keys||function(e){var r=[];for(var n in e){if(Object.prototype.hasOwnProperty.call(e,n))r.push(n)}return r}}};var r={};function __nccwpck_require__(n){var t=r[n];if(t!==undefined){return t.exports}var o=r[n]={exports:{}};var a=true;try{e[n](o,o.exports,__nccwpck_require__);a=false}finally{if(a)delete r[n]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var n={};!function(){var e=n;e.decode=e.parse=__nccwpck_require__(815);e.encode=e.stringify=__nccwpck_require__(577)}();module.exports=n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLGFBQWEsT0FBTyxnQkFBZ0IsNkJBQTZCLGlEQUFpRCw0QkFBNEIsU0FBUyxTQUFTLFNBQVMsc0NBQXNDLFNBQVMsWUFBWSxhQUFhLFVBQVUsbUNBQW1DLFlBQVksZUFBZSxhQUFhLElBQUksWUFBWSxJQUFJLEtBQUssbURBQW1ELFNBQVMsZ0JBQWdCLGdCQUFnQixLQUFLLElBQUksS0FBSyx3QkFBd0Isd0JBQXdCLHlCQUF5QixPQUFPLGlCQUFpQixhQUFhLEtBQUssZUFBZSxVQUFVLGlDQUFpQyw2REFBNkQsaUJBQWlCLG1DQUFtQyxpQkFBaUIsc0JBQXNCLHNDQUFzQyxxQ0FBcUMsbUJBQW1CLDRCQUE0QixTQUFTLFNBQVMsYUFBYSxZQUFZLHdCQUF3Qiw2QkFBNkIsa0RBQWtELFlBQVksNkJBQTZCLG1EQUFtRCxXQUFXLEtBQUssdURBQXVELFdBQVcsZUFBZSw4RkFBOEYsaUNBQWlDLDZEQUE2RCxrQkFBa0IseUJBQXlCLFNBQVMsWUFBWSxXQUFXLEtBQUssa0JBQWtCLFNBQVMsK0JBQStCLFNBQVMsZ0JBQWdCLHVEQUF1RCxZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLFNBQVMsWUFBWSxRQUFRLDBDQUEwQyw4Q0FBOEMsR0FBRyxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9xdWVyeXN0cmluZy1lczMvaW5kZXguanM/MzdkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgZT17ODE1OmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGhhc093blByb3BlcnR5KGUscil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpfWUuZXhwb3J0cz1mdW5jdGlvbihlLG4sdCxvKXtuPW58fFwiJlwiO3Q9dHx8XCI9XCI7dmFyIGE9e307aWYodHlwZW9mIGUhPT1cInN0cmluZ1wifHxlLmxlbmd0aD09PTApe3JldHVybiBhfXZhciBpPS9cXCsvZztlPWUuc3BsaXQobik7dmFyIHU9MWUzO2lmKG8mJnR5cGVvZiBvLm1heEtleXM9PT1cIm51bWJlclwiKXt1PW8ubWF4S2V5c312YXIgYz1lLmxlbmd0aDtpZih1PjAmJmM+dSl7Yz11fWZvcih2YXIgcD0wO3A8YzsrK3Ape3ZhciBmPWVbcF0ucmVwbGFjZShpLFwiJTIwXCIpLHM9Zi5pbmRleE9mKHQpLF8sbCx5LGQ7aWYocz49MCl7Xz1mLnN1YnN0cigwLHMpO2w9Zi5zdWJzdHIocysxKX1lbHNle189ZjtsPVwiXCJ9eT1kZWNvZGVVUklDb21wb25lbnQoXyk7ZD1kZWNvZGVVUklDb21wb25lbnQobCk7aWYoIWhhc093blByb3BlcnR5KGEseSkpe2FbeV09ZH1lbHNlIGlmKHIoYVt5XSkpe2FbeV0ucHVzaChkKX1lbHNle2FbeV09W2FbeV0sZF19fXJldHVybiBhfTt2YXIgcj1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpPT09XCJbb2JqZWN0IEFycmF5XVwifX0sNTc3OmZ1bmN0aW9uKGUpe3ZhciBzdHJpbmdpZnlQcmltaXRpdmU9ZnVuY3Rpb24oZSl7c3dpdGNoKHR5cGVvZiBlKXtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gZTtjYXNlXCJib29sZWFuXCI6cmV0dXJuIGU/XCJ0cnVlXCI6XCJmYWxzZVwiO2Nhc2VcIm51bWJlclwiOnJldHVybiBpc0Zpbml0ZShlKT9lOlwiXCI7ZGVmYXVsdDpyZXR1cm5cIlwifX07ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxvLGEpe3Q9dHx8XCImXCI7bz1vfHxcIj1cIjtpZihlPT09bnVsbCl7ZT11bmRlZmluZWR9aWYodHlwZW9mIGU9PT1cIm9iamVjdFwiKXtyZXR1cm4gbWFwKG4oZSksKGZ1bmN0aW9uKG4pe3ZhciBhPWVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobikpK287aWYocihlW25dKSl7cmV0dXJuIG1hcChlW25dLChmdW5jdGlvbihlKXtyZXR1cm4gYStlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGUpKX0pKS5qb2luKHQpfWVsc2V7cmV0dXJuIGErZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShlW25dKSl9fSkpLmpvaW4odCl9aWYoIWEpcmV0dXJuXCJcIjtyZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShhKSkrbytlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGUpKX07dmFyIHI9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKT09PVwiW29iamVjdCBBcnJheV1cIn07ZnVuY3Rpb24gbWFwKGUscil7aWYoZS5tYXApcmV0dXJuIGUubWFwKHIpO3ZhciBuPVtdO2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtuLnB1c2gocihlW3RdLHQpKX1yZXR1cm4gbn12YXIgbj1PYmplY3Qua2V5c3x8ZnVuY3Rpb24oZSl7dmFyIHI9W107Zm9yKHZhciBuIGluIGUpe2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pKXIucHVzaChuKX1yZXR1cm4gcn19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKG4pe3ZhciB0PXJbbl07aWYodCE9PXVuZGVmaW5lZCl7cmV0dXJuIHQuZXhwb3J0c312YXIgbz1yW25dPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW25dKG8sby5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW25dfXJldHVybiBvLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciBuPXt9OyFmdW5jdGlvbigpe3ZhciBlPW47ZS5kZWNvZGU9ZS5wYXJzZT1fX25jY3dwY2tfcmVxdWlyZV9fKDgxNSk7ZS5lbmNvZGU9ZS5zdHJpbmdpZnk9X19uY2N3cGNrX3JlcXVpcmVfXyg1NzcpfSgpO21vZHVsZS5leHBvcnRzPW59KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/querystring-es3/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/analysis/page.tsx":
/*!*******************************!*\
  !*** ./app/analysis/page.tsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Analysis; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _components_Container__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/Container */ \"(app-pages-browser)/./components/Container.tsx\");\n/* harmony import */ var _ui_fonts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ui/fonts */ \"(app-pages-browser)/./ui/fonts.ts\");\n/* harmony import */ var _components_AddressSearch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/AddressSearch */ \"(app-pages-browser)/./components/AddressSearch.tsx\");\n/* harmony import */ var _components_MapImage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/MapImage */ \"(app-pages-browser)/./components/MapImage.tsx\");\n/* harmony import */ var _components_Trends__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/components/Trends */ \"(app-pages-browser)/./components/Trends.tsx\");\n/* harmony import */ var _components_LandUsePlanning__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/components/LandUsePlanning */ \"(app-pages-browser)/./components/LandUsePlanning.tsx\");\n/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! chroma-js */ \"(app-pages-browser)/./node_modules/chroma-js/chroma.js\");\n/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(chroma_js__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _types_valuesToNames__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/types/valuesToNames */ \"(app-pages-browser)/./types/valuesToNames.ts\");\n/* harmony import */ var geotiff__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! geotiff */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/geotiff.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\nconst DEMO_ADDRESS = {\n    address: \"8159 Side Road 30, Wellington County, Ontario, N0B 2K0, Canada\",\n    lat: \"43.6929954\",\n    lng: \"-80.3071343\"\n};\nfunction Analysis() {\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_1__.useRouter)();\n    const searchParams = (0,next_navigation__WEBPACK_IMPORTED_MODULE_1__.useSearchParams)();\n    const address = searchParams.get(\"address\");\n    const lat = searchParams.get(\"lat\");\n    const lng = searchParams.get(\"lng\");\n    // PROPERTY \n    // Callback to handle new selected address in property\n    const handleNewAddressSelect = (newAddress, newLat, newLng)=>{\n        router.push(\"/analysis?address=\".concat(encodeURIComponent(newAddress), \"&lat=\").concat(newLat, \"&lng=\").concat(newLng));\n    };\n    // Check if the current address is the demo address\n    const isDemoAddress = address === DEMO_ADDRESS.address;\n    // LAND HISTORY\n    // Load Raster data\n    const rasterDataCache = useRef();\n    const [landHistoryYear, setLandHistoryYear] = useState(2014);\n    const [rasterData, setRasterData] = useState(null);\n    const colors = chroma_js__WEBPACK_IMPORTED_MODULE_8___default().scale(\"Set1\").colors(Object.keys(_types_valuesToNames__WEBPACK_IMPORTED_MODULE_9__.valuesToNames).length);\n    // Fetch raster data for all years on mount\n    useEffect(()=>{\n        const fetchAllRasterData = async ()=>{\n            const years = [\n                2014,\n                2015,\n                2016,\n                2017,\n                2018,\n                2019,\n                2020,\n                2021\n            ];\n            const rasterDataForYears = {};\n            for (const yr of years){\n                const rasterFile = \"/demo/land_history/prior_inventory/\".concat(yr, \".tif\");\n                const data = await fetchRasterData(rasterFile);\n                rasterDataForYears[yr] = data;\n            }\n            // Store all fetched data in cache\n            rasterDataCache.current = rasterDataForYears;\n            // Set initial year data\n            setRasterData(rasterDataForYears[year]);\n        };\n        fetchAllRasterData();\n    }, []);\n    const fetchRasterData = async (url)=>{\n        const response = await fetch(url);\n        const arrayBuffer = await response.arrayBuffer();\n        const tiff = await (0,geotiff__WEBPACK_IMPORTED_MODULE_10__.fromArrayBuffer)(arrayBuffer);\n        const image = await tiff.getImage();\n        const data = await image.readRasters();\n        const width = image.getWidth();\n        const height = image.getHeight();\n        const imageUrl = rasterToImageURL(data, width, height);\n        const uniqueElements = new Set(data[0]);\n        const legend = {};\n        uniqueElements.forEach((value)=>{\n            const name = _types_valuesToNames__WEBPACK_IMPORTED_MODULE_9__.valuesToNames[value];\n            if (name && name != \"Cloud\") {\n                const index = Object.keys(_types_valuesToNames__WEBPACK_IMPORTED_MODULE_9__.valuesToNames).findIndex((key)=>parseInt(key) === value);\n                legend[name] = colors[index];\n            }\n        });\n        const bbox = image.getBoundingBox();\n        return {\n            imageUrl,\n            legend,\n            bbox\n        };\n    };\n    const rasterToImageURL = function(rasterData, width, height) {\n        let scaleFactor = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5;\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        const ctx = canvas.getContext(\"2d\");\n        ctx.imageSmoothingEnabled = false;\n        const imageData = ctx.createImageData(width, height);\n        // Fill the imageData with the original raster data\n        for(let i = 0; i < rasterData[0].length; i++){\n            const value = rasterData[0][i];\n            const index = Object.keys(_types_valuesToNames__WEBPACK_IMPORTED_MODULE_9__.valuesToNames).findIndex((key)=>parseInt(key) === value);\n            const color = index !== -1 ? chroma_js__WEBPACK_IMPORTED_MODULE_8___default()(colors[index]) : chroma_js__WEBPACK_IMPORTED_MODULE_8___default()(\"black\");\n            const [r, g, b] = color.rgb();\n            let a = 255;\n            if (value == 0 || value == 10) {\n                a = 0;\n            }\n            imageData.data[i * 4] = r;\n            imageData.data[i * 4 + 1] = g;\n            imageData.data[i * 4 + 2] = b;\n            imageData.data[i * 4 + 3] = a;\n        }\n        // Put the imageData on the canvas at original resolution\n        ctx.putImageData(imageData, 0, 0);\n        // Create a new canvas to hold the upscaled version\n        const scaledCanvas = document.createElement(\"canvas\");\n        scaledCanvas.width = width * scaleFactor;\n        scaledCanvas.height = height * scaleFactor;\n        const scaledCtx = scaledCanvas.getContext(\"2d\");\n        scaledCtx.imageSmoothingEnabled = false;\n        scaledCtx.drawImage(canvas, 0, 0, scaledCanvas.width, scaledCanvas.height);\n        return scaledCanvas.toDataURL();\n    };\n    // Update map and legend when the year is changed\n    useEffect(()=>{\n        if (rasterDataCache.current && rasterDataCache.current[landHistoryYear]) {\n            setRasterData(rasterDataCache.current[landHistoryYear]);\n        }\n    }, [\n        landHistoryYear\n    ]);\n    const handleLandHistoryYearChange = (event, newValue)=>{\n        setLandHistoryYear(newValue);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"\".concat(_ui_fonts__WEBPACK_IMPORTED_MODULE_3__.roboto.className, \" bg-accent-light text-black\"),\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"relative m-4\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Container__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                    className: \"mb-4\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                        id: \"property\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"\".concat(_ui_fonts__WEBPACK_IMPORTED_MODULE_3__.merriweather.className, \" text-accent-dark text-2xl pb-2\"),\n                                children: \"Property\"\n                            }, void 0, false, {\n                                fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                lineNumber: 154,\n                                columnNumber: 13\n                            }, this),\n                            isDemoAddress && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"mb-2 text-accent text-xl text-center\",\n                                children: \"This is the demo address!\"\n                            }, void 0, false, {\n                                fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                lineNumber: 159,\n                                columnNumber: 15\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"mb-2\",\n                                children: [\n                                    \"Address: \",\n                                    address\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                lineNumber: 162,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"mb-2\",\n                                children: [\n                                    \"Latitude: \",\n                                    lat\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                lineNumber: 163,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"mb-2\",\n                                children: [\n                                    \"Longitude: \",\n                                    lng\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                lineNumber: 164,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"mt-8\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_AddressSearch__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                    onAddressSelect: handleNewAddressSelect,\n                                    prompt: \"Search for a new address\"\n                                }, void 0, false, {\n                                    fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                    lineNumber: 167,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                lineNumber: 166,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                        lineNumber: 153,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                    lineNumber: 152,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Container__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                    className: \"mb-4\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                        id: \"land-history\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"\".concat(_ui_fonts__WEBPACK_IMPORTED_MODULE_3__.merriweather.className, \" text-accent-dark text-2xl pb-2\"),\n                                children: \"Historical Land Use\"\n                            }, void 0, false, {\n                                fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                lineNumber: 174,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex justify-center items-left\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"mr-4\",\n                                        children: \"Select The Year\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                        lineNumber: 180,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"controls w-32\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Slider, {\n                                            value: landHistoryYear,\n                                            onChange: handleLandHistoryYearChange,\n                                            min: 2014,\n                                            max: 2021,\n                                            step: 1,\n                                            valueLabelDisplay: \"auto\",\n                                            marks: true\n                                        }, void 0, false, {\n                                            fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                            lineNumber: 182,\n                                            columnNumber: 17\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                        lineNumber: 181,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                lineNumber: 179,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_MapImage__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                latitude: lat,\n                                longitude: lng,\n                                zoom: 15,\n                                bbox: rasterData.bbox,\n                                imageUrl: rasterData.imageUrl\n                            }, void 0, false, {\n                                fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                lineNumber: 195,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"legend\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"\".concat(_ui_fonts__WEBPACK_IMPORTED_MODULE_3__.merriweather.className, \" text-center mb-2 font-medium\"),\n                                        children: \"Legend\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                        lineNumber: 199,\n                                        columnNumber: 15\n                                    }, this),\n                                    Object.keys(selectedColors).map((key)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"legend-item\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    className: \"legend-color\",\n                                                    style: {\n                                                        backgroundColor: selectedColors[key]\n                                                    }\n                                                }, void 0, false, {\n                                                    fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                                    lineNumber: 202,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    className: \"legend-label\",\n                                                    children: key\n                                                }, void 0, false, {\n                                                    fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                                    lineNumber: 206,\n                                                    columnNumber: 19\n                                                }, this)\n                                            ]\n                                        }, key, true, {\n                                            fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                            lineNumber: 201,\n                                            columnNumber: 17\n                                        }, this))\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                lineNumber: 198,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                        lineNumber: 173,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                    lineNumber: 172,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Container__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                    className: \"mb-4\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                        id: \"trends\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"\".concat(_ui_fonts__WEBPACK_IMPORTED_MODULE_3__.merriweather.className, \" text-accent-dark text-2xl pb-2\"),\n                                children: \"Trends\"\n                            }, void 0, false, {\n                                fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                lineNumber: 215,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Trends__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {}, void 0, false, {\n                                fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                lineNumber: 219,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                        lineNumber: 214,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                    lineNumber: 213,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Container__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                        id: \"agriculture-tips\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"\".concat(_ui_fonts__WEBPACK_IMPORTED_MODULE_3__.merriweather.className, \" text-accent-dark text-2xl pb-2\"),\n                                children: \"Agriculture Tips\"\n                            }, void 0, false, {\n                                fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                lineNumber: 225,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_LandUsePlanning__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                latitude: lat,\n                                longitude: lng\n                            }, void 0, false, {\n                                fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                                lineNumber: 229,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                        lineNumber: 224,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n                    lineNumber: 223,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n            lineNumber: 151,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/home/liamgraham123/landwise_analytica/landwise-dashboard/app/analysis/page.tsx\",\n        lineNumber: 150,\n        columnNumber: 5\n    }, this);\n}\n_s(Analysis, \"MH5KD/2dB1fsSvZyu/bwdz8FTWo=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_1__.useRouter,\n        next_navigation__WEBPACK_IMPORTED_MODULE_1__.useSearchParams\n    ];\n});\n_c = Analysis;\nvar _c;\n$RefreshReg$(_c, \"Analysis\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9hbmFseXNpcy9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFa0Q7QUFFSDtBQUNlO0FBQ2xCO0FBQ1c7QUFDVjtBQUNKO0FBQ2tCO0FBQzVCO0FBQ3VCO0FBQ1o7QUFFMUMsTUFBTVksZUFBZTtJQUNuQkMsU0FBUztJQUNUQyxLQUFLO0lBQ0xDLEtBQUs7QUFDUDtBQUVlLFNBQVNDOztJQUN0QixNQUFNQyxTQUFTYiwwREFBU0E7SUFFeEIsTUFBTWMsZUFBZWxCLGdFQUFlQTtJQUNwQyxNQUFNYSxVQUFVSyxhQUFhQyxHQUFHLENBQUM7SUFDakMsTUFBTUwsTUFBTUksYUFBYUMsR0FBRyxDQUFDO0lBQzdCLE1BQU1KLE1BQU1HLGFBQWFDLEdBQUcsQ0FBQztJQUU3QixZQUFZO0lBQ1osc0RBQXNEO0lBQ3RELE1BQU1DLHlCQUF5QixDQUFDQyxZQUFvQkMsUUFBZ0JDO1FBQ2xFTixPQUFPTyxJQUFJLENBQUMscUJBQTJERixPQUF0Q0csbUJBQW1CSixhQUFZLFNBQXFCRSxPQUFkRCxRQUFPLFNBQWMsT0FBUEM7SUFDdkY7SUFFQSxtREFBbUQ7SUFDbkQsTUFBTUcsZ0JBQWdCYixZQUFZRCxhQUFhQyxPQUFPO0lBRXRELGVBQWU7SUFFZixtQkFBbUI7SUFDbkIsTUFBTWMsa0JBQWtCQztJQUN4QixNQUFNLENBQUNDLGlCQUFpQkMsbUJBQW1CLEdBQUdDLFNBQVM7SUFDdkQsTUFBTSxDQUFDQyxZQUFZQyxjQUFjLEdBQUdGLFNBQVM7SUFFN0MsTUFBTUcsU0FBU3pCLHNEQUFZLENBQUMsUUFBUXlCLE1BQU0sQ0FBQ0UsT0FBT0MsSUFBSSxDQUFDM0IsK0RBQWFBLEVBQUU0QixNQUFNO0lBRTVFLDJDQUEyQztJQUMzQ0MsVUFBVTtRQUNSLE1BQU1DLHFCQUFxQjtZQUN6QixNQUFNQyxRQUFRO2dCQUFDO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2dCQUFNO2FBQUs7WUFDOUQsTUFBTUMscUJBQXFCLENBQUM7WUFFNUIsS0FBSyxNQUFNQyxNQUFNRixNQUFPO2dCQUN0QixNQUFNRyxhQUFhLHNDQUF5QyxPQUFIRCxJQUFHO2dCQUM1RCxNQUFNRSxPQUFPLE1BQU1DLGdCQUFnQkY7Z0JBQ25DRixrQkFBa0IsQ0FBQ0MsR0FBRyxHQUFHRTtZQUMzQjtZQUVBLGtDQUFrQztZQUNsQ2xCLGdCQUFnQm9CLE9BQU8sR0FBR0w7WUFFMUIsd0JBQXdCO1lBQ3hCVCxjQUFjUyxrQkFBa0IsQ0FBQ00sS0FBSztRQUN4QztRQUVBUjtJQUNGLEdBQUcsRUFBRTtJQUVMLE1BQU1NLGtCQUFrQixPQUFPRztRQUM3QixNQUFNQyxXQUFXLE1BQU1DLE1BQU1GO1FBQzdCLE1BQU1HLGNBQWMsTUFBTUYsU0FBU0UsV0FBVztRQUM5QyxNQUFNQyxPQUFPLE1BQU0xQyx5REFBZUEsQ0FBQ3lDO1FBQ25DLE1BQU1FLFFBQVEsTUFBTUQsS0FBS0UsUUFBUTtRQUNqQyxNQUFNVixPQUFPLE1BQU1TLE1BQU1FLFdBQVc7UUFDcEMsTUFBTUMsUUFBUUgsTUFBTUksUUFBUTtRQUM1QixNQUFNQyxTQUFTTCxNQUFNTSxTQUFTO1FBRTlCLE1BQU1DLFdBQVdDLGlCQUFpQmpCLE1BQU1ZLE9BQU9FO1FBRS9DLE1BQU1JLGlCQUFpQixJQUFJQyxJQUFJbkIsSUFBSSxDQUFDLEVBQUU7UUFDdEMsTUFBTW9CLFNBQVMsQ0FBQztRQUNoQkYsZUFBZUcsT0FBTyxDQUFDLENBQUNDO1lBQ3RCLE1BQU1DLE9BQU8xRCwrREFBYSxDQUFDeUQsTUFBTTtZQUNqQyxJQUFJQyxRQUFRQSxRQUFRLFNBQVM7Z0JBQzNCLE1BQU1DLFFBQVFqQyxPQUFPQyxJQUFJLENBQUMzQiwrREFBYUEsRUFBRTRELFNBQVMsQ0FBQyxDQUFDQyxNQUFRQyxTQUFTRCxTQUFTSjtnQkFDOUVGLE1BQU0sQ0FBQ0csS0FBSyxHQUFHbEMsTUFBTSxDQUFDbUMsTUFBTTtZQUM5QjtRQUNGO1FBQ0EsTUFBTUksT0FBT25CLE1BQU1vQixjQUFjO1FBRWpDLE9BQU87WUFBQ2I7WUFBVUk7WUFBUVE7UUFBSTtJQUNoQztJQUVBLE1BQU1YLG1CQUFtQixTQUFDOUIsWUFBWXlCLE9BQU9FO1lBQVFnQiwrRUFBYztRQUNqRSxNQUFNQyxTQUFTQyxTQUFTQyxhQUFhLENBQUM7UUFDdENGLE9BQU9uQixLQUFLLEdBQUdBO1FBQ2ZtQixPQUFPakIsTUFBTSxHQUFHQTtRQUNoQixNQUFNb0IsTUFBTUgsT0FBT0ksVUFBVSxDQUFDO1FBQzlCRCxJQUFJRSxxQkFBcUIsR0FBRztRQUU1QixNQUFNQyxZQUFZSCxJQUFJSSxlQUFlLENBQUMxQixPQUFPRTtRQUU3QyxtREFBbUQ7UUFDbkQsSUFBSyxJQUFJeUIsSUFBSSxHQUFHQSxJQUFJcEQsVUFBVSxDQUFDLEVBQUUsQ0FBQ00sTUFBTSxFQUFFOEMsSUFBSztZQUM3QyxNQUFNakIsUUFBUW5DLFVBQVUsQ0FBQyxFQUFFLENBQUNvRCxFQUFFO1lBQzlCLE1BQU1mLFFBQVFqQyxPQUFPQyxJQUFJLENBQUMzQiwrREFBYUEsRUFBRTRELFNBQVMsQ0FBQyxDQUFDQyxNQUFRQyxTQUFTRCxTQUFTSjtZQUM5RSxNQUFNa0IsUUFBUWhCLFVBQVUsQ0FBQyxJQUFJNUQsZ0RBQU1BLENBQUN5QixNQUFNLENBQUNtQyxNQUFNLElBQUk1RCxnREFBTUEsQ0FBQztZQUM1RCxNQUFNLENBQUM2RSxHQUFHQyxHQUFHQyxFQUFFLEdBQUdILE1BQU1JLEdBQUc7WUFFM0IsSUFBSUMsSUFBSTtZQUNSLElBQUl2QixTQUFTLEtBQUtBLFNBQVMsSUFBSTtnQkFDN0J1QixJQUFJO1lBQ047WUFFQVIsVUFBVXJDLElBQUksQ0FBQ3VDLElBQUksRUFBRSxHQUFHRTtZQUN4QkosVUFBVXJDLElBQUksQ0FBQ3VDLElBQUksSUFBSSxFQUFFLEdBQUdHO1lBQzVCTCxVQUFVckMsSUFBSSxDQUFDdUMsSUFBSSxJQUFJLEVBQUUsR0FBR0k7WUFDNUJOLFVBQVVyQyxJQUFJLENBQUN1QyxJQUFJLElBQUksRUFBRSxHQUFHTTtRQUM5QjtRQUVBLHlEQUF5RDtRQUN6RFgsSUFBSVksWUFBWSxDQUFDVCxXQUFXLEdBQUc7UUFFL0IsbURBQW1EO1FBQ25ELE1BQU1VLGVBQWVmLFNBQVNDLGFBQWEsQ0FBQztRQUM1Q2MsYUFBYW5DLEtBQUssR0FBR0EsUUFBUWtCO1FBQzdCaUIsYUFBYWpDLE1BQU0sR0FBR0EsU0FBU2dCO1FBQy9CLE1BQU1rQixZQUFZRCxhQUFhWixVQUFVLENBQUM7UUFFMUNhLFVBQVVaLHFCQUFxQixHQUFHO1FBQ2xDWSxVQUFVQyxTQUFTLENBQUNsQixRQUFRLEdBQUcsR0FBR2dCLGFBQWFuQyxLQUFLLEVBQUVtQyxhQUFhakMsTUFBTTtRQUN6RSxPQUFPaUMsYUFBYUcsU0FBUztJQUMvQjtJQUVBLGlEQUFpRDtJQUNqRHhELFVBQVU7UUFDUixJQUFJWixnQkFBZ0JvQixPQUFPLElBQUlwQixnQkFBZ0JvQixPQUFPLENBQUNsQixnQkFBZ0IsRUFBRTtZQUN2RUksY0FBY04sZ0JBQWdCb0IsT0FBTyxDQUFDbEIsZ0JBQWdCO1FBQ3hEO0lBQ0YsR0FBRztRQUFDQTtLQUFnQjtJQUVwQixNQUFNbUUsOEJBQThCLENBQUNDLE9BQU9DO1FBQzFDcEUsbUJBQW1Cb0U7SUFDckI7SUFJQSxxQkFDRSw4REFBQ0M7UUFBSUMsV0FBVyxHQUFvQixPQUFqQmxHLDZDQUFNQSxDQUFDa0csU0FBUyxFQUFDO2tCQUNsQyw0RUFBQ0Q7WUFBSUMsV0FBVTs7OEJBQ2IsOERBQUNuRyw2REFBU0E7b0JBQUNtRyxXQUFVOzhCQUNuQiw0RUFBQ0M7d0JBQVFDLElBQUc7OzBDQUNWLDhEQUFDSDtnQ0FBSUMsV0FBVyxHQUEwQixPQUF2QmpHLG1EQUFZQSxDQUFDaUcsU0FBUyxFQUFDOzBDQUFrQzs7Ozs7OzRCQUkzRTFFLCtCQUNDLDhEQUFDNkU7Z0NBQUVILFdBQVU7MENBQXVDOzs7Ozs7MENBR3RELDhEQUFDRztnQ0FBRUgsV0FBVTs7b0NBQU87b0NBQVV2Rjs7Ozs7OzswQ0FDOUIsOERBQUMwRjtnQ0FBRUgsV0FBVTs7b0NBQU87b0NBQVd0Rjs7Ozs7OzswQ0FDL0IsOERBQUN5RjtnQ0FBRUgsV0FBVTs7b0NBQU87b0NBQVlyRjs7Ozs7OzswQ0FFaEMsOERBQUNvRjtnQ0FBSUMsV0FBVTswQ0FDYiw0RUFBQy9GLGlFQUFhQTtvQ0FBQ21HLGlCQUFpQnBGO29DQUF3QnFGLFFBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OEJBS3JFLDhEQUFDeEcsNkRBQVNBO29CQUFDbUcsV0FBVTs4QkFDbkIsNEVBQUNDO3dCQUFRQyxJQUFHOzswQ0FDViw4REFBQ0g7Z0NBQUlDLFdBQVcsR0FBMEIsT0FBdkJqRyxtREFBWUEsQ0FBQ2lHLFNBQVMsRUFBQzswQ0FBa0M7Ozs7OzswQ0FLNUUsOERBQUNEO2dDQUFJQyxXQUFZOztrREFDZiw4REFBQ0Q7d0NBQUlDLFdBQVk7a0RBQU87Ozs7OztrREFDeEIsOERBQUNEO3dDQUFJQyxXQUFVO2tEQUNiLDRFQUFDTTs0Q0FDQ3ZDLE9BQU90Qzs0Q0FDUDhFLFVBQVVYOzRDQUNWWSxLQUFLOzRDQUNMQyxLQUFLOzRDQUNMQyxNQUFNOzRDQUNOQyxtQkFBa0I7NENBQ2xCQyxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7OzswQ0FNWCw4REFBQzFHLDREQUFRQTtnQ0FBQzJHLFVBQVVuRztnQ0FBS29HLFdBQVduRztnQ0FBS29HLE1BQU07Z0NBQUkxQyxNQUFNekMsV0FBV3lDLElBQUk7Z0NBQUVaLFVBQVU3QixXQUFXNkIsUUFBUTs7Ozs7OzBDQUd2Ryw4REFBQ3NDO2dDQUFJQyxXQUFVOztrREFDYiw4REFBQ0Q7d0NBQUlDLFdBQVcsR0FBMEIsT0FBdkJqRyxtREFBWUEsQ0FBQ2lHLFNBQVMsRUFBQztrREFBZ0M7Ozs7OztvQ0FDekVoRSxPQUFPQyxJQUFJLENBQUMrRSxnQkFBZ0JDLEdBQUcsQ0FBQyxDQUFDOUMsb0JBQ2hDLDhEQUFDNEI7NENBQWNDLFdBQVU7OzhEQUN2Qiw4REFBQ2tCO29EQUNDbEIsV0FBVTtvREFDVm1CLE9BQU87d0RBQUVDLGlCQUFpQkosY0FBYyxDQUFDN0MsSUFBSTtvREFBQzs7Ozs7OzhEQUVoRCw4REFBQytDO29EQUFLbEIsV0FBVTs4REFBZ0I3Qjs7Ozs7OzsyQ0FMeEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCQVlsQiw4REFBQ3RFLDZEQUFTQTtvQkFBQ21HLFdBQVU7OEJBQ25CLDRFQUFDQzt3QkFBUUMsSUFBRzs7MENBQ1YsOERBQUNIO2dDQUFJQyxXQUFXLEdBQTBCLE9BQXZCakcsbURBQVlBLENBQUNpRyxTQUFTLEVBQUM7MENBQWtDOzs7Ozs7MENBSTVFLDhEQUFDN0YsMERBQU1BOzs7Ozs7Ozs7Ozs7Ozs7OzhCQUlYLDhEQUFDTiw2REFBU0E7OEJBQ1IsNEVBQUNvRzt3QkFBUUMsSUFBRzs7MENBQ1YsOERBQUNIO2dDQUFJQyxXQUFXLEdBQTBCLE9BQXZCakcsbURBQVlBLENBQUNpRyxTQUFTLEVBQUM7MENBQWtDOzs7Ozs7MENBSTVFLDhEQUFDNUYsbUVBQWVBO2dDQUFDeUcsVUFBWW5HO2dDQUFLb0csV0FBYW5HOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTTNEO0dBck53QkM7O1FBQ1BaLHNEQUFTQTtRQUVISiw0REFBZUE7OztLQUhkZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2FuYWx5c2lzL3BhZ2UudHN4P2IxMmEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VTZWFyY2hQYXJhbXMgfSBmcm9tICduZXh0L25hdmlnYXRpb24nO1xuaW1wb3J0IE5hdiBmcm9tICdAL2NvbXBvbmVudHMvTmF2JzsgLy8gSW1wb3J0IHRoZSBTaWRlYmFyTmF2IGNvbXBvbmVudFxuaW1wb3J0IENvbnRhaW5lciBmcm9tICdAL2NvbXBvbmVudHMvQ29udGFpbmVyJztcbmltcG9ydCB7IG1vbnRzZXJyYXQsIHJvYm90bywgbWVycml3ZWF0aGVyIH0gZnJvbSAnQC91aS9mb250cyc7XG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L25hdmlnYXRpb24nO1xuaW1wb3J0IEFkZHJlc3NTZWFyY2ggZnJvbSAnQC9jb21wb25lbnRzL0FkZHJlc3NTZWFyY2gnO1xuaW1wb3J0IE1hcEltYWdlIGZyb20gJ0AvY29tcG9uZW50cy9NYXBJbWFnZSc7XG5pbXBvcnQgVHJlbmRzIGZyb20gJ0AvY29tcG9uZW50cy9UcmVuZHMnO1xuaW1wb3J0IExhbmRVc2VQbGFubmluZyBmcm9tICdAL2NvbXBvbmVudHMvTGFuZFVzZVBsYW5uaW5nJztcbmltcG9ydCBjaHJvbWEgZnJvbSAnY2hyb21hLWpzJztcbmltcG9ydCB7IHZhbHVlc1RvTmFtZXMgfSBmcm9tICdAL3R5cGVzL3ZhbHVlc1RvTmFtZXMnO1xuaW1wb3J0IHsgZnJvbUFycmF5QnVmZmVyIH0gZnJvbSBcImdlb3RpZmZcIjtcblxuY29uc3QgREVNT19BRERSRVNTID0ge1xuICBhZGRyZXNzOiBcIjgxNTkgU2lkZSBSb2FkIDMwLCBXZWxsaW5ndG9uIENvdW50eSwgT250YXJpbywgTjBCIDJLMCwgQ2FuYWRhXCIsXG4gIGxhdDogXCI0My42OTI5OTU0XCIsXG4gIGxuZzogXCItODAuMzA3MTM0M1wiXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBbmFseXNpcygpIHtcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG4gICAgXG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHVzZVNlYXJjaFBhcmFtcygpO1xuICBjb25zdCBhZGRyZXNzID0gc2VhcmNoUGFyYW1zLmdldCgnYWRkcmVzcycpO1xuICBjb25zdCBsYXQgPSBzZWFyY2hQYXJhbXMuZ2V0KCdsYXQnKTtcbiAgY29uc3QgbG5nID0gc2VhcmNoUGFyYW1zLmdldCgnbG5nJyk7XG5cbiAgLy8gUFJPUEVSVFkgXG4gIC8vIENhbGxiYWNrIHRvIGhhbmRsZSBuZXcgc2VsZWN0ZWQgYWRkcmVzcyBpbiBwcm9wZXJ0eVxuICBjb25zdCBoYW5kbGVOZXdBZGRyZXNzU2VsZWN0ID0gKG5ld0FkZHJlc3M6IHN0cmluZywgbmV3TGF0OiBudW1iZXIsIG5ld0xuZzogbnVtYmVyKSA9PiB7XG4gICAgcm91dGVyLnB1c2goYC9hbmFseXNpcz9hZGRyZXNzPSR7ZW5jb2RlVVJJQ29tcG9uZW50KG5ld0FkZHJlc3MpfSZsYXQ9JHtuZXdMYXR9JmxuZz0ke25ld0xuZ31gKTtcbiAgfTtcblxuICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCBhZGRyZXNzIGlzIHRoZSBkZW1vIGFkZHJlc3NcbiAgY29uc3QgaXNEZW1vQWRkcmVzcyA9IGFkZHJlc3MgPT09IERFTU9fQUREUkVTUy5hZGRyZXNzO1xuXG4gIC8vIExBTkQgSElTVE9SWVxuXG4gIC8vIExvYWQgUmFzdGVyIGRhdGFcbiAgY29uc3QgcmFzdGVyRGF0YUNhY2hlID0gdXNlUmVmKCk7XG4gIGNvbnN0IFtsYW5kSGlzdG9yeVllYXIsIHNldExhbmRIaXN0b3J5WWVhcl0gPSB1c2VTdGF0ZSgyMDE0KTtcbiAgY29uc3QgW3Jhc3RlckRhdGEsIHNldFJhc3RlckRhdGFdID0gdXNlU3RhdGUobnVsbCk7XG5cbiAgY29uc3QgY29sb3JzID0gY2hyb21hLnNjYWxlKCdTZXQxJykuY29sb3JzKE9iamVjdC5rZXlzKHZhbHVlc1RvTmFtZXMpLmxlbmd0aCk7XG5cbiAgLy8gRmV0Y2ggcmFzdGVyIGRhdGEgZm9yIGFsbCB5ZWFycyBvbiBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGZldGNoQWxsUmFzdGVyRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHllYXJzID0gWzIwMTQsIDIwMTUsIDIwMTYsIDIwMTcsIDIwMTgsIDIwMTksIDIwMjAsIDIwMjFdO1xuICAgICAgY29uc3QgcmFzdGVyRGF0YUZvclllYXJzID0ge307XG5cbiAgICAgIGZvciAoY29uc3QgeXIgb2YgeWVhcnMpIHtcbiAgICAgICAgY29uc3QgcmFzdGVyRmlsZSA9IGAvZGVtby9sYW5kX2hpc3RvcnkvcHJpb3JfaW52ZW50b3J5LyR7eXJ9LnRpZmA7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaFJhc3RlckRhdGEocmFzdGVyRmlsZSk7XG4gICAgICAgIHJhc3RlckRhdGFGb3JZZWFyc1t5cl0gPSBkYXRhO1xuICAgICAgfVxuXG4gICAgICAvLyBTdG9yZSBhbGwgZmV0Y2hlZCBkYXRhIGluIGNhY2hlXG4gICAgICByYXN0ZXJEYXRhQ2FjaGUuY3VycmVudCA9IHJhc3RlckRhdGFGb3JZZWFycztcblxuICAgICAgLy8gU2V0IGluaXRpYWwgeWVhciBkYXRhXG4gICAgICBzZXRSYXN0ZXJEYXRhKHJhc3RlckRhdGFGb3JZZWFyc1t5ZWFyXSk7XG4gICAgfTtcblxuICAgIGZldGNoQWxsUmFzdGVyRGF0YSgpO1xuICB9LCBbXSk7XG4gICAgXG4gIGNvbnN0IGZldGNoUmFzdGVyRGF0YSA9IGFzeW5jICh1cmwpID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7ICAgIFxuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTsgICAgXG4gICAgY29uc3QgdGlmZiA9IGF3YWl0IGZyb21BcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcik7ICAgIFxuICAgIGNvbnN0IGltYWdlID0gYXdhaXQgdGlmZi5nZXRJbWFnZSgpOyAgICBcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgaW1hZ2UucmVhZFJhc3RlcnMoKTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlLmdldFdpZHRoKCk7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICBcbiAgICBjb25zdCBpbWFnZVVybCA9IHJhc3RlclRvSW1hZ2VVUkwoZGF0YSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBjb25zdCB1bmlxdWVFbGVtZW50cyA9IG5ldyBTZXQoZGF0YVswXSk7XG4gICAgY29uc3QgbGVnZW5kID0ge307XG4gICAgdW5pcXVlRWxlbWVudHMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSB2YWx1ZXNUb05hbWVzW3ZhbHVlXTtcbiAgICAgIGlmIChuYW1lICYmIG5hbWUgIT0gJ0Nsb3VkJykge1xuICAgICAgICBjb25zdCBpbmRleCA9IE9iamVjdC5rZXlzKHZhbHVlc1RvTmFtZXMpLmZpbmRJbmRleCgoa2V5KSA9PiBwYXJzZUludChrZXkpID09PSB2YWx1ZSk7XG4gICAgICAgIGxlZ2VuZFtuYW1lXSA9IGNvbG9yc1tpbmRleF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgYmJveCA9IGltYWdlLmdldEJvdW5kaW5nQm94KCkgICAgXG5cbiAgICByZXR1cm4ge2ltYWdlVXJsLCBsZWdlbmQsIGJib3h9O1xuICB9O1xuICAgIFxuICBjb25zdCByYXN0ZXJUb0ltYWdlVVJMID0gKHJhc3RlckRhdGEsIHdpZHRoLCBoZWlnaHQsIHNjYWxlRmFjdG9yID0gNSkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG5cbiAgICAvLyBGaWxsIHRoZSBpbWFnZURhdGEgd2l0aCB0aGUgb3JpZ2luYWwgcmFzdGVyIGRhdGFcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhc3RlckRhdGFbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcmFzdGVyRGF0YVswXVtpXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gT2JqZWN0LmtleXModmFsdWVzVG9OYW1lcykuZmluZEluZGV4KChrZXkpID0+IHBhcnNlSW50KGtleSkgPT09IHZhbHVlKTtcbiAgICAgIGNvbnN0IGNvbG9yID0gaW5kZXggIT09IC0xID8gY2hyb21hKGNvbG9yc1tpbmRleF0pIDogY2hyb21hKCdibGFjaycpO1xuICAgICAgY29uc3QgW3IsIGcsIGJdID0gY29sb3IucmdiKCk7XG5cbiAgICAgIGxldCBhID0gMjU1O1xuICAgICAgaWYgKHZhbHVlID09IDAgfHwgdmFsdWUgPT0gMTApIHtcbiAgICAgICAgYSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGltYWdlRGF0YS5kYXRhW2kgKiA0XSA9IHI7XG4gICAgICBpbWFnZURhdGEuZGF0YVtpICogNCArIDFdID0gZztcbiAgICAgIGltYWdlRGF0YS5kYXRhW2kgKiA0ICsgMl0gPSBiO1xuICAgICAgaW1hZ2VEYXRhLmRhdGFbaSAqIDQgKyAzXSA9IGE7XG4gICAgfVxuXG4gICAgLy8gUHV0IHRoZSBpbWFnZURhdGEgb24gdGhlIGNhbnZhcyBhdCBvcmlnaW5hbCByZXNvbHV0aW9uXG4gICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGNhbnZhcyB0byBob2xkIHRoZSB1cHNjYWxlZCB2ZXJzaW9uXG4gICAgY29uc3Qgc2NhbGVkQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBzY2FsZWRDYW52YXMud2lkdGggPSB3aWR0aCAqIHNjYWxlRmFjdG9yO1xuICAgIHNjYWxlZENhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBzY2FsZUZhY3RvcjtcbiAgICBjb25zdCBzY2FsZWRDdHggPSBzY2FsZWRDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgc2NhbGVkQ3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgIHNjYWxlZEN0eC5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwLCBzY2FsZWRDYW52YXMud2lkdGgsIHNjYWxlZENhbnZhcy5oZWlnaHQpO1xuICAgIHJldHVybiBzY2FsZWRDYW52YXMudG9EYXRhVVJMKCk7XG4gIH07XG5cbiAgLy8gVXBkYXRlIG1hcCBhbmQgbGVnZW5kIHdoZW4gdGhlIHllYXIgaXMgY2hhbmdlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyYXN0ZXJEYXRhQ2FjaGUuY3VycmVudCAmJiByYXN0ZXJEYXRhQ2FjaGUuY3VycmVudFtsYW5kSGlzdG9yeVllYXJdKSB7ICAgICAgICBcbiAgICAgIHNldFJhc3RlckRhdGEocmFzdGVyRGF0YUNhY2hlLmN1cnJlbnRbbGFuZEhpc3RvcnlZZWFyXSk7XG4gICAgfVxuICB9LCBbbGFuZEhpc3RvcnlZZWFyXSk7XG5cbiAgY29uc3QgaGFuZGxlTGFuZEhpc3RvcnlZZWFyQ2hhbmdlID0gKGV2ZW50LCBuZXdWYWx1ZSkgPT4ge1xuICAgIHNldExhbmRIaXN0b3J5WWVhcihuZXdWYWx1ZSk7XG4gIH07XG5cblxuICAgIFxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtyb2JvdG8uY2xhc3NOYW1lfSBiZy1hY2NlbnQtbGlnaHQgdGV4dC1ibGFja2B9PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSBtLTRcIj5cbiAgICAgICAgPENvbnRhaW5lciBjbGFzc05hbWU9XCJtYi00XCI+XG4gICAgICAgICAgPHNlY3Rpb24gaWQ9XCJwcm9wZXJ0eVwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake21lcnJpd2VhdGhlci5jbGFzc05hbWV9IHRleHQtYWNjZW50LWRhcmsgdGV4dC0yeGwgcGItMmB9PlxuICAgICAgICAgICAgICAgIFByb3BlcnR5XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAge2lzRGVtb0FkZHJlc3MgJiYgKFxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJtYi0yIHRleHQtYWNjZW50IHRleHQteGwgdGV4dC1jZW50ZXJcIj5UaGlzIGlzIHRoZSBkZW1vIGFkZHJlc3MhPC9wPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJtYi0yXCI+QWRkcmVzczoge2FkZHJlc3N9PC9wPlxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibWItMlwiPkxhdGl0dWRlOiB7bGF0fTwvcD5cbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cIm1iLTJcIj5Mb25naXR1ZGU6IHtsbmd9PC9wPlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LThcIj5cbiAgICAgICAgICAgICAgPEFkZHJlc3NTZWFyY2ggb25BZGRyZXNzU2VsZWN0PXtoYW5kbGVOZXdBZGRyZXNzU2VsZWN0fSBwcm9tcHQ9XCJTZWFyY2ggZm9yIGEgbmV3IGFkZHJlc3NcIiAvPiBcbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgPC9Db250YWluZXI+XG5cbiAgICAgICAgPENvbnRhaW5lciBjbGFzc05hbWU9XCJtYi00XCI+XG4gICAgICAgICAgPHNlY3Rpb24gaWQ9XCJsYW5kLWhpc3RvcnlcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHttZXJyaXdlYXRoZXIuY2xhc3NOYW1lfSB0ZXh0LWFjY2VudC1kYXJrIHRleHQtMnhsIHBiLTJgfT5cbiAgICAgICAgICAgICAgICBIaXN0b3JpY2FsIExhbmQgVXNlXG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgey8qIExhbmQgSGlzdG9yeSBZZWFyIFNsaWRlciAqL31cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lID0gXCJmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWxlZnRcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWUgPSBcIm1yLTRcIj5TZWxlY3QgVGhlIFllYXI8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250cm9scyB3LTMyXCI+XG4gICAgICAgICAgICAgICAgPFNsaWRlclxuICAgICAgICAgICAgICAgICAgdmFsdWU9e2xhbmRIaXN0b3J5WWVhcn1cbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVMYW5kSGlzdG9yeVllYXJDaGFuZ2V9XG4gICAgICAgICAgICAgICAgICBtaW49ezIwMTR9XG4gICAgICAgICAgICAgICAgICBtYXg9ezIwMjF9XG4gICAgICAgICAgICAgICAgICBzdGVwPXsxfVxuICAgICAgICAgICAgICAgICAgdmFsdWVMYWJlbERpc3BsYXk9XCJhdXRvXCJcbiAgICAgICAgICAgICAgICAgIG1hcmtzXG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9kaXY+ICAgIFxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIHsvKiBJbWFnZSBvbiBNYXAgKi99XG4gICAgICAgICAgICA8TWFwSW1hZ2UgbGF0aXR1ZGU9e2xhdH0gbG9uZ2l0dWRlPXtsbmd9IHpvb209ezE1fSBiYm94PXtyYXN0ZXJEYXRhLmJib3h9IGltYWdlVXJsPXtyYXN0ZXJEYXRhLmltYWdlVXJsfS8+XG5cbiAgICAgICAgICAgIHsvKiBMZWdlbmQgKi99XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImxlZ2VuZFwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7bWVycml3ZWF0aGVyLmNsYXNzTmFtZX0gdGV4dC1jZW50ZXIgbWItMiBmb250LW1lZGl1bWB9PkxlZ2VuZDwvZGl2PlxuICAgICAgICAgICAgICB7T2JqZWN0LmtleXMoc2VsZWN0ZWRDb2xvcnMpLm1hcCgoa2V5KSA9PiAoXG4gICAgICAgICAgICAgICAgPGRpdiBrZXk9e2tleX0gY2xhc3NOYW1lPVwibGVnZW5kLWl0ZW1cIj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImxlZ2VuZC1jb2xvclwiXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7IGJhY2tncm91bmRDb2xvcjogc2VsZWN0ZWRDb2xvcnNba2V5XSB9fVxuICAgICAgICAgICAgICAgICAgPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImxlZ2VuZC1sYWJlbFwiPntrZXl9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgPC9Db250YWluZXI+XG5cbiAgICAgICAgPENvbnRhaW5lciBjbGFzc05hbWU9XCJtYi00XCI+XG4gICAgICAgICAgPHNlY3Rpb24gaWQ9XCJ0cmVuZHNcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHttZXJyaXdlYXRoZXIuY2xhc3NOYW1lfSB0ZXh0LWFjY2VudC1kYXJrIHRleHQtMnhsIHBiLTJgfT5cbiAgICAgICAgICAgICAgICBUcmVuZHNcbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8VHJlbmRzIC8+XG4gICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICA8L0NvbnRhaW5lcj5cblxuICAgICAgICA8Q29udGFpbmVyPlxuICAgICAgICAgIDxzZWN0aW9uIGlkPVwiYWdyaWN1bHR1cmUtdGlwc1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake21lcnJpd2VhdGhlci5jbGFzc05hbWV9IHRleHQtYWNjZW50LWRhcmsgdGV4dC0yeGwgcGItMmB9PlxuICAgICAgICAgICAgICAgIEFncmljdWx0dXJlIFRpcHNcbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8TGFuZFVzZVBsYW5uaW5nIGxhdGl0dWRlID0ge2xhdH0gbG9uZ2l0dWRlID0ge2xuZ30gLz5cbiAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgIDwvQ29udGFpbmVyPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iXSwibmFtZXMiOlsidXNlU2VhcmNoUGFyYW1zIiwiQ29udGFpbmVyIiwicm9ib3RvIiwibWVycml3ZWF0aGVyIiwidXNlUm91dGVyIiwiQWRkcmVzc1NlYXJjaCIsIk1hcEltYWdlIiwiVHJlbmRzIiwiTGFuZFVzZVBsYW5uaW5nIiwiY2hyb21hIiwidmFsdWVzVG9OYW1lcyIsImZyb21BcnJheUJ1ZmZlciIsIkRFTU9fQUREUkVTUyIsImFkZHJlc3MiLCJsYXQiLCJsbmciLCJBbmFseXNpcyIsInJvdXRlciIsInNlYXJjaFBhcmFtcyIsImdldCIsImhhbmRsZU5ld0FkZHJlc3NTZWxlY3QiLCJuZXdBZGRyZXNzIiwibmV3TGF0IiwibmV3TG5nIiwicHVzaCIsImVuY29kZVVSSUNvbXBvbmVudCIsImlzRGVtb0FkZHJlc3MiLCJyYXN0ZXJEYXRhQ2FjaGUiLCJ1c2VSZWYiLCJsYW5kSGlzdG9yeVllYXIiLCJzZXRMYW5kSGlzdG9yeVllYXIiLCJ1c2VTdGF0ZSIsInJhc3RlckRhdGEiLCJzZXRSYXN0ZXJEYXRhIiwiY29sb3JzIiwic2NhbGUiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwidXNlRWZmZWN0IiwiZmV0Y2hBbGxSYXN0ZXJEYXRhIiwieWVhcnMiLCJyYXN0ZXJEYXRhRm9yWWVhcnMiLCJ5ciIsInJhc3RlckZpbGUiLCJkYXRhIiwiZmV0Y2hSYXN0ZXJEYXRhIiwiY3VycmVudCIsInllYXIiLCJ1cmwiLCJyZXNwb25zZSIsImZldGNoIiwiYXJyYXlCdWZmZXIiLCJ0aWZmIiwiaW1hZ2UiLCJnZXRJbWFnZSIsInJlYWRSYXN0ZXJzIiwid2lkdGgiLCJnZXRXaWR0aCIsImhlaWdodCIsImdldEhlaWdodCIsImltYWdlVXJsIiwicmFzdGVyVG9JbWFnZVVSTCIsInVuaXF1ZUVsZW1lbnRzIiwiU2V0IiwibGVnZW5kIiwiZm9yRWFjaCIsInZhbHVlIiwibmFtZSIsImluZGV4IiwiZmluZEluZGV4Iiwia2V5IiwicGFyc2VJbnQiLCJiYm94IiwiZ2V0Qm91bmRpbmdCb3giLCJzY2FsZUZhY3RvciIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImN0eCIsImdldENvbnRleHQiLCJpbWFnZVNtb290aGluZ0VuYWJsZWQiLCJpbWFnZURhdGEiLCJjcmVhdGVJbWFnZURhdGEiLCJpIiwiY29sb3IiLCJyIiwiZyIsImIiLCJyZ2IiLCJhIiwicHV0SW1hZ2VEYXRhIiwic2NhbGVkQ2FudmFzIiwic2NhbGVkQ3R4IiwiZHJhd0ltYWdlIiwidG9EYXRhVVJMIiwiaGFuZGxlTGFuZEhpc3RvcnlZZWFyQ2hhbmdlIiwiZXZlbnQiLCJuZXdWYWx1ZSIsImRpdiIsImNsYXNzTmFtZSIsInNlY3Rpb24iLCJpZCIsInAiLCJvbkFkZHJlc3NTZWxlY3QiLCJwcm9tcHQiLCJTbGlkZXIiLCJvbkNoYW5nZSIsIm1pbiIsIm1heCIsInN0ZXAiLCJ2YWx1ZUxhYmVsRGlzcGxheSIsIm1hcmtzIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJ6b29tIiwic2VsZWN0ZWRDb2xvcnMiLCJtYXAiLCJzcGFuIiwic3R5bGUiLCJiYWNrZ3JvdW5kQ29sb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/analysis/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@petamoriken/float16/src/DataView.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/DataView.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFloat16: function() { return /* binding */ getFloat16; },\n/* harmony export */   setFloat16: function() { return /* binding */ setFloat16; }\n/* harmony export */ });\n/* harmony import */ var _util_arrayIterator_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_util/arrayIterator.mjs */ \"(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs\");\n/* harmony import */ var _util_converter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_util/converter.mjs */ \"(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/converter.mjs\");\n/* harmony import */ var _util_primordials_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_util/primordials.mjs */ \"(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/primordials.mjs\");\n\n\n\n\n/**\n * returns an unsigned 16-bit float at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {[boolean]} opts\n * @returns {number}\n */\nfunction getFloat16(dataView, byteOffset, ...opts) {\n  return (0,_util_converter_mjs__WEBPACK_IMPORTED_MODULE_0__.convertToNumber)(\n    (0,_util_primordials_mjs__WEBPACK_IMPORTED_MODULE_1__.DataViewPrototypeGetUint16)(dataView, byteOffset, ...(0,_util_arrayIterator_mjs__WEBPACK_IMPORTED_MODULE_2__.safeIfNeeded)(opts))\n  );\n}\n\n/**\n * stores an unsigned 16-bit float value at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {number} value\n * @param {[boolean]} opts\n */\nfunction setFloat16(dataView, byteOffset, value, ...opts) {\n  return (0,_util_primordials_mjs__WEBPACK_IMPORTED_MODULE_1__.DataViewPrototypeSetUint16)(\n    dataView,\n    byteOffset,\n    (0,_util_converter_mjs__WEBPACK_IMPORTED_MODULE_0__.roundToFloat16Bits)(value),\n    ...(0,_util_arrayIterator_mjs__WEBPACK_IMPORTED_MODULE_2__.safeIfNeeded)(opts)\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGV0YW1vcmlrZW4vZmxvYXQxNi9zcmMvRGF0YVZpZXcubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXlEO0FBQ21CO0FBSTNDOztBQUVqQztBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEIsYUFBYTtBQUNiO0FBQ087QUFDUCxTQUFTLG9FQUFlO0FBQ3hCLElBQUksaUZBQTBCLDBCQUEwQixxRUFBWTtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEI7QUFDTztBQUNQLFNBQVMsaUZBQTBCO0FBQ25DO0FBQ0E7QUFDQSxJQUFJLHVFQUFrQjtBQUN0QixPQUFPLHFFQUFZO0FBQ25CO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BwZXRhbW9yaWtlbi9mbG9hdDE2L3NyYy9EYXRhVmlldy5tanM/YWFjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzYWZlSWZOZWVkZWQgfSBmcm9tIFwiLi9fdXRpbC9hcnJheUl0ZXJhdG9yLm1qc1wiO1xuaW1wb3J0IHsgY29udmVydFRvTnVtYmVyLCByb3VuZFRvRmxvYXQxNkJpdHMgfSBmcm9tIFwiLi9fdXRpbC9jb252ZXJ0ZXIubWpzXCI7XG5pbXBvcnQge1xuICBEYXRhVmlld1Byb3RvdHlwZUdldFVpbnQxNixcbiAgRGF0YVZpZXdQcm90b3R5cGVTZXRVaW50MTYsXG59IGZyb20gXCIuL191dGlsL3ByaW1vcmRpYWxzLm1qc1wiO1xuXG4vKipcbiAqIHJldHVybnMgYW4gdW5zaWduZWQgMTYtYml0IGZsb2F0IGF0IHRoZSBzcGVjaWZpZWQgYnl0ZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIERhdGFWaWV3XG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlld1xuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVPZmZzZXRcbiAqIEBwYXJhbSB7W2Jvb2xlYW5dfSBvcHRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmxvYXQxNihkYXRhVmlldywgYnl0ZU9mZnNldCwgLi4ub3B0cykge1xuICByZXR1cm4gY29udmVydFRvTnVtYmVyKFxuICAgIERhdGFWaWV3UHJvdG90eXBlR2V0VWludDE2KGRhdGFWaWV3LCBieXRlT2Zmc2V0LCAuLi5zYWZlSWZOZWVkZWQob3B0cykpXG4gICk7XG59XG5cbi8qKlxuICogc3RvcmVzIGFuIHVuc2lnbmVkIDE2LWJpdCBmbG9hdCB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIGJ5dGUgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBEYXRhVmlld1xuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVZpZXdcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlT2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7W2Jvb2xlYW5dfSBvcHRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRGbG9hdDE2KGRhdGFWaWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgLi4ub3B0cykge1xuICByZXR1cm4gRGF0YVZpZXdQcm90b3R5cGVTZXRVaW50MTYoXG4gICAgZGF0YVZpZXcsXG4gICAgYnl0ZU9mZnNldCxcbiAgICByb3VuZFRvRmxvYXQxNkJpdHModmFsdWUpLFxuICAgIC4uLnNhZmVJZk5lZWRlZChvcHRzKVxuICApO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@petamoriken/float16/src/DataView.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   safeIfNeeded: function() { return /* binding */ safeIfNeeded; },\n/* harmony export */   wrap: function() { return /* binding */ wrap; }\n/* harmony export */ });\n/* harmony import */ var _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./primordials.mjs */ \"(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/primordials.mjs\");\n\n\n/** @type {WeakMap<{}, IterableIterator<any>>} */\nconst arrayIterators = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeWeakMap();\n\nconst SafeIteratorPrototype = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectCreate)(null, {\n  next: {\n    value: function next() {\n      const arrayIterator = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.WeakMapPrototypeGet)(arrayIterators, this);\n      return (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayIteratorPrototypeNext)(arrayIterator);\n    },\n  },\n\n  [_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.SymbolIterator]: {\n    value: function values() {\n      return this;\n    },\n  },\n});\n\n/**\n * Wrap the Array around the SafeIterator If Array.prototype [@@iterator] has been modified\n * @type {<T>(array: T[]) => Iterable<T>}\n */\nfunction safeIfNeeded(array) {\n  if (\n    array[_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.SymbolIterator] === _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeArrayPrototypeSymbolIterator &&\n    _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayIteratorPrototype.next === _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayIteratorPrototypeNext\n  ) {\n    return array;\n  }\n\n  const safe = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectCreate)(SafeIteratorPrototype);\n  (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.WeakMapPrototypeSet)(arrayIterators, safe, (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayPrototypeSymbolIterator)(array));\n  return safe;\n}\n\n/** @type {WeakMap<{}, Generator<any>>} */\nconst generators = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeWeakMap();\n\n/** @see https://tc39.es/ecma262/#sec-%arrayiteratorprototype%-object */\nconst DummyArrayIteratorPrototype = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectCreate)(_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.IteratorPrototype, {\n  next: {\n    value: function next() {\n      const generator = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.WeakMapPrototypeGet)(generators, this);\n      return (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.GeneratorPrototypeNext)(generator);\n    },\n    writable: true,\n    configurable: true,\n  },\n});\n\nfor (const key of (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ReflectOwnKeys)(_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayIteratorPrototype)) {\n  // next method has already defined\n  if (key === \"next\") {\n    continue;\n  }\n\n  // Copy ArrayIteratorPrototype descriptors to DummyArrayIteratorPrototype\n  (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectDefineProperty)(DummyArrayIteratorPrototype, key, (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ReflectGetOwnPropertyDescriptor)(_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayIteratorPrototype, key));\n}\n\n/**\n * Wrap the Generator around the dummy ArrayIterator\n * @type {<T>(generator: Generator<T>) => IterableIterator<T>}\n */\nfunction wrap(generator) {\n  const dummy = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectCreate)(DummyArrayIteratorPrototype);\n  (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.WeakMapPrototypeSet)(generators, dummy, generator);\n  return dummy;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGV0YW1vcmlrZW4vZmxvYXQxNi9zcmMvX3V0aWwvYXJyYXlJdGVyYXRvci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBZTJCOztBQUUzQixXQUFXLFVBQVUsMEJBQTBCO0FBQy9DLDJCQUEyQiwyREFBYTs7QUFFeEMsOEJBQThCLDhEQUFZO0FBQzFDO0FBQ0E7QUFDQSw0QkFBNEIscUVBQW1CO0FBQy9DLGFBQWEsNEVBQTBCO0FBQ3ZDLEtBQUs7QUFDTCxHQUFHOztBQUVILEdBQUcsNERBQWM7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBLFVBQVUsNERBQWMsTUFBTSxnRkFBa0M7QUFDaEUsSUFBSSxvRUFBc0IsVUFBVSx3RUFBMEI7QUFDOUQ7QUFDQTtBQUNBOztBQUVBLGVBQWUsOERBQVk7QUFDM0IsRUFBRSxxRUFBbUIsdUJBQXVCLDhFQUE0QjtBQUN4RTtBQUNBOztBQUVBLFdBQVcsVUFBVSxtQkFBbUI7QUFDeEMsdUJBQXVCLDJEQUFhOztBQUVwQztBQUNBLG9DQUFvQyw4REFBWSxDQUFDLCtEQUFpQjtBQUNsRTtBQUNBO0FBQ0Esd0JBQXdCLHFFQUFtQjtBQUMzQyxhQUFhLHdFQUFzQjtBQUNuQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVELGtCQUFrQixnRUFBYyxDQUFDLG9FQUFzQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUUsc0VBQW9CLG1DQUFtQyxpRkFBK0IsQ0FBQyxvRUFBc0I7QUFDL0c7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1AsZ0JBQWdCLDhEQUFZO0FBQzVCLEVBQUUscUVBQW1CO0FBQ3JCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BwZXRhbW9yaWtlbi9mbG9hdDE2L3NyYy9fdXRpbC9hcnJheUl0ZXJhdG9yLm1qcz83ZTgyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFycmF5SXRlcmF0b3JQcm90b3R5cGUsXG4gIEFycmF5SXRlcmF0b3JQcm90b3R5cGVOZXh0LFxuICBBcnJheVByb3RvdHlwZVN5bWJvbEl0ZXJhdG9yLFxuICBHZW5lcmF0b3JQcm90b3R5cGVOZXh0LFxuICBJdGVyYXRvclByb3RvdHlwZSxcbiAgTmF0aXZlQXJyYXlQcm90b3R5cGVTeW1ib2xJdGVyYXRvcixcbiAgTmF0aXZlV2Vha01hcCxcbiAgT2JqZWN0Q3JlYXRlLFxuICBPYmplY3REZWZpbmVQcm9wZXJ0eSxcbiAgUmVmbGVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgUmVmbGVjdE93bktleXMsXG4gIFN5bWJvbEl0ZXJhdG9yLFxuICBXZWFrTWFwUHJvdG90eXBlR2V0LFxuICBXZWFrTWFwUHJvdG90eXBlU2V0LFxufSBmcm9tIFwiLi9wcmltb3JkaWFscy5tanNcIjtcblxuLyoqIEB0eXBlIHtXZWFrTWFwPHt9LCBJdGVyYWJsZUl0ZXJhdG9yPGFueT4+fSAqL1xuY29uc3QgYXJyYXlJdGVyYXRvcnMgPSBuZXcgTmF0aXZlV2Vha01hcCgpO1xuXG5jb25zdCBTYWZlSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3RDcmVhdGUobnVsbCwge1xuICBuZXh0OiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICBjb25zdCBhcnJheUl0ZXJhdG9yID0gV2Vha01hcFByb3RvdHlwZUdldChhcnJheUl0ZXJhdG9ycywgdGhpcyk7XG4gICAgICByZXR1cm4gQXJyYXlJdGVyYXRvclByb3RvdHlwZU5leHQoYXJyYXlJdGVyYXRvcik7XG4gICAgfSxcbiAgfSxcblxuICBbU3ltYm9sSXRlcmF0b3JdOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIH0sXG59KTtcblxuLyoqXG4gKiBXcmFwIHRoZSBBcnJheSBhcm91bmQgdGhlIFNhZmVJdGVyYXRvciBJZiBBcnJheS5wcm90b3R5cGUgW0BAaXRlcmF0b3JdIGhhcyBiZWVuIG1vZGlmaWVkXG4gKiBAdHlwZSB7PFQ+KGFycmF5OiBUW10pID0+IEl0ZXJhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZUlmTmVlZGVkKGFycmF5KSB7XG4gIGlmIChcbiAgICBhcnJheVtTeW1ib2xJdGVyYXRvcl0gPT09IE5hdGl2ZUFycmF5UHJvdG90eXBlU3ltYm9sSXRlcmF0b3IgJiZcbiAgICBBcnJheUl0ZXJhdG9yUHJvdG90eXBlLm5leHQgPT09IEFycmF5SXRlcmF0b3JQcm90b3R5cGVOZXh0XG4gICkge1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIGNvbnN0IHNhZmUgPSBPYmplY3RDcmVhdGUoU2FmZUl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgV2Vha01hcFByb3RvdHlwZVNldChhcnJheUl0ZXJhdG9ycywgc2FmZSwgQXJyYXlQcm90b3R5cGVTeW1ib2xJdGVyYXRvcihhcnJheSkpO1xuICByZXR1cm4gc2FmZTtcbn1cblxuLyoqIEB0eXBlIHtXZWFrTWFwPHt9LCBHZW5lcmF0b3I8YW55Pj59ICovXG5jb25zdCBnZW5lcmF0b3JzID0gbmV3IE5hdGl2ZVdlYWtNYXAoKTtcblxuLyoqIEBzZWUgaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0ICovXG5jb25zdCBEdW1teUFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3RDcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtcbiAgbmV4dDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgY29uc3QgZ2VuZXJhdG9yID0gV2Vha01hcFByb3RvdHlwZUdldChnZW5lcmF0b3JzLCB0aGlzKTtcbiAgICAgIHJldHVybiBHZW5lcmF0b3JQcm90b3R5cGVOZXh0KGdlbmVyYXRvcik7XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gIH0sXG59KTtcblxuZm9yIChjb25zdCBrZXkgb2YgUmVmbGVjdE93bktleXMoQXJyYXlJdGVyYXRvclByb3RvdHlwZSkpIHtcbiAgLy8gbmV4dCBtZXRob2QgaGFzIGFscmVhZHkgZGVmaW5lZFxuICBpZiAoa2V5ID09PSBcIm5leHRcIikge1xuICAgIGNvbnRpbnVlO1xuICB9XG5cbiAgLy8gQ29weSBBcnJheUl0ZXJhdG9yUHJvdG90eXBlIGRlc2NyaXB0b3JzIHRvIER1bW15QXJyYXlJdGVyYXRvclByb3RvdHlwZVxuICBPYmplY3REZWZpbmVQcm9wZXJ0eShEdW1teUFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGtleSwgUmVmbGVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBrZXkpKTtcbn1cblxuLyoqXG4gKiBXcmFwIHRoZSBHZW5lcmF0b3IgYXJvdW5kIHRoZSBkdW1teSBBcnJheUl0ZXJhdG9yXG4gKiBAdHlwZSB7PFQ+KGdlbmVyYXRvcjogR2VuZXJhdG9yPFQ+KSA9PiBJdGVyYWJsZUl0ZXJhdG9yPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcChnZW5lcmF0b3IpIHtcbiAgY29uc3QgZHVtbXkgPSBPYmplY3RDcmVhdGUoRHVtbXlBcnJheUl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgV2Vha01hcFByb3RvdHlwZVNldChnZW5lcmF0b3JzLCBkdW1teSwgZ2VuZXJhdG9yKTtcbiAgcmV0dXJuIGR1bW15O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/converter.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/_util/converter.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertToNumber: function() { return /* binding */ convertToNumber; },\n/* harmony export */   roundToFloat16: function() { return /* binding */ roundToFloat16; },\n/* harmony export */   roundToFloat16Bits: function() { return /* binding */ roundToFloat16Bits; }\n/* harmony export */ });\n/* harmony import */ var _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./primordials.mjs */ \"(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/primordials.mjs\");\n\n\nconst INVERSE_OF_EPSILON = 1 / _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.EPSILON;\n\n/**\n * rounds to the nearest value;\n * if the number falls midway, it is rounded to the nearest value with an even least significant digit\n * @param {number} num\n * @returns {number}\n */\nfunction roundTiesToEven(num) {\n  return (num + INVERSE_OF_EPSILON) - INVERSE_OF_EPSILON;\n}\n\nconst FLOAT16_MIN_VALUE = 6.103515625e-05;\nconst FLOAT16_MAX_VALUE = 65504;\nconst FLOAT16_EPSILON = 0.0009765625;\n\nconst FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE = FLOAT16_EPSILON * FLOAT16_MIN_VALUE;\nconst FLOAT16_EPSILON_DEVIDED_BY_EPSILON = FLOAT16_EPSILON * INVERSE_OF_EPSILON;\n\n/**\n * round a number to a half float number\n * @param {unknown} num - double float\n * @returns {number} half float number\n */\nfunction roundToFloat16(num) {\n  const number = +num;\n\n  // NaN, Infinity, -Infinity, 0, -0\n  if (!(0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NumberIsFinite)(number) || number === 0) {\n    return number;\n  }\n\n  // finite except 0, -0\n  const sign = number > 0 ? 1 : -1;\n  const absolute = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.MathAbs)(number);\n\n  // small number\n  if (absolute < FLOAT16_MIN_VALUE) {\n    return sign * roundTiesToEven(absolute / FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE) * FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE;\n  }\n\n  const temp = (1 + FLOAT16_EPSILON_DEVIDED_BY_EPSILON) * absolute;\n  const result = temp - (temp - absolute);\n\n  // large number\n  if (result > FLOAT16_MAX_VALUE || (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NumberIsNaN)(result)) {\n    return sign * Infinity;\n  }\n\n  return sign * result;\n}\n\n// base algorithm: http://fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst buffer = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeArrayBuffer(4);\nconst floatView = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeFloat32Array(buffer);\nconst uint32View = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint32Array(buffer);\n\nconst baseTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint16Array(512);\nconst shiftTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint8Array(512);\n\nfor (let i = 0; i < 256; ++i) {\n  const e = i - 127;\n\n  // very small number (0, -0)\n  if (e < -24) {\n    baseTable[i]         = 0x0000;\n    baseTable[i | 0x100] = 0x8000;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // small number (denorm)\n  } else if (e < -14) {\n    baseTable[i]         =  0x0400 >> (-e - 14);\n    baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n    shiftTable[i]         = -e - 1;\n    shiftTable[i | 0x100] = -e - 1;\n\n  // normal number\n  } else if (e <= 15) {\n    baseTable[i]         =  (e + 15) << 10;\n    baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n\n  // large number (Infinity, -Infinity)\n  } else if (e < 128) {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // stay (NaN, Infinity, -Infinity)\n  } else {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n  }\n}\n\n/**\n * round a number to a half float number bits\n * @param {unknown} num - double float\n * @returns {number} half float number bits\n */\nfunction roundToFloat16Bits(num) {\n  floatView[0] = roundToFloat16(num);\n  const f = uint32View[0];\n  const e = (f >> 23) & 0x1ff;\n  return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n}\n\nconst mantissaTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint32Array(2048);\nfor (let i = 1; i < 1024; ++i) {\n  let m = i << 13; // zero pad mantissa bits\n  let e = 0; // zero exponent\n\n  // normalized\n  while ((m & 0x00800000) === 0) {\n    m <<= 1;\n    e -= 0x00800000; // decrement exponent\n  }\n\n  m &= ~0x00800000; // clear leading 1 bit\n  e += 0x38800000; // adjust bias\n\n  mantissaTable[i] = m | e;\n}\nfor (let i = 1024; i < 2048; ++i) {\n  mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\n}\n\nconst exponentTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint32Array(64);\nfor (let i = 1; i < 31; ++i) {\n  exponentTable[i] = i << 23;\n}\nexponentTable[31] = 0x47800000;\nexponentTable[32] = 0x80000000;\nfor (let i = 33; i < 63; ++i) {\n  exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n}\nexponentTable[63] = 0xc7800000;\n\nconst offsetTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint16Array(64);\nfor (let i = 1; i < 64; ++i) {\n  if (i !== 32) {\n    offsetTable[i] = 1024;\n  }\n}\n\n/**\n * convert a half float number bits to a number\n * @param {number} float16bits - half float number bits\n * @returns {number} double float\n */\nfunction convertToNumber(float16bits) {\n  const i = float16bits >> 10;\n  uint32View[0] = mantissaTable[offsetTable[i] + (float16bits & 0x3ff)] + exponentTable[i];\n  return floatView[0];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGV0YW1vcmlrZW4vZmxvYXQxNi9zcmMvX3V0aWwvY29udmVydGVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBVTJCOztBQUUzQiwrQkFBK0IscURBQU87O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDTztBQUNQOztBQUVBO0FBQ0EsT0FBTyxnRUFBYztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIseURBQU87O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsNkRBQVc7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQiwrREFBaUI7QUFDcEMsc0JBQXNCLGdFQUFrQjtBQUN4Qyx1QkFBdUIsK0RBQWlCOztBQUV4QyxzQkFBc0IsK0RBQWlCO0FBQ3ZDLHVCQUF1Qiw4REFBZ0I7O0FBRXZDLGdCQUFnQixTQUFTO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLCtEQUFpQjtBQUMzQyxnQkFBZ0IsVUFBVTtBQUMxQixtQkFBbUI7QUFDbkIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEsb0JBQW9CO0FBQ3BCLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7O0FBRUEsMEJBQTBCLCtEQUFpQjtBQUMzQyxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsK0RBQWlCO0FBQ3pDLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL191dGlsL2NvbnZlcnRlci5tanM/OGY4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBFUFNJTE9OLFxuICBNYXRoQWJzLFxuICBOYXRpdmVBcnJheUJ1ZmZlcixcbiAgTmF0aXZlRmxvYXQzMkFycmF5LFxuICBOYXRpdmVVaW50MTZBcnJheSxcbiAgTmF0aXZlVWludDMyQXJyYXksXG4gIE5hdGl2ZVVpbnQ4QXJyYXksXG4gIE51bWJlcklzRmluaXRlLFxuICBOdW1iZXJJc05hTixcbn0gZnJvbSBcIi4vcHJpbW9yZGlhbHMubWpzXCI7XG5cbmNvbnN0IElOVkVSU0VfT0ZfRVBTSUxPTiA9IDEgLyBFUFNJTE9OO1xuXG4vKipcbiAqIHJvdW5kcyB0byB0aGUgbmVhcmVzdCB2YWx1ZTtcbiAqIGlmIHRoZSBudW1iZXIgZmFsbHMgbWlkd2F5LCBpdCBpcyByb3VuZGVkIHRvIHRoZSBuZWFyZXN0IHZhbHVlIHdpdGggYW4gZXZlbiBsZWFzdCBzaWduaWZpY2FudCBkaWdpdFxuICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gcm91bmRUaWVzVG9FdmVuKG51bSkge1xuICByZXR1cm4gKG51bSArIElOVkVSU0VfT0ZfRVBTSUxPTikgLSBJTlZFUlNFX09GX0VQU0lMT047XG59XG5cbmNvbnN0IEZMT0FUMTZfTUlOX1ZBTFVFID0gNi4xMDM1MTU2MjVlLTA1O1xuY29uc3QgRkxPQVQxNl9NQVhfVkFMVUUgPSA2NTUwNDtcbmNvbnN0IEZMT0FUMTZfRVBTSUxPTiA9IDAuMDAwOTc2NTYyNTtcblxuY29uc3QgRkxPQVQxNl9FUFNJTE9OX01VTFRJUExJRURfQllfRkxPQVQxNl9NSU5fVkFMVUUgPSBGTE9BVDE2X0VQU0lMT04gKiBGTE9BVDE2X01JTl9WQUxVRTtcbmNvbnN0IEZMT0FUMTZfRVBTSUxPTl9ERVZJREVEX0JZX0VQU0lMT04gPSBGTE9BVDE2X0VQU0lMT04gKiBJTlZFUlNFX09GX0VQU0lMT047XG5cbi8qKlxuICogcm91bmQgYSBudW1iZXIgdG8gYSBoYWxmIGZsb2F0IG51bWJlclxuICogQHBhcmFtIHt1bmtub3dufSBudW0gLSBkb3VibGUgZmxvYXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGhhbGYgZmxvYXQgbnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZFRvRmxvYXQxNihudW0pIHtcbiAgY29uc3QgbnVtYmVyID0gK251bTtcblxuICAvLyBOYU4sIEluZmluaXR5LCAtSW5maW5pdHksIDAsIC0wXG4gIGlmICghTnVtYmVySXNGaW5pdGUobnVtYmVyKSB8fCBudW1iZXIgPT09IDApIHtcbiAgICByZXR1cm4gbnVtYmVyO1xuICB9XG5cbiAgLy8gZmluaXRlIGV4Y2VwdCAwLCAtMFxuICBjb25zdCBzaWduID0gbnVtYmVyID4gMCA/IDEgOiAtMTtcbiAgY29uc3QgYWJzb2x1dGUgPSBNYXRoQWJzKG51bWJlcik7XG5cbiAgLy8gc21hbGwgbnVtYmVyXG4gIGlmIChhYnNvbHV0ZSA8IEZMT0FUMTZfTUlOX1ZBTFVFKSB7XG4gICAgcmV0dXJuIHNpZ24gKiByb3VuZFRpZXNUb0V2ZW4oYWJzb2x1dGUgLyBGTE9BVDE2X0VQU0lMT05fTVVMVElQTElFRF9CWV9GTE9BVDE2X01JTl9WQUxVRSkgKiBGTE9BVDE2X0VQU0lMT05fTVVMVElQTElFRF9CWV9GTE9BVDE2X01JTl9WQUxVRTtcbiAgfVxuXG4gIGNvbnN0IHRlbXAgPSAoMSArIEZMT0FUMTZfRVBTSUxPTl9ERVZJREVEX0JZX0VQU0lMT04pICogYWJzb2x1dGU7XG4gIGNvbnN0IHJlc3VsdCA9IHRlbXAgLSAodGVtcCAtIGFic29sdXRlKTtcblxuICAvLyBsYXJnZSBudW1iZXJcbiAgaWYgKHJlc3VsdCA+IEZMT0FUMTZfTUFYX1ZBTFVFIHx8IE51bWJlcklzTmFOKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gc2lnbiAqIEluZmluaXR5O1xuICB9XG5cbiAgcmV0dXJuIHNpZ24gKiByZXN1bHQ7XG59XG5cbi8vIGJhc2UgYWxnb3JpdGhtOiBodHRwOi8vZm94LXRvb2xraXQub3JnL2Z0cC9mYXN0aGFsZmZsb2F0Y29udmVyc2lvbi5wZGZcblxuY29uc3QgYnVmZmVyID0gbmV3IE5hdGl2ZUFycmF5QnVmZmVyKDQpO1xuY29uc3QgZmxvYXRWaWV3ID0gbmV3IE5hdGl2ZUZsb2F0MzJBcnJheShidWZmZXIpO1xuY29uc3QgdWludDMyVmlldyA9IG5ldyBOYXRpdmVVaW50MzJBcnJheShidWZmZXIpO1xuXG5jb25zdCBiYXNlVGFibGUgPSBuZXcgTmF0aXZlVWludDE2QXJyYXkoNTEyKTtcbmNvbnN0IHNoaWZ0VGFibGUgPSBuZXcgTmF0aXZlVWludDhBcnJheSg1MTIpO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGNvbnN0IGUgPSBpIC0gMTI3O1xuXG4gIC8vIHZlcnkgc21hbGwgbnVtYmVyICgwLCAtMClcbiAgaWYgKGUgPCAtMjQpIHtcbiAgICBiYXNlVGFibGVbaV0gICAgICAgICA9IDB4MDAwMDtcbiAgICBiYXNlVGFibGVbaSB8IDB4MTAwXSA9IDB4ODAwMDtcbiAgICBzaGlmdFRhYmxlW2ldICAgICAgICAgPSAyNDtcbiAgICBzaGlmdFRhYmxlW2kgfCAweDEwMF0gPSAyNDtcblxuICAvLyBzbWFsbCBudW1iZXIgKGRlbm9ybSlcbiAgfSBlbHNlIGlmIChlIDwgLTE0KSB7XG4gICAgYmFzZVRhYmxlW2ldICAgICAgICAgPSAgMHgwNDAwID4+ICgtZSAtIDE0KTtcbiAgICBiYXNlVGFibGVbaSB8IDB4MTAwXSA9ICgweDA0MDAgPj4gKC1lIC0gMTQpKSB8IDB4ODAwMDtcbiAgICBzaGlmdFRhYmxlW2ldICAgICAgICAgPSAtZSAtIDE7XG4gICAgc2hpZnRUYWJsZVtpIHwgMHgxMDBdID0gLWUgLSAxO1xuXG4gIC8vIG5vcm1hbCBudW1iZXJcbiAgfSBlbHNlIGlmIChlIDw9IDE1KSB7XG4gICAgYmFzZVRhYmxlW2ldICAgICAgICAgPSAgKGUgKyAxNSkgPDwgMTA7XG4gICAgYmFzZVRhYmxlW2kgfCAweDEwMF0gPSAoKGUgKyAxNSkgPDwgMTApIHwgMHg4MDAwO1xuICAgIHNoaWZ0VGFibGVbaV0gICAgICAgICA9IDEzO1xuICAgIHNoaWZ0VGFibGVbaSB8IDB4MTAwXSA9IDEzO1xuXG4gIC8vIGxhcmdlIG51bWJlciAoSW5maW5pdHksIC1JbmZpbml0eSlcbiAgfSBlbHNlIGlmIChlIDwgMTI4KSB7XG4gICAgYmFzZVRhYmxlW2ldICAgICAgICAgPSAweDdjMDA7XG4gICAgYmFzZVRhYmxlW2kgfCAweDEwMF0gPSAweGZjMDA7XG4gICAgc2hpZnRUYWJsZVtpXSAgICAgICAgID0gMjQ7XG4gICAgc2hpZnRUYWJsZVtpIHwgMHgxMDBdID0gMjQ7XG5cbiAgLy8gc3RheSAoTmFOLCBJbmZpbml0eSwgLUluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIGJhc2VUYWJsZVtpXSAgICAgICAgID0gMHg3YzAwO1xuICAgIGJhc2VUYWJsZVtpIHwgMHgxMDBdID0gMHhmYzAwO1xuICAgIHNoaWZ0VGFibGVbaV0gICAgICAgICA9IDEzO1xuICAgIHNoaWZ0VGFibGVbaSB8IDB4MTAwXSA9IDEzO1xuICB9XG59XG5cbi8qKlxuICogcm91bmQgYSBudW1iZXIgdG8gYSBoYWxmIGZsb2F0IG51bWJlciBiaXRzXG4gKiBAcGFyYW0ge3Vua25vd259IG51bSAtIGRvdWJsZSBmbG9hdFxuICogQHJldHVybnMge251bWJlcn0gaGFsZiBmbG9hdCBudW1iZXIgYml0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmRUb0Zsb2F0MTZCaXRzKG51bSkge1xuICBmbG9hdFZpZXdbMF0gPSByb3VuZFRvRmxvYXQxNihudW0pO1xuICBjb25zdCBmID0gdWludDMyVmlld1swXTtcbiAgY29uc3QgZSA9IChmID4+IDIzKSAmIDB4MWZmO1xuICByZXR1cm4gYmFzZVRhYmxlW2VdICsgKChmICYgMHgwMDdmZmZmZikgPj4gc2hpZnRUYWJsZVtlXSk7XG59XG5cbmNvbnN0IG1hbnRpc3NhVGFibGUgPSBuZXcgTmF0aXZlVWludDMyQXJyYXkoMjA0OCk7XG5mb3IgKGxldCBpID0gMTsgaSA8IDEwMjQ7ICsraSkge1xuICBsZXQgbSA9IGkgPDwgMTM7IC8vIHplcm8gcGFkIG1hbnRpc3NhIGJpdHNcbiAgbGV0IGUgPSAwOyAvLyB6ZXJvIGV4cG9uZW50XG5cbiAgLy8gbm9ybWFsaXplZFxuICB3aGlsZSAoKG0gJiAweDAwODAwMDAwKSA9PT0gMCkge1xuICAgIG0gPDw9IDE7XG4gICAgZSAtPSAweDAwODAwMDAwOyAvLyBkZWNyZW1lbnQgZXhwb25lbnRcbiAgfVxuXG4gIG0gJj0gfjB4MDA4MDAwMDA7IC8vIGNsZWFyIGxlYWRpbmcgMSBiaXRcbiAgZSArPSAweDM4ODAwMDAwOyAvLyBhZGp1c3QgYmlhc1xuXG4gIG1hbnRpc3NhVGFibGVbaV0gPSBtIHwgZTtcbn1cbmZvciAobGV0IGkgPSAxMDI0OyBpIDwgMjA0ODsgKytpKSB7XG4gIG1hbnRpc3NhVGFibGVbaV0gPSAweDM4MDAwMDAwICsgKChpIC0gMTAyNCkgPDwgMTMpO1xufVxuXG5jb25zdCBleHBvbmVudFRhYmxlID0gbmV3IE5hdGl2ZVVpbnQzMkFycmF5KDY0KTtcbmZvciAobGV0IGkgPSAxOyBpIDwgMzE7ICsraSkge1xuICBleHBvbmVudFRhYmxlW2ldID0gaSA8PCAyMztcbn1cbmV4cG9uZW50VGFibGVbMzFdID0gMHg0NzgwMDAwMDtcbmV4cG9uZW50VGFibGVbMzJdID0gMHg4MDAwMDAwMDtcbmZvciAobGV0IGkgPSAzMzsgaSA8IDYzOyArK2kpIHtcbiAgZXhwb25lbnRUYWJsZVtpXSA9IDB4ODAwMDAwMDAgKyAoKGkgLSAzMikgPDwgMjMpO1xufVxuZXhwb25lbnRUYWJsZVs2M10gPSAweGM3ODAwMDAwO1xuXG5jb25zdCBvZmZzZXRUYWJsZSA9IG5ldyBOYXRpdmVVaW50MTZBcnJheSg2NCk7XG5mb3IgKGxldCBpID0gMTsgaSA8IDY0OyArK2kpIHtcbiAgaWYgKGkgIT09IDMyKSB7XG4gICAgb2Zmc2V0VGFibGVbaV0gPSAxMDI0O1xuICB9XG59XG5cbi8qKlxuICogY29udmVydCBhIGhhbGYgZmxvYXQgbnVtYmVyIGJpdHMgdG8gYSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbG9hdDE2Yml0cyAtIGhhbGYgZmxvYXQgbnVtYmVyIGJpdHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRvdWJsZSBmbG9hdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvTnVtYmVyKGZsb2F0MTZiaXRzKSB7XG4gIGNvbnN0IGkgPSBmbG9hdDE2Yml0cyA+PiAxMDtcbiAgdWludDMyVmlld1swXSA9IG1hbnRpc3NhVGFibGVbb2Zmc2V0VGFibGVbaV0gKyAoZmxvYXQxNmJpdHMgJiAweDNmZildICsgZXhwb25lbnRUYWJsZVtpXTtcbiAgcmV0dXJuIGZsb2F0Vmlld1swXTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/converter.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/messages.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/_util/messages.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER: function() { return /* binding */ ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER; },\n/* harmony export */   CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT: function() { return /* binding */ CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT; },\n/* harmony export */   CANNOT_MIX_BIGINT_AND_OTHER_TYPES: function() { return /* binding */ CANNOT_MIX_BIGINT_AND_OTHER_TYPES; },\n/* harmony export */   DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH: function() { return /* binding */ DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH; },\n/* harmony export */   ITERATOR_PROPERTY_IS_NOT_CALLABLE: function() { return /* binding */ ITERATOR_PROPERTY_IS_NOT_CALLABLE; },\n/* harmony export */   OFFSET_IS_OUT_OF_BOUNDS: function() { return /* binding */ OFFSET_IS_OUT_OF_BOUNDS; },\n/* harmony export */   REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE: function() { return /* binding */ REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE; },\n/* harmony export */   SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT: function() { return /* binding */ SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT; },\n/* harmony export */   THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED: function() { return /* binding */ THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED; },\n/* harmony export */   THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT: function() { return /* binding */ THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT; },\n/* harmony export */   THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY: function() { return /* binding */ THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY; },\n/* harmony export */   THIS_IS_NOT_AN_OBJECT: function() { return /* binding */ THIS_IS_NOT_AN_OBJECT; },\n/* harmony export */   THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT: function() { return /* binding */ THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT; }\n/* harmony export */ });\nconst THIS_IS_NOT_AN_OBJECT = \"This is not an object\";\nconst THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT = \"This is not a Float16Array object\";\nconst THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY =\n  \"This constructor is not a subclass of Float16Array\";\nconst THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT =\n  \"The constructor property value is not an object\";\nconst SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT =\n  \"Species constructor didn't return TypedArray object\";\nconst DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH =\n  \"Derived constructor created TypedArray object which was too small length\";\nconst ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER =\n  \"Attempting to access detached ArrayBuffer\";\nconst CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT =\n  \"Cannot convert undefined or null to object\";\nconst CANNOT_MIX_BIGINT_AND_OTHER_TYPES =\n  \"Cannot mix BigInt and other types, use explicit conversions\";\nconst ITERATOR_PROPERTY_IS_NOT_CALLABLE = \"@@iterator property is not callable\";\nconst REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE =\n  \"Reduce of empty array with no initial value\";\nconst THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED =\n  \"The comparison function must be either a function or undefined\";\nconst OFFSET_IS_OUT_OF_BOUNDS = \"Offset is out of bounds\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGV0YW1vcmlrZW4vZmxvYXQxNi9zcmMvX3V0aWwvbWVzc2FnZXMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBTztBQUNBO0FBQ0E7QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ0E7QUFDUDtBQUNPO0FBQ1A7QUFDTyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL191dGlsL21lc3NhZ2VzLm1qcz8yODhjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBUSElTX0lTX05PVF9BTl9PQkpFQ1QgPSBcIlRoaXMgaXMgbm90IGFuIG9iamVjdFwiO1xuZXhwb3J0IGNvbnN0IFRISVNfSVNfTk9UX0FfRkxPQVQxNkFSUkFZX09CSkVDVCA9IFwiVGhpcyBpcyBub3QgYSBGbG9hdDE2QXJyYXkgb2JqZWN0XCI7XG5leHBvcnQgY29uc3QgVEhJU19DT05TVFJVQ1RPUl9JU19OT1RfQV9TVUJDTEFTU19PRl9GTE9BVDE2QVJSQVkgPVxuICBcIlRoaXMgY29uc3RydWN0b3IgaXMgbm90IGEgc3ViY2xhc3Mgb2YgRmxvYXQxNkFycmF5XCI7XG5leHBvcnQgY29uc3QgVEhFX0NPTlNUUlVDVE9SX1BST1BFUlRZX1ZBTFVFX0lTX05PVF9BTl9PQkpFQ1QgPVxuICBcIlRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eSB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0XCI7XG5leHBvcnQgY29uc3QgU1BFQ0lFU19DT05TVFJVQ1RPUl9ESUROVF9SRVRVUk5fVFlQRURBUlJBWV9PQkpFQ1QgPVxuICBcIlNwZWNpZXMgY29uc3RydWN0b3IgZGlkbid0IHJldHVybiBUeXBlZEFycmF5IG9iamVjdFwiO1xuZXhwb3J0IGNvbnN0IERFUklWRURfQ09OU1RSVUNUT1JfQ1JFQVRFRF9UWVBFREFSUkFZX09CSkVDVF9XSElDSF9XQVNfVE9PX1NNQUxMX0xFTkdUSCA9XG4gIFwiRGVyaXZlZCBjb25zdHJ1Y3RvciBjcmVhdGVkIFR5cGVkQXJyYXkgb2JqZWN0IHdoaWNoIHdhcyB0b28gc21hbGwgbGVuZ3RoXCI7XG5leHBvcnQgY29uc3QgQVRURU1QVElOR19UT19BQ0NFU1NfREVUQUNIRURfQVJSQVlCVUZGRVIgPVxuICBcIkF0dGVtcHRpbmcgdG8gYWNjZXNzIGRldGFjaGVkIEFycmF5QnVmZmVyXCI7XG5leHBvcnQgY29uc3QgQ0FOTk9UX0NPTlZFUlRfVU5ERUZJTkVEX09SX05VTExfVE9fT0JKRUNUID1cbiAgXCJDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3RcIjtcbmV4cG9ydCBjb25zdCBDQU5OT1RfTUlYX0JJR0lOVF9BTkRfT1RIRVJfVFlQRVMgPVxuICBcIkNhbm5vdCBtaXggQmlnSW50IGFuZCBvdGhlciB0eXBlcywgdXNlIGV4cGxpY2l0IGNvbnZlcnNpb25zXCI7XG5leHBvcnQgY29uc3QgSVRFUkFUT1JfUFJPUEVSVFlfSVNfTk9UX0NBTExBQkxFID0gXCJAQGl0ZXJhdG9yIHByb3BlcnR5IGlzIG5vdCBjYWxsYWJsZVwiO1xuZXhwb3J0IGNvbnN0IFJFRFVDRV9PRl9FTVBUWV9BUlJBWV9XSVRIX05PX0lOSVRJQUxfVkFMVUUgPVxuICBcIlJlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWVcIjtcbmV4cG9ydCBjb25zdCBUSEVfQ09NUEFSSVNPTl9GVU5DVElPTl9NVVNUX0JFX0VJVEhFUl9BX0ZVTkNUSU9OX09SX1VOREVGSU5FRCA9XG4gIFwiVGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gbXVzdCBiZSBlaXRoZXIgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIjtcbmV4cG9ydCBjb25zdCBPRkZTRVRfSVNfT1VUX09GX0JPVU5EUyA9IFwiT2Zmc2V0IGlzIG91dCBvZiBib3VuZHNcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/messages.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/primordials.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/_util/primordials.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayBufferIsView: function() { return /* binding */ ArrayBufferIsView; },\n/* harmony export */   ArrayBufferPrototypeGetByteLength: function() { return /* binding */ ArrayBufferPrototypeGetByteLength; },\n/* harmony export */   ArrayBufferPrototypeSlice: function() { return /* binding */ ArrayBufferPrototypeSlice; },\n/* harmony export */   ArrayIsArray: function() { return /* binding */ ArrayIsArray; },\n/* harmony export */   ArrayIteratorPrototype: function() { return /* binding */ ArrayIteratorPrototype; },\n/* harmony export */   ArrayIteratorPrototypeNext: function() { return /* binding */ ArrayIteratorPrototypeNext; },\n/* harmony export */   ArrayPrototypeJoin: function() { return /* binding */ ArrayPrototypeJoin; },\n/* harmony export */   ArrayPrototypePush: function() { return /* binding */ ArrayPrototypePush; },\n/* harmony export */   ArrayPrototypeSymbolIterator: function() { return /* binding */ ArrayPrototypeSymbolIterator; },\n/* harmony export */   ArrayPrototypeToLocaleString: function() { return /* binding */ ArrayPrototypeToLocaleString; },\n/* harmony export */   DataViewPrototypeGetUint16: function() { return /* binding */ DataViewPrototypeGetUint16; },\n/* harmony export */   DataViewPrototypeSetUint16: function() { return /* binding */ DataViewPrototypeSetUint16; },\n/* harmony export */   EPSILON: function() { return /* binding */ EPSILON; },\n/* harmony export */   GeneratorPrototypeNext: function() { return /* binding */ GeneratorPrototypeNext; },\n/* harmony export */   IteratorPrototype: function() { return /* binding */ IteratorPrototype; },\n/* harmony export */   MAX_SAFE_INTEGER: function() { return /* binding */ MAX_SAFE_INTEGER; },\n/* harmony export */   MathAbs: function() { return /* binding */ MathAbs; },\n/* harmony export */   MathTrunc: function() { return /* binding */ MathTrunc; },\n/* harmony export */   NativeArrayBuffer: function() { return /* binding */ NativeArrayBuffer; },\n/* harmony export */   NativeArrayPrototypeSymbolIterator: function() { return /* binding */ NativeArrayPrototypeSymbolIterator; },\n/* harmony export */   NativeFloat32Array: function() { return /* binding */ NativeFloat32Array; },\n/* harmony export */   NativeObject: function() { return /* binding */ NativeObject; },\n/* harmony export */   NativeProxy: function() { return /* binding */ NativeProxy; },\n/* harmony export */   NativeRangeError: function() { return /* binding */ NativeRangeError; },\n/* harmony export */   NativeSharedArrayBuffer: function() { return /* binding */ NativeSharedArrayBuffer; },\n/* harmony export */   NativeTypeError: function() { return /* binding */ NativeTypeError; },\n/* harmony export */   NativeTypedArrayPrototypeSymbolIterator: function() { return /* binding */ NativeTypedArrayPrototypeSymbolIterator; },\n/* harmony export */   NativeUint16Array: function() { return /* binding */ NativeUint16Array; },\n/* harmony export */   NativeUint32Array: function() { return /* binding */ NativeUint32Array; },\n/* harmony export */   NativeUint8Array: function() { return /* binding */ NativeUint8Array; },\n/* harmony export */   NativeWeakMap: function() { return /* binding */ NativeWeakMap; },\n/* harmony export */   NativeWeakSet: function() { return /* binding */ NativeWeakSet; },\n/* harmony export */   NumberIsFinite: function() { return /* binding */ NumberIsFinite; },\n/* harmony export */   NumberIsNaN: function() { return /* binding */ NumberIsNaN; },\n/* harmony export */   ObjectCreate: function() { return /* binding */ ObjectCreate; },\n/* harmony export */   ObjectDefineProperty: function() { return /* binding */ ObjectDefineProperty; },\n/* harmony export */   ObjectFreeze: function() { return /* binding */ ObjectFreeze; },\n/* harmony export */   ObjectHasOwn: function() { return /* binding */ ObjectHasOwn; },\n/* harmony export */   ObjectIs: function() { return /* binding */ ObjectIs; },\n/* harmony export */   ObjectPrototype__lookupGetter__: function() { return /* binding */ ObjectPrototype__lookupGetter__; },\n/* harmony export */   ReflectApply: function() { return /* binding */ ReflectApply; },\n/* harmony export */   ReflectConstruct: function() { return /* binding */ ReflectConstruct; },\n/* harmony export */   ReflectDefineProperty: function() { return /* binding */ ReflectDefineProperty; },\n/* harmony export */   ReflectGet: function() { return /* binding */ ReflectGet; },\n/* harmony export */   ReflectGetOwnPropertyDescriptor: function() { return /* binding */ ReflectGetOwnPropertyDescriptor; },\n/* harmony export */   ReflectGetPrototypeOf: function() { return /* binding */ ReflectGetPrototypeOf; },\n/* harmony export */   ReflectHas: function() { return /* binding */ ReflectHas; },\n/* harmony export */   ReflectOwnKeys: function() { return /* binding */ ReflectOwnKeys; },\n/* harmony export */   ReflectSet: function() { return /* binding */ ReflectSet; },\n/* harmony export */   ReflectSetPrototypeOf: function() { return /* binding */ ReflectSetPrototypeOf; },\n/* harmony export */   SharedArrayBufferPrototypeGetByteLength: function() { return /* binding */ SharedArrayBufferPrototypeGetByteLength; },\n/* harmony export */   SymbolFor: function() { return /* binding */ SymbolFor; },\n/* harmony export */   SymbolIterator: function() { return /* binding */ SymbolIterator; },\n/* harmony export */   SymbolSpecies: function() { return /* binding */ SymbolSpecies; },\n/* harmony export */   SymbolToStringTag: function() { return /* binding */ SymbolToStringTag; },\n/* harmony export */   TypedArray: function() { return /* binding */ TypedArray; },\n/* harmony export */   TypedArrayPrototype: function() { return /* binding */ TypedArrayPrototype; },\n/* harmony export */   TypedArrayPrototypeCopyWithin: function() { return /* binding */ TypedArrayPrototypeCopyWithin; },\n/* harmony export */   TypedArrayPrototypeEntries: function() { return /* binding */ TypedArrayPrototypeEntries; },\n/* harmony export */   TypedArrayPrototypeFill: function() { return /* binding */ TypedArrayPrototypeFill; },\n/* harmony export */   TypedArrayPrototypeGetBuffer: function() { return /* binding */ TypedArrayPrototypeGetBuffer; },\n/* harmony export */   TypedArrayPrototypeGetByteOffset: function() { return /* binding */ TypedArrayPrototypeGetByteOffset; },\n/* harmony export */   TypedArrayPrototypeGetLength: function() { return /* binding */ TypedArrayPrototypeGetLength; },\n/* harmony export */   TypedArrayPrototypeGetSymbolToStringTag: function() { return /* binding */ TypedArrayPrototypeGetSymbolToStringTag; },\n/* harmony export */   TypedArrayPrototypeKeys: function() { return /* binding */ TypedArrayPrototypeKeys; },\n/* harmony export */   TypedArrayPrototypeReverse: function() { return /* binding */ TypedArrayPrototypeReverse; },\n/* harmony export */   TypedArrayPrototypeSet: function() { return /* binding */ TypedArrayPrototypeSet; },\n/* harmony export */   TypedArrayPrototypeSlice: function() { return /* binding */ TypedArrayPrototypeSlice; },\n/* harmony export */   TypedArrayPrototypeSort: function() { return /* binding */ TypedArrayPrototypeSort; },\n/* harmony export */   TypedArrayPrototypeSubarray: function() { return /* binding */ TypedArrayPrototypeSubarray; },\n/* harmony export */   TypedArrayPrototypeValues: function() { return /* binding */ TypedArrayPrototypeValues; },\n/* harmony export */   Uint16ArrayFrom: function() { return /* binding */ Uint16ArrayFrom; },\n/* harmony export */   WeakMapPrototypeGet: function() { return /* binding */ WeakMapPrototypeGet; },\n/* harmony export */   WeakMapPrototypeHas: function() { return /* binding */ WeakMapPrototypeHas; },\n/* harmony export */   WeakMapPrototypeSet: function() { return /* binding */ WeakMapPrototypeSet; },\n/* harmony export */   WeakSetPrototypeAdd: function() { return /* binding */ WeakSetPrototypeAdd; },\n/* harmony export */   WeakSetPrototypeHas: function() { return /* binding */ WeakSetPrototypeHas; }\n/* harmony export */ });\n/* harmony import */ var _messages_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./messages.mjs */ \"(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/messages.mjs\");\n/* eslint-disable no-restricted-globals, no-restricted-syntax */\n/* global SharedArrayBuffer */\n\n\n\n/** @type {<T extends (...args: any) => any>(target: T) => (thisArg: ThisType<T>, ...args: any[]) => any} */\nfunction uncurryThis(target) {\n  return (thisArg, ...args) => {\n    return ReflectApply(target, thisArg, args);\n  };\n}\n\n/** @type {(target: any, key: string | symbol) => (thisArg: any, ...args: any[]) => any} */\nfunction uncurryThisGetter(target, key) {\n  return uncurryThis(\n    ReflectGetOwnPropertyDescriptor(\n      target,\n      key\n    ).get\n  );\n}\n\n// Reflect\nconst {\n  apply: ReflectApply,\n  construct: ReflectConstruct,\n  defineProperty: ReflectDefineProperty,\n  get: ReflectGet,\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n  getPrototypeOf: ReflectGetPrototypeOf,\n  has: ReflectHas,\n  ownKeys: ReflectOwnKeys,\n  set: ReflectSet,\n  setPrototypeOf: ReflectSetPrototypeOf,\n} = Reflect;\n\n// Proxy\nconst NativeProxy = Proxy;\n\n// Number\nconst {\n  EPSILON,\n  MAX_SAFE_INTEGER,\n  isFinite: NumberIsFinite,\n  isNaN: NumberIsNaN,\n} = Number;\n\n// Symbol\nconst {\n  iterator: SymbolIterator,\n  species: SymbolSpecies,\n  toStringTag: SymbolToStringTag,\n  for: SymbolFor,\n} = Symbol;\n\n// Object\nconst NativeObject = Object;\nconst {\n  create: ObjectCreate,\n  defineProperty: ObjectDefineProperty,\n  freeze: ObjectFreeze,\n  is: ObjectIs,\n} = NativeObject;\nconst ObjectPrototype = NativeObject.prototype;\n/** @type {(object: object, key: PropertyKey) => Function | undefined} */\nconst ObjectPrototype__lookupGetter__ = /** @type {any} */ (ObjectPrototype).__lookupGetter__\n  ? uncurryThis(/** @type {any} */ (ObjectPrototype).__lookupGetter__)\n  : (object, key) => {\n    if (object == null) {\n      throw NativeTypeError(\n        _messages_mjs__WEBPACK_IMPORTED_MODULE_0__.CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n      );\n    }\n\n    let target = NativeObject(object);\n    do {\n      const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n      if (descriptor !== undefined) {\n        if (ObjectHasOwn(descriptor, \"get\")) {\n          return descriptor.get;\n        }\n\n        return;\n      }\n    } while ((target = ReflectGetPrototypeOf(target)) !== null);\n  };\n/** @type {(object: object, key: PropertyKey) => boolean} */\nconst ObjectHasOwn = /** @type {any} */ (NativeObject).hasOwn ||\n  uncurryThis(ObjectPrototype.hasOwnProperty);\n\n// Array\nconst NativeArray = Array;\nconst ArrayIsArray = NativeArray.isArray;\nconst ArrayPrototype = NativeArray.prototype;\n/** @type {(array: ArrayLike<unknown>, separator?: string) => string} */\nconst ArrayPrototypeJoin = uncurryThis(ArrayPrototype.join);\n/** @type {<T>(array: T[], ...items: T[]) => number} */\nconst ArrayPrototypePush = uncurryThis(ArrayPrototype.push);\n/** @type {(array: ArrayLike<unknown>, ...opts: any[]) => string} */\nconst ArrayPrototypeToLocaleString = uncurryThis(\n  ArrayPrototype.toLocaleString\n);\nconst NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator];\n/** @type {<T>(array: T[]) => IterableIterator<T>} */\nconst ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator);\n\n// Math\nconst {\n  abs: MathAbs,\n  trunc: MathTrunc,\n} = Math;\n\n// ArrayBuffer\nconst NativeArrayBuffer = ArrayBuffer;\nconst ArrayBufferIsView = NativeArrayBuffer.isView;\nconst ArrayBufferPrototype = NativeArrayBuffer.prototype;\n/** @type {(buffer: ArrayBuffer, begin?: number, end?: number) => number} */\nconst ArrayBufferPrototypeSlice = uncurryThis(ArrayBufferPrototype.slice);\n/** @type {(buffer: ArrayBuffer) => ArrayBuffer} */\nconst ArrayBufferPrototypeGetByteLength = uncurryThisGetter(ArrayBufferPrototype, \"byteLength\");\n\n// SharedArrayBuffer\nconst NativeSharedArrayBuffer = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : null;\n/** @type {(buffer: SharedArrayBuffer) => SharedArrayBuffer} */\nconst SharedArrayBufferPrototypeGetByteLength = NativeSharedArrayBuffer\n  && uncurryThisGetter(NativeSharedArrayBuffer.prototype, \"byteLength\");\n\n// TypedArray\n/** @typedef {Uint8Array|Uint8ClampedArray|Uint16Array|Uint32Array|Int8Array|Int16Array|Int32Array|Float32Array|Float64Array|BigUint64Array|BigInt64Array} TypedArray */\n/** @type {any} */\nconst TypedArray = ReflectGetPrototypeOf(Uint8Array);\nconst TypedArrayFrom = TypedArray.from;\nconst TypedArrayPrototype = TypedArray.prototype;\nconst NativeTypedArrayPrototypeSymbolIterator = TypedArrayPrototype[SymbolIterator];\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nconst TypedArrayPrototypeKeys = uncurryThis(TypedArrayPrototype.keys);\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nconst TypedArrayPrototypeValues = uncurryThis(\n  TypedArrayPrototype.values\n);\n/** @type {(typedArray: TypedArray) => IterableIterator<[number, number]>} */\nconst TypedArrayPrototypeEntries = uncurryThis(\n  TypedArrayPrototype.entries\n);\n/** @type {(typedArray: TypedArray, array: ArrayLike<number>, offset?: number) => void} */\nconst TypedArrayPrototypeSet = uncurryThis(TypedArrayPrototype.set);\n/** @type {<T extends TypedArray>(typedArray: T) => T} */\nconst TypedArrayPrototypeReverse = uncurryThis(\n  TypedArrayPrototype.reverse\n);\n/** @type {<T extends TypedArray>(typedArray: T, value: number, start?: number, end?: number) => T} */\nconst TypedArrayPrototypeFill = uncurryThis(TypedArrayPrototype.fill);\n/** @type {<T extends TypedArray>(typedArray: T, target: number, start: number, end?: number) => T} */\nconst TypedArrayPrototypeCopyWithin = uncurryThis(\n  TypedArrayPrototype.copyWithin\n);\n/** @type {<T extends TypedArray>(typedArray: T, compareFn?: (a: number, b: number) => number) => T} */\nconst TypedArrayPrototypeSort = uncurryThis(TypedArrayPrototype.sort);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nconst TypedArrayPrototypeSlice = uncurryThis(TypedArrayPrototype.slice);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nconst TypedArrayPrototypeSubarray = uncurryThis(\n  TypedArrayPrototype.subarray\n);\n/** @type {((typedArray: TypedArray) => ArrayBuffer)} */\nconst TypedArrayPrototypeGetBuffer = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"buffer\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nconst TypedArrayPrototypeGetByteOffset = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"byteOffset\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nconst TypedArrayPrototypeGetLength = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"length\"\n);\n/** @type {(target: unknown) => string} */\nconst TypedArrayPrototypeGetSymbolToStringTag = uncurryThisGetter(\n  TypedArrayPrototype,\n  SymbolToStringTag\n);\n\n// Uint8Array\nconst NativeUint8Array = Uint8Array;\n\n// Uint16Array\nconst NativeUint16Array = Uint16Array;\n/** @type {Uint16ArrayConstructor[\"from\"]} */\nconst Uint16ArrayFrom = (...args) => {\n  return ReflectApply(TypedArrayFrom, NativeUint16Array, args);\n};\n\n// Uint32Array\nconst NativeUint32Array = Uint32Array;\n\n// Float32Array\nconst NativeFloat32Array = Float32Array;\n\n// ArrayIterator\n/** @type {any} */\nconst ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());\n/** @type {<T>(arrayIterator: IterableIterator<T>) => IteratorResult<T>} */\nconst ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next);\n\n// Generator\n/** @type {<T = unknown, TReturn = any, TNext = unknown>(generator: Generator<T, TReturn, TNext>, value?: TNext) => T} */\nconst GeneratorPrototypeNext = uncurryThis((function* () {})().next);\n\n// Iterator\nconst IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype);\n\n// DataView\nconst DataViewPrototype = DataView.prototype;\n/** @type {(dataView: DataView, byteOffset: number, littleEndian?: boolean) => number} */\nconst DataViewPrototypeGetUint16 = uncurryThis(\n  DataViewPrototype.getUint16\n);\n/** @type {(dataView: DataView, byteOffset: number, value: number, littleEndian?: boolean) => void} */\nconst DataViewPrototypeSetUint16 = uncurryThis(\n  DataViewPrototype.setUint16\n);\n\n// Error\nconst NativeTypeError = TypeError;\nconst NativeRangeError = RangeError;\n\n// WeakSet\n/**\n * Do not construct with arguments to avoid calling the \"add\" method\n * @type {{new <T extends {}>(): WeakSet<T>}}\n */\nconst NativeWeakSet = WeakSet;\nconst WeakSetPrototype = NativeWeakSet.prototype;\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => Set<T>} */\nconst WeakSetPrototypeAdd = uncurryThis(WeakSetPrototype.add);\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => boolean} */\nconst WeakSetPrototypeHas = uncurryThis(WeakSetPrototype.has);\n\n// WeakMap\n/**\n * Do not construct with arguments to avoid calling the \"set\" method\n * @type {{new <K extends {}, V>(): WeakMap<K, V>}}\n */\nconst NativeWeakMap = WeakMap;\nconst WeakMapPrototype = NativeWeakMap.prototype;\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => V} */\nconst WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => boolean} */\nconst WeakMapPrototypeHas = uncurryThis(WeakMapPrototype.has);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K, value: V) => WeakMap} */\nconst WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGV0YW1vcmlrZW4vZmxvYXQxNi9zcmMvX3V0aWwvcHJpbW9yZGlhbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRTRFOztBQUU1RSxXQUFXLCtGQUErRjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsOEVBQThFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNPOztBQUVQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLFdBQVcsNERBQTREO0FBQ2hFLG1EQUFtRCxLQUFLO0FBQy9ELDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUZBQTBDO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFdBQVcsK0NBQStDO0FBQ25ELGdDQUFnQyxLQUFLO0FBQzVDOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsV0FBVywyREFBMkQ7QUFDL0Q7QUFDUCxXQUFXLDBDQUEwQztBQUM5QztBQUNQLFdBQVcsdURBQXVEO0FBQzNEO0FBQ1A7QUFDQTtBQUNPO0FBQ1AsV0FBVyx3Q0FBd0M7QUFDNUM7O0FBRVA7QUFDTztBQUNQO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ087QUFDQTtBQUNQO0FBQ0EsV0FBVywrREFBK0Q7QUFDbkU7QUFDUCxXQUFXLHNDQUFzQztBQUMxQzs7QUFFUDtBQUNPO0FBQ1AsV0FBVyxrREFBa0Q7QUFDdEQ7QUFDUDs7QUFFQTtBQUNBLGNBQWMsNklBQTZJO0FBQzNKLFdBQVcsS0FBSztBQUNUO0FBQ1A7QUFDTztBQUNBO0FBQ1AsV0FBVyxzREFBc0Q7QUFDMUQ7QUFDUCxXQUFXLHNEQUFzRDtBQUMxRDtBQUNQO0FBQ0E7QUFDQSxXQUFXLGdFQUFnRTtBQUNwRTtBQUNQO0FBQ0E7QUFDQSxXQUFXLDZFQUE2RTtBQUNqRjtBQUNQLFdBQVcsNENBQTRDO0FBQ2hEO0FBQ1A7QUFDQTtBQUNBLFdBQVcseUZBQXlGO0FBQzdGO0FBQ1AsV0FBVyx5RkFBeUY7QUFDN0Y7QUFDUDtBQUNBO0FBQ0EsV0FBVywwRkFBMEY7QUFDOUY7QUFDUCxXQUFXLDBFQUEwRTtBQUM5RTtBQUNQLFdBQVcsMEVBQTBFO0FBQzlFO0FBQ1A7QUFDQTtBQUNBLFdBQVcsMkNBQTJDO0FBQy9DO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQ0FBc0M7QUFDMUM7QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNDQUFzQztBQUMxQztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ2pDO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ087O0FBRVA7QUFDTztBQUNQLFdBQVcsZ0NBQWdDO0FBQ3BDO0FBQ1A7QUFDQTs7QUFFQTtBQUNPOztBQUVQO0FBQ087O0FBRVA7QUFDQSxXQUFXLEtBQUs7QUFDVDtBQUNQLFdBQVcsOERBQThEO0FBQ2xFOztBQUVQO0FBQ0EsV0FBVyw0R0FBNEc7QUFDaEgsMkRBQTJEOztBQUVsRTtBQUNPOztBQUVQO0FBQ0E7QUFDQSxXQUFXLDRFQUE0RTtBQUNoRjtBQUNQO0FBQ0E7QUFDQSxXQUFXLHlGQUF5RjtBQUM3RjtBQUNQO0FBQ0E7O0FBRUE7QUFDTztBQUNBOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ087QUFDUDtBQUNBLFdBQVcsYUFBYSx3Q0FBd0M7QUFDekQ7QUFDUCxXQUFXLGFBQWEseUNBQXlDO0FBQzFEOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ087QUFDUDtBQUNBLFdBQVcsYUFBYSwyQ0FBMkM7QUFDNUQ7QUFDUCxXQUFXLGFBQWEsaURBQWlEO0FBQ2xFO0FBQ1AsV0FBVyxhQUFhLDJEQUEyRDtBQUM1RSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL191dGlsL3ByaW1vcmRpYWxzLm1qcz82Mjg2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscywgbm8tcmVzdHJpY3RlZC1zeW50YXggKi9cbi8qIGdsb2JhbCBTaGFyZWRBcnJheUJ1ZmZlciAqL1xuXG5pbXBvcnQgeyBDQU5OT1RfQ09OVkVSVF9VTkRFRklORURfT1JfTlVMTF9UT19PQkpFQ1QgfSBmcm9tIFwiLi9tZXNzYWdlcy5tanNcIjtcblxuLyoqIEB0eXBlIHs8VCBleHRlbmRzICguLi5hcmdzOiBhbnkpID0+IGFueT4odGFyZ2V0OiBUKSA9PiAodGhpc0FyZzogVGhpc1R5cGU8VD4sIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnl9ICovXG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyh0YXJnZXQpIHtcbiAgcmV0dXJuICh0aGlzQXJnLCAuLi5hcmdzKSA9PiB7XG4gICAgcmV0dXJuIFJlZmxlY3RBcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufVxuXG4vKiogQHR5cGUgeyh0YXJnZXQ6IGFueSwga2V5OiBzdHJpbmcgfCBzeW1ib2wpID0+ICh0aGlzQXJnOiBhbnksIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnl9ICovXG5mdW5jdGlvbiB1bmN1cnJ5VGhpc0dldHRlcih0YXJnZXQsIGtleSkge1xuICByZXR1cm4gdW5jdXJyeVRoaXMoXG4gICAgUmVmbGVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleVxuICAgICkuZ2V0XG4gICk7XG59XG5cbi8vIFJlZmxlY3RcbmV4cG9ydCBjb25zdCB7XG4gIGFwcGx5OiBSZWZsZWN0QXBwbHksXG4gIGNvbnN0cnVjdDogUmVmbGVjdENvbnN0cnVjdCxcbiAgZGVmaW5lUHJvcGVydHk6IFJlZmxlY3REZWZpbmVQcm9wZXJ0eSxcbiAgZ2V0OiBSZWZsZWN0R2V0LFxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IFJlZmxlY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIGdldFByb3RvdHlwZU9mOiBSZWZsZWN0R2V0UHJvdG90eXBlT2YsXG4gIGhhczogUmVmbGVjdEhhcyxcbiAgb3duS2V5czogUmVmbGVjdE93bktleXMsXG4gIHNldDogUmVmbGVjdFNldCxcbiAgc2V0UHJvdG90eXBlT2Y6IFJlZmxlY3RTZXRQcm90b3R5cGVPZixcbn0gPSBSZWZsZWN0O1xuXG4vLyBQcm94eVxuZXhwb3J0IGNvbnN0IE5hdGl2ZVByb3h5ID0gUHJveHk7XG5cbi8vIE51bWJlclxuZXhwb3J0IGNvbnN0IHtcbiAgRVBTSUxPTixcbiAgTUFYX1NBRkVfSU5URUdFUixcbiAgaXNGaW5pdGU6IE51bWJlcklzRmluaXRlLFxuICBpc05hTjogTnVtYmVySXNOYU4sXG59ID0gTnVtYmVyO1xuXG4vLyBTeW1ib2xcbmV4cG9ydCBjb25zdCB7XG4gIGl0ZXJhdG9yOiBTeW1ib2xJdGVyYXRvcixcbiAgc3BlY2llczogU3ltYm9sU3BlY2llcyxcbiAgdG9TdHJpbmdUYWc6IFN5bWJvbFRvU3RyaW5nVGFnLFxuICBmb3I6IFN5bWJvbEZvcixcbn0gPSBTeW1ib2w7XG5cbi8vIE9iamVjdFxuZXhwb3J0IGNvbnN0IE5hdGl2ZU9iamVjdCA9IE9iamVjdDtcbmV4cG9ydCBjb25zdCB7XG4gIGNyZWF0ZTogT2JqZWN0Q3JlYXRlLFxuICBkZWZpbmVQcm9wZXJ0eTogT2JqZWN0RGVmaW5lUHJvcGVydHksXG4gIGZyZWV6ZTogT2JqZWN0RnJlZXplLFxuICBpczogT2JqZWN0SXMsXG59ID0gTmF0aXZlT2JqZWN0O1xuY29uc3QgT2JqZWN0UHJvdG90eXBlID0gTmF0aXZlT2JqZWN0LnByb3RvdHlwZTtcbi8qKiBAdHlwZSB7KG9iamVjdDogb2JqZWN0LCBrZXk6IFByb3BlcnR5S2V5KSA9PiBGdW5jdGlvbiB8IHVuZGVmaW5lZH0gKi9cbmV4cG9ydCBjb25zdCBPYmplY3RQcm90b3R5cGVfX2xvb2t1cEdldHRlcl9fID0gLyoqIEB0eXBlIHthbnl9ICovIChPYmplY3RQcm90b3R5cGUpLl9fbG9va3VwR2V0dGVyX19cbiAgPyB1bmN1cnJ5VGhpcygvKiogQHR5cGUge2FueX0gKi8gKE9iamVjdFByb3RvdHlwZSkuX19sb29rdXBHZXR0ZXJfXylcbiAgOiAob2JqZWN0LCBrZXkpID0+IHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHRocm93IE5hdGl2ZVR5cGVFcnJvcihcbiAgICAgICAgQ0FOTk9UX0NPTlZFUlRfVU5ERUZJTkVEX09SX05VTExfVE9fT0JKRUNUXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCB0YXJnZXQgPSBOYXRpdmVPYmplY3Qob2JqZWN0KTtcbiAgICBkbyB7XG4gICAgICBjb25zdCBkZXNjcmlwdG9yID0gUmVmbGVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgICBpZiAoZGVzY3JpcHRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChPYmplY3RIYXNPd24oZGVzY3JpcHRvciwgXCJnZXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci5nZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSB3aGlsZSAoKHRhcmdldCA9IFJlZmxlY3RHZXRQcm90b3R5cGVPZih0YXJnZXQpKSAhPT0gbnVsbCk7XG4gIH07XG4vKiogQHR5cGUgeyhvYmplY3Q6IG9iamVjdCwga2V5OiBQcm9wZXJ0eUtleSkgPT4gYm9vbGVhbn0gKi9cbmV4cG9ydCBjb25zdCBPYmplY3RIYXNPd24gPSAvKiogQHR5cGUge2FueX0gKi8gKE5hdGl2ZU9iamVjdCkuaGFzT3duIHx8XG4gIHVuY3VycnlUaGlzKE9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbi8vIEFycmF5XG5jb25zdCBOYXRpdmVBcnJheSA9IEFycmF5O1xuZXhwb3J0IGNvbnN0IEFycmF5SXNBcnJheSA9IE5hdGl2ZUFycmF5LmlzQXJyYXk7XG5jb25zdCBBcnJheVByb3RvdHlwZSA9IE5hdGl2ZUFycmF5LnByb3RvdHlwZTtcbi8qKiBAdHlwZSB7KGFycmF5OiBBcnJheUxpa2U8dW5rbm93bj4sIHNlcGFyYXRvcj86IHN0cmluZykgPT4gc3RyaW5nfSAqL1xuZXhwb3J0IGNvbnN0IEFycmF5UHJvdG90eXBlSm9pbiA9IHVuY3VycnlUaGlzKEFycmF5UHJvdG90eXBlLmpvaW4pO1xuLyoqIEB0eXBlIHs8VD4oYXJyYXk6IFRbXSwgLi4uaXRlbXM6IFRbXSkgPT4gbnVtYmVyfSAqL1xuZXhwb3J0IGNvbnN0IEFycmF5UHJvdG90eXBlUHVzaCA9IHVuY3VycnlUaGlzKEFycmF5UHJvdG90eXBlLnB1c2gpO1xuLyoqIEB0eXBlIHsoYXJyYXk6IEFycmF5TGlrZTx1bmtub3duPiwgLi4ub3B0czogYW55W10pID0+IHN0cmluZ30gKi9cbmV4cG9ydCBjb25zdCBBcnJheVByb3RvdHlwZVRvTG9jYWxlU3RyaW5nID0gdW5jdXJyeVRoaXMoXG4gIEFycmF5UHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nXG4pO1xuZXhwb3J0IGNvbnN0IE5hdGl2ZUFycmF5UHJvdG90eXBlU3ltYm9sSXRlcmF0b3IgPSBBcnJheVByb3RvdHlwZVtTeW1ib2xJdGVyYXRvcl07XG4vKiogQHR5cGUgezxUPihhcnJheTogVFtdKSA9PiBJdGVyYWJsZUl0ZXJhdG9yPFQ+fSAqL1xuZXhwb3J0IGNvbnN0IEFycmF5UHJvdG90eXBlU3ltYm9sSXRlcmF0b3IgPSB1bmN1cnJ5VGhpcyhOYXRpdmVBcnJheVByb3RvdHlwZVN5bWJvbEl0ZXJhdG9yKTtcblxuLy8gTWF0aFxuZXhwb3J0IGNvbnN0IHtcbiAgYWJzOiBNYXRoQWJzLFxuICB0cnVuYzogTWF0aFRydW5jLFxufSA9IE1hdGg7XG5cbi8vIEFycmF5QnVmZmVyXG5leHBvcnQgY29uc3QgTmF0aXZlQXJyYXlCdWZmZXIgPSBBcnJheUJ1ZmZlcjtcbmV4cG9ydCBjb25zdCBBcnJheUJ1ZmZlcklzVmlldyA9IE5hdGl2ZUFycmF5QnVmZmVyLmlzVmlldztcbmNvbnN0IEFycmF5QnVmZmVyUHJvdG90eXBlID0gTmF0aXZlQXJyYXlCdWZmZXIucHJvdG90eXBlO1xuLyoqIEB0eXBlIHsoYnVmZmVyOiBBcnJheUJ1ZmZlciwgYmVnaW4/OiBudW1iZXIsIGVuZD86IG51bWJlcikgPT4gbnVtYmVyfSAqL1xuZXhwb3J0IGNvbnN0IEFycmF5QnVmZmVyUHJvdG90eXBlU2xpY2UgPSB1bmN1cnJ5VGhpcyhBcnJheUJ1ZmZlclByb3RvdHlwZS5zbGljZSk7XG4vKiogQHR5cGUgeyhidWZmZXI6IEFycmF5QnVmZmVyKSA9PiBBcnJheUJ1ZmZlcn0gKi9cbmV4cG9ydCBjb25zdCBBcnJheUJ1ZmZlclByb3RvdHlwZUdldEJ5dGVMZW5ndGggPSB1bmN1cnJ5VGhpc0dldHRlcihBcnJheUJ1ZmZlclByb3RvdHlwZSwgXCJieXRlTGVuZ3RoXCIpO1xuXG4vLyBTaGFyZWRBcnJheUJ1ZmZlclxuZXhwb3J0IGNvbnN0IE5hdGl2ZVNoYXJlZEFycmF5QnVmZmVyID0gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSBcInVuZGVmaW5lZFwiID8gU2hhcmVkQXJyYXlCdWZmZXIgOiBudWxsO1xuLyoqIEB0eXBlIHsoYnVmZmVyOiBTaGFyZWRBcnJheUJ1ZmZlcikgPT4gU2hhcmVkQXJyYXlCdWZmZXJ9ICovXG5leHBvcnQgY29uc3QgU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGVHZXRCeXRlTGVuZ3RoID0gTmF0aXZlU2hhcmVkQXJyYXlCdWZmZXJcbiAgJiYgdW5jdXJyeVRoaXNHZXR0ZXIoTmF0aXZlU2hhcmVkQXJyYXlCdWZmZXIucHJvdG90eXBlLCBcImJ5dGVMZW5ndGhcIik7XG5cbi8vIFR5cGVkQXJyYXlcbi8qKiBAdHlwZWRlZiB7VWludDhBcnJheXxVaW50OENsYW1wZWRBcnJheXxVaW50MTZBcnJheXxVaW50MzJBcnJheXxJbnQ4QXJyYXl8SW50MTZBcnJheXxJbnQzMkFycmF5fEZsb2F0MzJBcnJheXxGbG9hdDY0QXJyYXl8QmlnVWludDY0QXJyYXl8QmlnSW50NjRBcnJheX0gVHlwZWRBcnJheSAqL1xuLyoqIEB0eXBlIHthbnl9ICovXG5leHBvcnQgY29uc3QgVHlwZWRBcnJheSA9IFJlZmxlY3RHZXRQcm90b3R5cGVPZihVaW50OEFycmF5KTtcbmNvbnN0IFR5cGVkQXJyYXlGcm9tID0gVHlwZWRBcnJheS5mcm9tO1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5LnByb3RvdHlwZTtcbmV4cG9ydCBjb25zdCBOYXRpdmVUeXBlZEFycmF5UHJvdG90eXBlU3ltYm9sSXRlcmF0b3IgPSBUeXBlZEFycmF5UHJvdG90eXBlW1N5bWJvbEl0ZXJhdG9yXTtcbi8qKiBAdHlwZSB7KHR5cGVkQXJyYXk6IFR5cGVkQXJyYXkpID0+IEl0ZXJhYmxlSXRlcmF0b3I8bnVtYmVyPn0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlS2V5cyA9IHVuY3VycnlUaGlzKFR5cGVkQXJyYXlQcm90b3R5cGUua2V5cyk7XG4vKiogQHR5cGUgeyh0eXBlZEFycmF5OiBUeXBlZEFycmF5KSA9PiBJdGVyYWJsZUl0ZXJhdG9yPG51bWJlcj59ICovXG5leHBvcnQgY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZVZhbHVlcyA9IHVuY3VycnlUaGlzKFxuICBUeXBlZEFycmF5UHJvdG90eXBlLnZhbHVlc1xuKTtcbi8qKiBAdHlwZSB7KHR5cGVkQXJyYXk6IFR5cGVkQXJyYXkpID0+IEl0ZXJhYmxlSXRlcmF0b3I8W251bWJlciwgbnVtYmVyXT59ICovXG5leHBvcnQgY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZUVudHJpZXMgPSB1bmN1cnJ5VGhpcyhcbiAgVHlwZWRBcnJheVByb3RvdHlwZS5lbnRyaWVzXG4pO1xuLyoqIEB0eXBlIHsodHlwZWRBcnJheTogVHlwZWRBcnJheSwgYXJyYXk6IEFycmF5TGlrZTxudW1iZXI+LCBvZmZzZXQ/OiBudW1iZXIpID0+IHZvaWR9ICovXG5leHBvcnQgY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZVNldCA9IHVuY3VycnlUaGlzKFR5cGVkQXJyYXlQcm90b3R5cGUuc2V0KTtcbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyBUeXBlZEFycmF5Pih0eXBlZEFycmF5OiBUKSA9PiBUfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVSZXZlcnNlID0gdW5jdXJyeVRoaXMoXG4gIFR5cGVkQXJyYXlQcm90b3R5cGUucmV2ZXJzZVxuKTtcbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyBUeXBlZEFycmF5Pih0eXBlZEFycmF5OiBULCB2YWx1ZTogbnVtYmVyLCBzdGFydD86IG51bWJlciwgZW5kPzogbnVtYmVyKSA9PiBUfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVGaWxsID0gdW5jdXJyeVRoaXMoVHlwZWRBcnJheVByb3RvdHlwZS5maWxsKTtcbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyBUeXBlZEFycmF5Pih0eXBlZEFycmF5OiBULCB0YXJnZXQ6IG51bWJlciwgc3RhcnQ6IG51bWJlciwgZW5kPzogbnVtYmVyKSA9PiBUfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVDb3B5V2l0aGluID0gdW5jdXJyeVRoaXMoXG4gIFR5cGVkQXJyYXlQcm90b3R5cGUuY29weVdpdGhpblxuKTtcbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyBUeXBlZEFycmF5Pih0eXBlZEFycmF5OiBULCBjb21wYXJlRm4/OiAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IG51bWJlcikgPT4gVH0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlU29ydCA9IHVuY3VycnlUaGlzKFR5cGVkQXJyYXlQcm90b3R5cGUuc29ydCk7XG4vKiogQHR5cGUgezxUIGV4dGVuZHMgVHlwZWRBcnJheT4odHlwZWRBcnJheTogVCwgc3RhcnQ/OiBudW1iZXIsIGVuZD86IG51bWJlcikgPT4gVH0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlU2xpY2UgPSB1bmN1cnJ5VGhpcyhUeXBlZEFycmF5UHJvdG90eXBlLnNsaWNlKTtcbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyBUeXBlZEFycmF5Pih0eXBlZEFycmF5OiBULCBzdGFydD86IG51bWJlciwgZW5kPzogbnVtYmVyKSA9PiBUfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVTdWJhcnJheSA9IHVuY3VycnlUaGlzKFxuICBUeXBlZEFycmF5UHJvdG90eXBlLnN1YmFycmF5XG4pO1xuLyoqIEB0eXBlIHsoKHR5cGVkQXJyYXk6IFR5cGVkQXJyYXkpID0+IEFycmF5QnVmZmVyKX0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlR2V0QnVmZmVyID0gdW5jdXJyeVRoaXNHZXR0ZXIoXG4gIFR5cGVkQXJyYXlQcm90b3R5cGUsXG4gIFwiYnVmZmVyXCJcbik7XG4vKiogQHR5cGUgeygodHlwZWRBcnJheTogVHlwZWRBcnJheSkgPT4gbnVtYmVyKX0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlR2V0Qnl0ZU9mZnNldCA9IHVuY3VycnlUaGlzR2V0dGVyKFxuICBUeXBlZEFycmF5UHJvdG90eXBlLFxuICBcImJ5dGVPZmZzZXRcIlxuKTtcbi8qKiBAdHlwZSB7KCh0eXBlZEFycmF5OiBUeXBlZEFycmF5KSA9PiBudW1iZXIpfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVHZXRMZW5ndGggPSB1bmN1cnJ5VGhpc0dldHRlcihcbiAgVHlwZWRBcnJheVByb3RvdHlwZSxcbiAgXCJsZW5ndGhcIlxuKTtcbi8qKiBAdHlwZSB7KHRhcmdldDogdW5rbm93bikgPT4gc3RyaW5nfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVHZXRTeW1ib2xUb1N0cmluZ1RhZyA9IHVuY3VycnlUaGlzR2V0dGVyKFxuICBUeXBlZEFycmF5UHJvdG90eXBlLFxuICBTeW1ib2xUb1N0cmluZ1RhZ1xuKTtcblxuLy8gVWludDhBcnJheVxuZXhwb3J0IGNvbnN0IE5hdGl2ZVVpbnQ4QXJyYXkgPSBVaW50OEFycmF5O1xuXG4vLyBVaW50MTZBcnJheVxuZXhwb3J0IGNvbnN0IE5hdGl2ZVVpbnQxNkFycmF5ID0gVWludDE2QXJyYXk7XG4vKiogQHR5cGUge1VpbnQxNkFycmF5Q29uc3RydWN0b3JbXCJmcm9tXCJdfSAqL1xuZXhwb3J0IGNvbnN0IFVpbnQxNkFycmF5RnJvbSA9ICguLi5hcmdzKSA9PiB7XG4gIHJldHVybiBSZWZsZWN0QXBwbHkoVHlwZWRBcnJheUZyb20sIE5hdGl2ZVVpbnQxNkFycmF5LCBhcmdzKTtcbn07XG5cbi8vIFVpbnQzMkFycmF5XG5leHBvcnQgY29uc3QgTmF0aXZlVWludDMyQXJyYXkgPSBVaW50MzJBcnJheTtcblxuLy8gRmxvYXQzMkFycmF5XG5leHBvcnQgY29uc3QgTmF0aXZlRmxvYXQzMkFycmF5ID0gRmxvYXQzMkFycmF5O1xuXG4vLyBBcnJheUl0ZXJhdG9yXG4vKiogQHR5cGUge2FueX0gKi9cbmV4cG9ydCBjb25zdCBBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gUmVmbGVjdEdldFByb3RvdHlwZU9mKFtdW1N5bWJvbEl0ZXJhdG9yXSgpKTtcbi8qKiBAdHlwZSB7PFQ+KGFycmF5SXRlcmF0b3I6IEl0ZXJhYmxlSXRlcmF0b3I8VD4pID0+IEl0ZXJhdG9yUmVzdWx0PFQ+fSAqL1xuZXhwb3J0IGNvbnN0IEFycmF5SXRlcmF0b3JQcm90b3R5cGVOZXh0ID0gdW5jdXJyeVRoaXMoQXJyYXlJdGVyYXRvclByb3RvdHlwZS5uZXh0KTtcblxuLy8gR2VuZXJhdG9yXG4vKiogQHR5cGUgezxUID0gdW5rbm93biwgVFJldHVybiA9IGFueSwgVE5leHQgPSB1bmtub3duPihnZW5lcmF0b3I6IEdlbmVyYXRvcjxULCBUUmV0dXJuLCBUTmV4dD4sIHZhbHVlPzogVE5leHQpID0+IFR9ICovXG5leHBvcnQgY29uc3QgR2VuZXJhdG9yUHJvdG90eXBlTmV4dCA9IHVuY3VycnlUaGlzKChmdW5jdGlvbiogKCkge30pKCkubmV4dCk7XG5cbi8vIEl0ZXJhdG9yXG5leHBvcnQgY29uc3QgSXRlcmF0b3JQcm90b3R5cGUgPSBSZWZsZWN0R2V0UHJvdG90eXBlT2YoQXJyYXlJdGVyYXRvclByb3RvdHlwZSk7XG5cbi8vIERhdGFWaWV3XG5jb25zdCBEYXRhVmlld1Byb3RvdHlwZSA9IERhdGFWaWV3LnByb3RvdHlwZTtcbi8qKiBAdHlwZSB7KGRhdGFWaWV3OiBEYXRhVmlldywgYnl0ZU9mZnNldDogbnVtYmVyLCBsaXR0bGVFbmRpYW4/OiBib29sZWFuKSA9PiBudW1iZXJ9ICovXG5leHBvcnQgY29uc3QgRGF0YVZpZXdQcm90b3R5cGVHZXRVaW50MTYgPSB1bmN1cnJ5VGhpcyhcbiAgRGF0YVZpZXdQcm90b3R5cGUuZ2V0VWludDE2XG4pO1xuLyoqIEB0eXBlIHsoZGF0YVZpZXc6IERhdGFWaWV3LCBieXRlT2Zmc2V0OiBudW1iZXIsIHZhbHVlOiBudW1iZXIsIGxpdHRsZUVuZGlhbj86IGJvb2xlYW4pID0+IHZvaWR9ICovXG5leHBvcnQgY29uc3QgRGF0YVZpZXdQcm90b3R5cGVTZXRVaW50MTYgPSB1bmN1cnJ5VGhpcyhcbiAgRGF0YVZpZXdQcm90b3R5cGUuc2V0VWludDE2XG4pO1xuXG4vLyBFcnJvclxuZXhwb3J0IGNvbnN0IE5hdGl2ZVR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbmV4cG9ydCBjb25zdCBOYXRpdmVSYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcblxuLy8gV2Vha1NldFxuLyoqXG4gKiBEbyBub3QgY29uc3RydWN0IHdpdGggYXJndW1lbnRzIHRvIGF2b2lkIGNhbGxpbmcgdGhlIFwiYWRkXCIgbWV0aG9kXG4gKiBAdHlwZSB7e25ldyA8VCBleHRlbmRzIHt9PigpOiBXZWFrU2V0PFQ+fX1cbiAqL1xuZXhwb3J0IGNvbnN0IE5hdGl2ZVdlYWtTZXQgPSBXZWFrU2V0O1xuY29uc3QgV2Vha1NldFByb3RvdHlwZSA9IE5hdGl2ZVdlYWtTZXQucHJvdG90eXBlO1xuLyoqIEB0eXBlIHs8VCBleHRlbmRzIHt9PihzZXQ6IFdlYWtTZXQ8VD4sIHZhbHVlOiBUKSA9PiBTZXQ8VD59ICovXG5leHBvcnQgY29uc3QgV2Vha1NldFByb3RvdHlwZUFkZCA9IHVuY3VycnlUaGlzKFdlYWtTZXRQcm90b3R5cGUuYWRkKTtcbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyB7fT4oc2V0OiBXZWFrU2V0PFQ+LCB2YWx1ZTogVCkgPT4gYm9vbGVhbn0gKi9cbmV4cG9ydCBjb25zdCBXZWFrU2V0UHJvdG90eXBlSGFzID0gdW5jdXJyeVRoaXMoV2Vha1NldFByb3RvdHlwZS5oYXMpO1xuXG4vLyBXZWFrTWFwXG4vKipcbiAqIERvIG5vdCBjb25zdHJ1Y3Qgd2l0aCBhcmd1bWVudHMgdG8gYXZvaWQgY2FsbGluZyB0aGUgXCJzZXRcIiBtZXRob2RcbiAqIEB0eXBlIHt7bmV3IDxLIGV4dGVuZHMge30sIFY+KCk6IFdlYWtNYXA8SywgVj59fVxuICovXG5leHBvcnQgY29uc3QgTmF0aXZlV2Vha01hcCA9IFdlYWtNYXA7XG5jb25zdCBXZWFrTWFwUHJvdG90eXBlID0gTmF0aXZlV2Vha01hcC5wcm90b3R5cGU7XG4vKiogQHR5cGUgezxLIGV4dGVuZHMge30sIFY+KHdlYWtNYXA6IFdlYWtNYXA8SywgVj4sIGtleTogSykgPT4gVn0gKi9cbmV4cG9ydCBjb25zdCBXZWFrTWFwUHJvdG90eXBlR2V0ID0gdW5jdXJyeVRoaXMoV2Vha01hcFByb3RvdHlwZS5nZXQpO1xuLyoqIEB0eXBlIHs8SyBleHRlbmRzIHt9LCBWPih3ZWFrTWFwOiBXZWFrTWFwPEssIFY+LCBrZXk6IEspID0+IGJvb2xlYW59ICovXG5leHBvcnQgY29uc3QgV2Vha01hcFByb3RvdHlwZUhhcyA9IHVuY3VycnlUaGlzKFdlYWtNYXBQcm90b3R5cGUuaGFzKTtcbi8qKiBAdHlwZSB7PEsgZXh0ZW5kcyB7fSwgVj4od2Vha01hcDogV2Vha01hcDxLLCBWPiwga2V5OiBLLCB2YWx1ZTogVikgPT4gV2Vha01hcH0gKi9cbmV4cG9ydCBjb25zdCBXZWFrTWFwUHJvdG90eXBlU2V0ID0gdW5jdXJyeVRoaXMoV2Vha01hcFByb3RvdHlwZS5zZXQpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@petamoriken/float16/src/_util/primordials.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/compression/basedecoder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/basedecoder.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ BaseDecoder; }\n/* harmony export */ });\n/* harmony import */ var _predictor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../predictor.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/predictor.js\");\n\n\nclass BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return (0,_predictor_js__WEBPACK_IMPORTED_MODULE_0__.applyPredictor)(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2NvbXByZXNzaW9uL2Jhc2VkZWNvZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlEOztBQUVsQztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkRBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvY29tcHJlc3Npb24vYmFzZWRlY29kZXIuanM/ZmQ5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcHBseVByZWRpY3RvciB9IGZyb20gJy4uL3ByZWRpY3Rvci5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VEZWNvZGVyIHtcbiAgYXN5bmMgZGVjb2RlKGZpbGVEaXJlY3RvcnksIGJ1ZmZlcikge1xuICAgIGNvbnN0IGRlY29kZWQgPSBhd2FpdCB0aGlzLmRlY29kZUJsb2NrKGJ1ZmZlcik7XG4gICAgY29uc3QgcHJlZGljdG9yID0gZmlsZURpcmVjdG9yeS5QcmVkaWN0b3IgfHwgMTtcbiAgICBpZiAocHJlZGljdG9yICE9PSAxKSB7XG4gICAgICBjb25zdCBpc1RpbGVkID0gIWZpbGVEaXJlY3RvcnkuU3RyaXBPZmZzZXRzO1xuICAgICAgY29uc3QgdGlsZVdpZHRoID0gaXNUaWxlZCA/IGZpbGVEaXJlY3RvcnkuVGlsZVdpZHRoIDogZmlsZURpcmVjdG9yeS5JbWFnZVdpZHRoO1xuICAgICAgY29uc3QgdGlsZUhlaWdodCA9IGlzVGlsZWQgPyBmaWxlRGlyZWN0b3J5LlRpbGVMZW5ndGggOiAoXG4gICAgICAgIGZpbGVEaXJlY3RvcnkuUm93c1BlclN0cmlwIHx8IGZpbGVEaXJlY3RvcnkuSW1hZ2VMZW5ndGhcbiAgICAgICk7XG4gICAgICByZXR1cm4gYXBwbHlQcmVkaWN0b3IoXG4gICAgICAgIGRlY29kZWQsIHByZWRpY3RvciwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0LCBmaWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGUsXG4gICAgICAgIGZpbGVEaXJlY3RvcnkuUGxhbmFyQ29uZmlndXJhdGlvbixcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/compression/basedecoder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/compression/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addDecoder: function() { return /* binding */ addDecoder; },\n/* harmony export */   getDecoder: function() { return /* binding */ getDecoder; }\n/* harmony export */ });\nconst registry = new Map();\n\nfunction addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nasync function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_geotiff_dist-module_compression_raw_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./raw.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/raw.js\")).then((m) => m.default));\naddDecoder(5, () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_geotiff_dist-module_compression_lzw_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./lzw.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/lzw.js\")).then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_geotiff_dist-module_compression_jpeg_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./jpeg.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/jpeg.js\")).then((m) => m.default));\naddDecoder([8, 32946], () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_geotiff_dist-module_compression_deflate_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./deflate.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/deflate.js\")).then((m) => m.default));\naddDecoder(32773, () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_geotiff_dist-module_compression_packbits_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./packbits.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/packbits.js\")).then((m) => m.default));\naddDecoder(34887, () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_geotiff_dist-module_compression_lerc_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./lerc.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/lerc.js\"))\n  .then(async (m) => {\n    await m.zstd.init();\n    return m;\n  })\n  .then((m) => m.default),\n);\naddDecoder(50001, () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_geotiff_dist-module_compression_webimage_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./webimage.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/webimage.js\")).then((m) => m.default));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2NvbXByZXNzaW9uL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBRU87QUFDUDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsOERBQThELDBCQUEwQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxnUUFBa0I7QUFDbkQsb0JBQW9CLGdRQUFrQjtBQUN0QztBQUNBO0FBQ0EsQ0FBQztBQUNELG9CQUFvQixtUUFBbUI7QUFDdkMsNkJBQTZCLDRRQUFzQjtBQUNuRCx3QkFBd0IsK1FBQXVCO0FBQy9DLHdCQUF3QixtUUFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3QkFBd0IsK1FBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2NvbXByZXNzaW9uL2luZGV4LmpzPzliYTIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcmVnaXN0cnkgPSBuZXcgTWFwKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGREZWNvZGVyKGNhc2VzLCBpbXBvcnRGbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2FzZXMpKSB7XG4gICAgY2FzZXMgPSBbY2FzZXNdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIH1cbiAgY2FzZXMuZm9yRWFjaCgoYykgPT4gcmVnaXN0cnkuc2V0KGMsIGltcG9ydEZuKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREZWNvZGVyKGZpbGVEaXJlY3RvcnkpIHtcbiAgY29uc3QgaW1wb3J0Rm4gPSByZWdpc3RyeS5nZXQoZmlsZURpcmVjdG9yeS5Db21wcmVzc2lvbik7XG4gIGlmICghaW1wb3J0Rm4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY29tcHJlc3Npb24gbWV0aG9kIGlkZW50aWZpZXI6ICR7ZmlsZURpcmVjdG9yeS5Db21wcmVzc2lvbn1gKTtcbiAgfVxuICBjb25zdCBEZWNvZGVyID0gYXdhaXQgaW1wb3J0Rm4oKTtcbiAgcmV0dXJuIG5ldyBEZWNvZGVyKGZpbGVEaXJlY3RvcnkpO1xufVxuXG4vLyBBZGQgZGVmYXVsdCBkZWNvZGVycyB0byByZWdpc3RyeSAoZW5kLXVzZXIgbWF5IG92ZXJyaWRlIHdpdGggb3RoZXIgaW1wbGVtZW50YXRpb25zKVxuYWRkRGVjb2RlcihbdW5kZWZpbmVkLCAxXSwgKCkgPT4gaW1wb3J0KCcuL3Jhdy5qcycpLnRoZW4oKG0pID0+IG0uZGVmYXVsdCkpO1xuYWRkRGVjb2Rlcig1LCAoKSA9PiBpbXBvcnQoJy4vbHp3LmpzJykudGhlbigobSkgPT4gbS5kZWZhdWx0KSk7XG5hZGREZWNvZGVyKDYsICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdvbGQgc3R5bGUgSlBFRyBjb21wcmVzc2lvbiBpcyBub3Qgc3VwcG9ydGVkLicpO1xufSk7XG5hZGREZWNvZGVyKDcsICgpID0+IGltcG9ydCgnLi9qcGVnLmpzJykudGhlbigobSkgPT4gbS5kZWZhdWx0KSk7XG5hZGREZWNvZGVyKFs4LCAzMjk0Nl0sICgpID0+IGltcG9ydCgnLi9kZWZsYXRlLmpzJykudGhlbigobSkgPT4gbS5kZWZhdWx0KSk7XG5hZGREZWNvZGVyKDMyNzczLCAoKSA9PiBpbXBvcnQoJy4vcGFja2JpdHMuanMnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbmFkZERlY29kZXIoMzQ4ODcsICgpID0+IGltcG9ydCgnLi9sZXJjLmpzJylcbiAgLnRoZW4oYXN5bmMgKG0pID0+IHtcbiAgICBhd2FpdCBtLnpzdGQuaW5pdCgpO1xuICAgIHJldHVybiBtO1xuICB9KVxuICAudGhlbigobSkgPT4gbS5kZWZhdWx0KSxcbik7XG5hZGREZWNvZGVyKDUwMDAxLCAoKSA9PiBpbXBvcnQoJy4vd2ViaW1hZ2UuanMnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/compression/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/dataslice.js":
/*!*******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/dataslice.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ DataSlice; }\n/* harmony export */ });\nclass DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2RhdGFzbGljZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvZGF0YXNsaWNlLmpzPzE2NGYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0YVNsaWNlIHtcbiAgY29uc3RydWN0b3IoYXJyYXlCdWZmZXIsIHNsaWNlT2Zmc2V0LCBsaXR0bGVFbmRpYW4sIGJpZ1RpZmYpIHtcbiAgICB0aGlzLl9kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgdGhpcy5fc2xpY2VPZmZzZXQgPSBzbGljZU9mZnNldDtcbiAgICB0aGlzLl9saXR0bGVFbmRpYW4gPSBsaXR0bGVFbmRpYW47XG4gICAgdGhpcy5fYmlnVGlmZiA9IGJpZ1RpZmY7XG4gIH1cblxuICBnZXQgc2xpY2VPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NsaWNlT2Zmc2V0O1xuICB9XG5cbiAgZ2V0IHNsaWNlVG9wKCkge1xuICAgIHJldHVybiB0aGlzLl9zbGljZU9mZnNldCArIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gIH1cblxuICBnZXQgbGl0dGxlRW5kaWFuKCkge1xuICAgIHJldHVybiB0aGlzLl9saXR0bGVFbmRpYW47XG4gIH1cblxuICBnZXQgYmlnVGlmZigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmlnVGlmZjtcbiAgfVxuXG4gIGdldCBidWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmJ1ZmZlcjtcbiAgfVxuXG4gIGNvdmVycyhvZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlT2Zmc2V0IDw9IG9mZnNldCAmJiB0aGlzLnNsaWNlVG9wID49IG9mZnNldCArIGxlbmd0aDtcbiAgfVxuXG4gIHJlYWRVaW50OChvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDgoXG4gICAgICBvZmZzZXQgLSB0aGlzLl9zbGljZU9mZnNldCwgdGhpcy5fbGl0dGxlRW5kaWFuLFxuICAgICk7XG4gIH1cblxuICByZWFkSW50OChvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0SW50OChcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRVaW50MTYob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldFVpbnQxNihcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRJbnQxNihvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0SW50MTYoXG4gICAgICBvZmZzZXQgLSB0aGlzLl9zbGljZU9mZnNldCwgdGhpcy5fbGl0dGxlRW5kaWFuLFxuICAgICk7XG4gIH1cblxuICByZWFkVWludDMyKG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRVaW50MzIoXG4gICAgICBvZmZzZXQgLSB0aGlzLl9zbGljZU9mZnNldCwgdGhpcy5fbGl0dGxlRW5kaWFuLFxuICAgICk7XG4gIH1cblxuICByZWFkSW50MzIob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEludDMyKFxuICAgICAgb2Zmc2V0IC0gdGhpcy5fc2xpY2VPZmZzZXQsIHRoaXMuX2xpdHRsZUVuZGlhbixcbiAgICApO1xuICB9XG5cbiAgcmVhZEZsb2F0MzIob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEZsb2F0MzIoXG4gICAgICBvZmZzZXQgLSB0aGlzLl9zbGljZU9mZnNldCwgdGhpcy5fbGl0dGxlRW5kaWFuLFxuICAgICk7XG4gIH1cblxuICByZWFkRmxvYXQ2NChvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0RmxvYXQ2NChcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRVaW50NjQob2Zmc2V0KSB7XG4gICAgY29uc3QgbGVmdCA9IHRoaXMucmVhZFVpbnQzMihvZmZzZXQpO1xuICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5yZWFkVWludDMyKG9mZnNldCArIDQpO1xuICAgIGxldCBjb21iaW5lZDtcbiAgICBpZiAodGhpcy5fbGl0dGxlRW5kaWFuKSB7XG4gICAgICBjb21iaW5lZCA9IGxlZnQgKyAoKDIgKiogMzIpICogcmlnaHQpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjb21iaW5lZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke2NvbWJpbmVkfSBleGNlZWRzIE1BWF9TQUZFX0lOVEVHRVIuIGBcbiAgICAgICAgICArICdQcmVjaXNpb24gbWF5IGJlIGxvc3QuIFBsZWFzZSByZXBvcnQgaWYgeW91IGdldCB0aGlzIG1lc3NhZ2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL2dlb3RpZmZqcy9nZW90aWZmLmpzL2lzc3VlcycsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tYmluZWQ7XG4gICAgfVxuICAgIGNvbWJpbmVkID0gKCgyICoqIDMyKSAqIGxlZnQpICsgcmlnaHQ7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjb21iaW5lZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7Y29tYmluZWR9IGV4Y2VlZHMgTUFYX1NBRkVfSU5URUdFUi4gYFxuICAgICAgICArICdQcmVjaXNpb24gbWF5IGJlIGxvc3QuIFBsZWFzZSByZXBvcnQgaWYgeW91IGdldCB0aGlzIG1lc3NhZ2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL2dlb3RpZmZqcy9nZW90aWZmLmpzL2lzc3VlcycsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjb21iaW5lZDtcbiAgfVxuXG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTUzMzgzODQvODA2MDU5MVxuICByZWFkSW50NjQob2Zmc2V0KSB7XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICBjb25zdCBpc05lZ2F0aXZlID0gKHRoaXMuX2RhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArICh0aGlzLl9saXR0bGVFbmRpYW4gPyA3IDogMCkpICYgMHg4MClcbiAgICAgID4gMDtcbiAgICBsZXQgY2FycnlpbmcgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICBsZXQgYnl0ZSA9IHRoaXMuX2RhdGFWaWV3LmdldFVpbnQ4KFxuICAgICAgICBvZmZzZXQgKyAodGhpcy5fbGl0dGxlRW5kaWFuID8gaSA6IDcgLSBpKSxcbiAgICAgICk7XG4gICAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgICBpZiAoY2FycnlpbmcpIHtcbiAgICAgICAgICBpZiAoYnl0ZSAhPT0gMHgwMCkge1xuICAgICAgICAgICAgYnl0ZSA9IH4oYnl0ZSAtIDEpICYgMHhmZjtcbiAgICAgICAgICAgIGNhcnJ5aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ5dGUgPSB+Ynl0ZSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhbHVlICs9IGJ5dGUgKiAoMjU2ICoqIGkpO1xuICAgIH1cbiAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJlYWRPZmZzZXQob2Zmc2V0KSB7XG4gICAgaWYgKHRoaXMuX2JpZ1RpZmYpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRVaW50NjQob2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVhZFVpbnQzMihvZmZzZXQpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/dataslice.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/dataview64.js":
/*!********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/dataview64.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ DataView64; }\n/* harmony export */ });\n/* harmony import */ var _petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @petamoriken/float16 */ \"(app-pages-browser)/./node_modules/@petamoriken/float16/src/DataView.mjs\");\n\n\nclass DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return (0,_petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__.getFloat16)(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2RhdGF2aWV3NjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0Q7O0FBRW5DO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxnRUFBVTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvZGF0YXZpZXc2NC5qcz84YzUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEZsb2F0MTYgfSBmcm9tICdAcGV0YW1vcmlrZW4vZmxvYXQxNic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGFWaWV3NjQge1xuICBjb25zdHJ1Y3RvcihhcnJheUJ1ZmZlcikge1xuICAgIHRoaXMuX2RhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgfVxuXG4gIGdldCBidWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmJ1ZmZlcjtcbiAgfVxuXG4gIGdldFVpbnQ2NChvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIGNvbnN0IGxlZnQgPSB0aGlzLmdldFVpbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gICAgY29uc3QgcmlnaHQgPSB0aGlzLmdldFVpbnQzMihvZmZzZXQgKyA0LCBsaXR0bGVFbmRpYW4pO1xuICAgIGxldCBjb21iaW5lZDtcbiAgICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgICBjb21iaW5lZCA9IGxlZnQgKyAoKDIgKiogMzIpICogcmlnaHQpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjb21iaW5lZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke2NvbWJpbmVkfSBleGNlZWRzIE1BWF9TQUZFX0lOVEVHRVIuIGBcbiAgICAgICAgICArICdQcmVjaXNpb24gbWF5IGJlIGxvc3QuIFBsZWFzZSByZXBvcnQgaWYgeW91IGdldCB0aGlzIG1lc3NhZ2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL2dlb3RpZmZqcy9nZW90aWZmLmpzL2lzc3VlcycsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tYmluZWQ7XG4gICAgfVxuICAgIGNvbWJpbmVkID0gKCgyICoqIDMyKSAqIGxlZnQpICsgcmlnaHQ7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjb21iaW5lZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7Y29tYmluZWR9IGV4Y2VlZHMgTUFYX1NBRkVfSU5URUdFUi4gYFxuICAgICAgICArICdQcmVjaXNpb24gbWF5IGJlIGxvc3QuIFBsZWFzZSByZXBvcnQgaWYgeW91IGdldCB0aGlzIG1lc3NhZ2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL2dlb3RpZmZqcy9nZW90aWZmLmpzL2lzc3VlcycsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjb21iaW5lZDtcbiAgfVxuXG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTUzMzgzODQvODA2MDU5MVxuICBnZXRJbnQ2NChvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgY29uc3QgaXNOZWdhdGl2ZSA9ICh0aGlzLl9kYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyAobGl0dGxlRW5kaWFuID8gNyA6IDApKSAmIDB4ODApID4gMDtcbiAgICBsZXQgY2FycnlpbmcgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICBsZXQgYnl0ZSA9IHRoaXMuX2RhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIChsaXR0bGVFbmRpYW4gPyBpIDogNyAtIGkpKTtcbiAgICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICAgIGlmIChjYXJyeWluZykge1xuICAgICAgICAgIGlmIChieXRlICE9PSAweDAwKSB7XG4gICAgICAgICAgICBieXRlID0gfihieXRlIC0gMSkgJiAweGZmO1xuICAgICAgICAgICAgY2FycnlpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnl0ZSA9IH5ieXRlICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFsdWUgKz0gYnl0ZSAqICgyNTYgKiogaSk7XG4gICAgfVxuICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZ2V0VWludDgob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0SW50OChvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRJbnQ4KG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgfVxuXG4gIGdldFVpbnQxNihvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0SW50MTYob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0VWludDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRJbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRJbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRGbG9hdDE2KG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIGdldEZsb2F0MTYodGhpcy5fZGF0YVZpZXcsIG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgfVxuXG4gIGdldEZsb2F0MzIob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0RmxvYXQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRGbG9hdDY0KG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEZsb2F0NjQob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/dataview64.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/geotiff.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiff.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseClient: function() { return /* reexport safe */ _source_client_base_js__WEBPACK_IMPORTED_MODULE_14__.BaseClient; },\n/* harmony export */   BaseDecoder: function() { return /* reexport safe */ _compression_basedecoder_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   BaseResponse: function() { return /* reexport safe */ _source_client_base_js__WEBPACK_IMPORTED_MODULE_14__.BaseResponse; },\n/* harmony export */   GeoTIFF: function() { return /* binding */ GeoTIFF; },\n/* harmony export */   GeoTIFFImage: function() { return /* reexport safe */ _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; },\n/* harmony export */   MultiGeoTIFF: function() { return /* binding */ MultiGeoTIFF; },\n/* harmony export */   Pool: function() { return /* reexport safe */ _pool_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"]; },\n/* harmony export */   addDecoder: function() { return /* reexport safe */ _compression_index_js__WEBPACK_IMPORTED_MODULE_3__.addDecoder; },\n/* harmony export */   fromArrayBuffer: function() { return /* binding */ fromArrayBuffer; },\n/* harmony export */   fromBlob: function() { return /* binding */ fromBlob; },\n/* harmony export */   fromCustomClient: function() { return /* binding */ fromCustomClient; },\n/* harmony export */   fromFile: function() { return /* binding */ fromFile; },\n/* harmony export */   fromUrl: function() { return /* binding */ fromUrl; },\n/* harmony export */   fromUrls: function() { return /* binding */ fromUrls; },\n/* harmony export */   getDecoder: function() { return /* reexport safe */ _compression_index_js__WEBPACK_IMPORTED_MODULE_3__.getDecoder; },\n/* harmony export */   globals: function() { return /* reexport module object */ _globals_js__WEBPACK_IMPORTED_MODULE_0__; },\n/* harmony export */   rgb: function() { return /* reexport module object */ _rgb_js__WEBPACK_IMPORTED_MODULE_1__; },\n/* harmony export */   setLogger: function() { return /* reexport safe */ _logging_js__WEBPACK_IMPORTED_MODULE_4__.setLogger; },\n/* harmony export */   writeArrayBuffer: function() { return /* binding */ writeArrayBuffer; }\n/* harmony export */ });\n/* harmony import */ var _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geotiffimage.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/geotiffimage.js\");\n/* harmony import */ var _dataview64_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dataview64.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/dataview64.js\");\n/* harmony import */ var _dataslice_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dataslice.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/dataslice.js\");\n/* harmony import */ var _pool_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./pool.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/pool.js\");\n/* harmony import */ var _source_remote_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./source/remote.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/remote.js\");\n/* harmony import */ var _source_arraybuffer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./source/arraybuffer.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/arraybuffer.js\");\n/* harmony import */ var _source_filereader_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./source/filereader.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/filereader.js\");\n/* harmony import */ var _source_file_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./source/file.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/file.js\");\n/* harmony import */ var _source_client_base_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./source/client/base.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _geotiffwriter_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./geotiffwriter.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/geotiffwriter.js\");\n/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rgb.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/rgb.js\");\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./compression/index.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/index.js\");\n/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./logging.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/logging.js\");\n/* harmony import */ var _compression_basedecoder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compression/basedecoder.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n/** @module geotiff */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.BYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SBYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.UNDEFINED:\n      return 1;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SHORT: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SSHORT:\n      return 2;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.FLOAT: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD:\n      return 4;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.DOUBLE:\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = _globals_js__WEBPACK_IMPORTED_MODULE_0__.geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (_globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.BYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL || fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new _dataslice_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && _globals_js__WEBPACK_IMPORTED_MODULE_0__.arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL || fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[_globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new _dataview64_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GeoTIFF);\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\n\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeRemoteSource)(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeCustomSource)(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource((0,_source_arraybuffer_js__WEBPACK_IMPORTED_MODULE_9__.makeBufferSource)(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromFile(path, signal) {\n  return GeoTIFF.fromSource((0,_source_file_js__WEBPACK_IMPORTED_MODULE_10__.makeFileSource)(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource((0,_source_filereader_js__WEBPACK_IMPORTED_MODULE_11__.makeFileReaderSource)(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nasync function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeRemoteSource)(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeRemoteSource)(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nfunction writeArrayBuffer(values, metadata) {\n  return (0,_geotiffwriter_js__WEBPACK_IMPORTED_MODULE_12__.writeGeotiff)(values, metadata);\n}\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2dlb3RpZmYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQzZDO0FBQ0o7QUFDRjtBQUNWOztBQUUyQztBQUNiO0FBQ0c7QUFDWjtBQUNpQjs7QUFFZ0I7QUFDakM7QUFDVjtBQUNSO0FBQ2dDO0FBQ3ZCOztBQUV0QjtBQUNKO0FBQ3VEO0FBQ3BDO0FBQ2I7O0FBRXJCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGdDQUFnQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCLGNBQWM7QUFDakQsYUFBYSx5QkFBeUI7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQixjQUFjO0FBQ25ELGFBQWEsMkJBQTJCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0IsY0FBYztBQUNsRSxhQUFhLDBEQUEwRDtBQUN2RTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxtREFBVSxZQUFZLG1EQUFVLGFBQWEsbURBQVUsYUFBYSxtREFBVTtBQUN2RjtBQUNBLFNBQVMsbURBQVUsYUFBYSxtREFBVTtBQUMxQztBQUNBLFNBQVMsbURBQVUsWUFBWSxtREFBVSxhQUFhLG1EQUFVLGFBQWEsbURBQVU7QUFDdkY7QUFDQSxTQUFTLG1EQUFVLGdCQUFnQixtREFBVSxpQkFBaUIsbURBQVU7QUFDeEUsU0FBUyxtREFBVSxhQUFhLG1EQUFVLGNBQWMsbURBQVU7QUFDbEU7QUFDQTtBQUNBLGtEQUFrRCxVQUFVO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixnQ0FBZ0M7QUFDbEQsZ0JBQWdCLG9EQUFXO0FBQzNCO0FBQ0EsU0FBUyxzREFBYTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMERBQTBELElBQUk7QUFDOUQsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxtREFBVSxZQUFZLG1EQUFVLGFBQWEsbURBQVU7QUFDaEUsc0NBQXNDO0FBQ3RDO0FBQ0EsU0FBUyxtREFBVTtBQUNuQixxQ0FBcUM7QUFDckM7QUFDQSxTQUFTLG1EQUFVO0FBQ25CLHVDQUF1QztBQUN2QztBQUNBLFNBQVMsbURBQVU7QUFDbkIsc0NBQXNDO0FBQ3RDO0FBQ0EsU0FBUyxtREFBVSxZQUFZLG1EQUFVO0FBQ3pDLHVDQUF1QztBQUN2QztBQUNBLFNBQVMsbURBQVU7QUFDbkIsc0NBQXNDO0FBQ3RDO0FBQ0EsU0FBUyxtREFBVSxhQUFhLG1EQUFVO0FBQzFDLGlDQUFpQztBQUNqQztBQUNBLFNBQVMsbURBQVU7QUFDbkIsaUNBQWlDO0FBQ2pDO0FBQ0EsU0FBUyxtREFBVTtBQUNuQiwyQ0FBMkM7QUFDM0M7QUFDQSxTQUFTLG1EQUFVO0FBQ25CLDBDQUEwQztBQUMxQztBQUNBLFNBQVMsbURBQVU7QUFDbkIsd0NBQXdDO0FBQ3hDO0FBQ0EsU0FBUyxtREFBVTtBQUNuQix3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLGtEQUFrRCxVQUFVO0FBQzVEOztBQUVBO0FBQ0Esc0JBQXNCLG1EQUFVLDJCQUEyQixtREFBVTtBQUNyRSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksT0FBTztBQUNYLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLG1EQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBO0FBQ0EsYUFBYSw0Q0FBNEMsV0FBVztBQUNwRSxlQUFlLDJCQUEyQjtBQUMxQztBQUNBLGdDQUFnQztBQUNoQyxZQUFZLHFDQUFxQztBQUNqRCxVQUFVLG1CQUFtQjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQSxnQkFBZ0IsMkRBQTJEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyx5QkFBeUI7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVM7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUscURBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLDZCQUE2QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZCQUE2Qiw0QkFBNEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUEsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixvREFBVztBQUN4QywyQkFBMkIsbURBQVUsMkJBQTJCLG1EQUFVO0FBQzFFO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isc0RBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxlQUFlLHdEQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsbURBQVU7QUFDdkQsNENBQTRDLG1EQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbURBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLGdCQUFnQjtBQUM3QixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlCQUF5QjtBQUN2RSx5QkFBeUIsc0RBQVU7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtQjtBQUNuQiwrREFBZSxPQUFPLEVBQUM7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBLHFCQUFxQix3REFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXdCOztBQUV4QjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixrQ0FBa0Msd0JBQXdCO0FBQzFELFdBQVcsYUFBYTtBQUN4QjtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ08sd0NBQXdDO0FBQy9DLDRCQUE0QixtRUFBZ0I7QUFDNUM7O0FBRUE7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pELFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsa0NBQWtDLHdCQUF3QjtBQUMxRCxXQUFXLGFBQWE7QUFDeEI7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNPLG9EQUFvRDtBQUMzRCw0QkFBNEIsbUVBQWdCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsbUdBQW1HO0FBQ3BILFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEI7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNPO0FBQ1AsNEJBQTRCLHdFQUFnQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNDQUFzQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEI7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNPO0FBQ1AsNEJBQTRCLGdFQUFjO0FBQzFDOztBQUVBO0FBQ0E7QUFDQSxVQUFVLDZEQUE2RDtBQUN2RSxVQUFVO0FBQ1Y7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDTztBQUNQLDRCQUE0Qiw0RUFBb0I7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLG9EQUFvRDtBQUNwRDtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ08sZ0VBQWdFO0FBQ3ZFLDRDQUE0QyxtRUFBZ0I7QUFDNUQ7QUFDQSxpREFBaUQsbUVBQWdCO0FBQ2pFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFVBQVU7QUFDdkI7QUFDTztBQUNQLFNBQVMsZ0VBQVk7QUFDckI7O0FBRWdCO0FBQ1E7QUFDWSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmLmpzPzMyZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBtb2R1bGUgZ2VvdGlmZiAqL1xuaW1wb3J0IEdlb1RJRkZJbWFnZSBmcm9tICcuL2dlb3RpZmZpbWFnZS5qcyc7XG5pbXBvcnQgRGF0YVZpZXc2NCBmcm9tICcuL2RhdGF2aWV3NjQuanMnO1xuaW1wb3J0IERhdGFTbGljZSBmcm9tICcuL2RhdGFzbGljZS5qcyc7XG5pbXBvcnQgUG9vbCBmcm9tICcuL3Bvb2wuanMnO1xuXG5pbXBvcnQgeyBtYWtlUmVtb3RlU291cmNlLCBtYWtlQ3VzdG9tU291cmNlIH0gZnJvbSAnLi9zb3VyY2UvcmVtb3RlLmpzJztcbmltcG9ydCB7IG1ha2VCdWZmZXJTb3VyY2UgfSBmcm9tICcuL3NvdXJjZS9hcnJheWJ1ZmZlci5qcyc7XG5pbXBvcnQgeyBtYWtlRmlsZVJlYWRlclNvdXJjZSB9IGZyb20gJy4vc291cmNlL2ZpbGVyZWFkZXIuanMnO1xuaW1wb3J0IHsgbWFrZUZpbGVTb3VyY2UgfSBmcm9tICcuL3NvdXJjZS9maWxlLmpzJztcbmltcG9ydCB7IEJhc2VDbGllbnQsIEJhc2VSZXNwb25zZSB9IGZyb20gJy4vc291cmNlL2NsaWVudC9iYXNlLmpzJztcblxuaW1wb3J0IHsgZmllbGRUeXBlcywgZmllbGRUYWdOYW1lcywgYXJyYXlGaWVsZHMsIGdlb0tleU5hbWVzIH0gZnJvbSAnLi9nbG9iYWxzLmpzJztcbmltcG9ydCB7IHdyaXRlR2VvdGlmZiB9IGZyb20gJy4vZ2VvdGlmZndyaXRlci5qcyc7XG5pbXBvcnQgKiBhcyBnbG9iYWxzIGZyb20gJy4vZ2xvYmFscy5qcyc7XG5pbXBvcnQgKiBhcyByZ2IgZnJvbSAnLi9yZ2IuanMnO1xuaW1wb3J0IHsgZ2V0RGVjb2RlciwgYWRkRGVjb2RlciB9IGZyb20gJy4vY29tcHJlc3Npb24vaW5kZXguanMnO1xuaW1wb3J0IHsgc2V0TG9nZ2VyIH0gZnJvbSAnLi9sb2dnaW5nLmpzJztcblxuZXhwb3J0IHsgZ2xvYmFscyB9O1xuZXhwb3J0IHsgcmdiIH07XG5leHBvcnQgeyBkZWZhdWx0IGFzIEJhc2VEZWNvZGVyIH0gZnJvbSAnLi9jb21wcmVzc2lvbi9iYXNlZGVjb2Rlci5qcyc7XG5leHBvcnQgeyBnZXREZWNvZGVyLCBhZGREZWNvZGVyIH07XG5leHBvcnQgeyBzZXRMb2dnZXIgfTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7VWludDhBcnJheSB8IEludDhBcnJheSB8IFVpbnQxNkFycmF5IHwgSW50MTZBcnJheSB8IFVpbnQzMkFycmF5IHwgSW50MzJBcnJheSB8IEZsb2F0MzJBcnJheSB8IEZsb2F0NjRBcnJheX1cbiAqIFR5cGVkQXJyYXlcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7IGhlaWdodDpudW1iZXIsIHdpZHRoOiBudW1iZXIgfX0gRGltZW5zaW9uc1xuICovXG5cbi8qKlxuICogVGhlIGF1dG9nZW5lcmF0ZWQgZG9jcyBhcmUgYSBsaXR0bGUgY29uZnVzaW5nIGhlcmUuIFRoZSBlZmZlY3RpdmUgdHlwZSBpczpcbiAqXG4gKiBgVHlwZWRBcnJheSAmIHsgaGVpZ2h0OiBudW1iZXI7IHdpZHRoOiBudW1iZXJ9YFxuICogQHR5cGVkZWYge1R5cGVkQXJyYXkgJiBEaW1lbnNpb25zfSBUeXBlZEFycmF5V2l0aERpbWVuc2lvbnNcbiAqL1xuXG4vKipcbiAqIFRoZSBhdXRvZ2VuZXJhdGVkIGRvY3MgYXJlIGEgbGl0dGxlIGNvbmZ1c2luZyBoZXJlLiBUaGUgZWZmZWN0aXZlIHR5cGUgaXM6XG4gKlxuICogYFR5cGVkQXJyYXlbXSAmIHsgaGVpZ2h0OiBudW1iZXI7IHdpZHRoOiBudW1iZXJ9YFxuICogQHR5cGVkZWYge1R5cGVkQXJyYXlbXSAmIERpbWVuc2lvbnN9IFR5cGVkQXJyYXlBcnJheVdpdGhEaW1lbnNpb25zXG4gKi9cblxuLyoqXG4gKiAgVGhlIGF1dG9nZW5lcmF0ZWQgZG9jcyBhcmUgYSBsaXR0bGUgY29uZnVzaW5nIGhlcmUuIFRoZSBlZmZlY3RpdmUgdHlwZSBpczpcbiAqXG4gKiBgKFR5cGVkQXJyYXkgfCBUeXBlZEFycmF5W10pICYgeyBoZWlnaHQ6IG51bWJlcjsgd2lkdGg6IG51bWJlcn1gXG4gKiBAdHlwZWRlZiB7VHlwZWRBcnJheVdpdGhEaW1lbnNpb25zIHwgVHlwZWRBcnJheUFycmF5V2l0aERpbWVuc2lvbnN9IFJlYWRSYXN0ZXJSZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBnZXRGaWVsZFR5cGVMZW5ndGgoZmllbGRUeXBlKSB7XG4gIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkJZVEU6IGNhc2UgZmllbGRUeXBlcy5BU0NJSTogY2FzZSBmaWVsZFR5cGVzLlNCWVRFOiBjYXNlIGZpZWxkVHlwZXMuVU5ERUZJTkVEOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSBmaWVsZFR5cGVzLlNIT1JUOiBjYXNlIGZpZWxkVHlwZXMuU1NIT1JUOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkxPTkc6IGNhc2UgZmllbGRUeXBlcy5TTE9ORzogY2FzZSBmaWVsZFR5cGVzLkZMT0FUOiBjYXNlIGZpZWxkVHlwZXMuSUZEOlxuICAgICAgcmV0dXJuIDQ7XG4gICAgY2FzZSBmaWVsZFR5cGVzLlJBVElPTkFMOiBjYXNlIGZpZWxkVHlwZXMuU1JBVElPTkFMOiBjYXNlIGZpZWxkVHlwZXMuRE9VQkxFOlxuICAgIGNhc2UgZmllbGRUeXBlcy5MT05HODogY2FzZSBmaWVsZFR5cGVzLlNMT05HODogY2FzZSBmaWVsZFR5cGVzLklGRDg6XG4gICAgICByZXR1cm4gODtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgZmllbGQgdHlwZTogJHtmaWVsZFR5cGV9YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VHZW9LZXlEaXJlY3RvcnkoZmlsZURpcmVjdG9yeSkge1xuICBjb25zdCByYXdHZW9LZXlEaXJlY3RvcnkgPSBmaWxlRGlyZWN0b3J5Lkdlb0tleURpcmVjdG9yeTtcbiAgaWYgKCFyYXdHZW9LZXlEaXJlY3RvcnkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGdlb0tleURpcmVjdG9yeSA9IHt9O1xuICBmb3IgKGxldCBpID0gNDsgaSA8PSByYXdHZW9LZXlEaXJlY3RvcnlbM10gKiA0OyBpICs9IDQpIHtcbiAgICBjb25zdCBrZXkgPSBnZW9LZXlOYW1lc1tyYXdHZW9LZXlEaXJlY3RvcnlbaV1dO1xuICAgIGNvbnN0IGxvY2F0aW9uID0gKHJhd0dlb0tleURpcmVjdG9yeVtpICsgMV0pXG4gICAgICA/IChmaWVsZFRhZ05hbWVzW3Jhd0dlb0tleURpcmVjdG9yeVtpICsgMV1dKSA6IG51bGw7XG4gICAgY29uc3QgY291bnQgPSByYXdHZW9LZXlEaXJlY3RvcnlbaSArIDJdO1xuICAgIGNvbnN0IG9mZnNldCA9IHJhd0dlb0tleURpcmVjdG9yeVtpICsgM107XG5cbiAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgIGlmICghbG9jYXRpb24pIHtcbiAgICAgIHZhbHVlID0gb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGZpbGVEaXJlY3RvcnlbbG9jYXRpb25dO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZ2V0IHZhbHVlIG9mIGdlb0tleSAnJHtrZXl9Jy5gKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIGNvdW50IC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLnN1YmFycmF5KSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBjb3VudCk7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZ2VvS2V5RGlyZWN0b3J5W2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gZ2VvS2V5RGlyZWN0b3J5O1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZXMoZGF0YVNsaWNlLCBmaWVsZFR5cGUsIGNvdW50LCBvZmZzZXQpIHtcbiAgbGV0IHZhbHVlcyA9IG51bGw7XG4gIGxldCByZWFkTWV0aG9kID0gbnVsbDtcbiAgY29uc3QgZmllbGRUeXBlTGVuZ3RoID0gZ2V0RmllbGRUeXBlTGVuZ3RoKGZpZWxkVHlwZSk7XG5cbiAgc3dpdGNoIChmaWVsZFR5cGUpIHtcbiAgICBjYXNlIGZpZWxkVHlwZXMuQllURTogY2FzZSBmaWVsZFR5cGVzLkFTQ0lJOiBjYXNlIGZpZWxkVHlwZXMuVU5ERUZJTkVEOlxuICAgICAgdmFsdWVzID0gbmV3IFVpbnQ4QXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRVaW50ODtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TQllURTpcbiAgICAgIHZhbHVlcyA9IG5ldyBJbnQ4QXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRJbnQ4O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLlNIT1JUOlxuICAgICAgdmFsdWVzID0gbmV3IFVpbnQxNkFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkVWludDE2O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLlNTSE9SVDpcbiAgICAgIHZhbHVlcyA9IG5ldyBJbnQxNkFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkSW50MTY7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuTE9ORzogY2FzZSBmaWVsZFR5cGVzLklGRDpcbiAgICAgIHZhbHVlcyA9IG5ldyBVaW50MzJBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZFVpbnQzMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TTE9ORzpcbiAgICAgIHZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkSW50MzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuTE9ORzg6IGNhc2UgZmllbGRUeXBlcy5JRkQ4OlxuICAgICAgdmFsdWVzID0gbmV3IEFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkVWludDY0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLlNMT05HODpcbiAgICAgIHZhbHVlcyA9IG5ldyBBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZEludDY0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLlJBVElPTkFMOlxuICAgICAgdmFsdWVzID0gbmV3IFVpbnQzMkFycmF5KGNvdW50ICogMik7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZFVpbnQzMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TUkFUSU9OQUw6XG4gICAgICB2YWx1ZXMgPSBuZXcgSW50MzJBcnJheShjb3VudCAqIDIpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRJbnQzMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5GTE9BVDpcbiAgICAgIHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRGbG9hdDMyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkRPVUJMRTpcbiAgICAgIHZhbHVlcyA9IG5ldyBGbG9hdDY0QXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRGbG9hdDY0O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGZpZWxkIHR5cGU6ICR7ZmllbGRUeXBlfWApO1xuICB9XG5cbiAgLy8gbm9ybWFsIGZpZWxkc1xuICBpZiAoIShmaWVsZFR5cGUgPT09IGZpZWxkVHlwZXMuUkFUSU9OQUwgfHwgZmllbGRUeXBlID09PSBmaWVsZFR5cGVzLlNSQVRJT05BTCkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIHZhbHVlc1tpXSA9IHJlYWRNZXRob2QuY2FsbChcbiAgICAgICAgZGF0YVNsaWNlLCBvZmZzZXQgKyAoaSAqIGZpZWxkVHlwZUxlbmd0aCksXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHsgLy8gUkFUSU9OQUwgb3IgU1JBVElPTkFMXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAyKSB7XG4gICAgICB2YWx1ZXNbaV0gPSByZWFkTWV0aG9kLmNhbGwoXG4gICAgICAgIGRhdGFTbGljZSwgb2Zmc2V0ICsgKGkgKiBmaWVsZFR5cGVMZW5ndGgpLFxuICAgICAgKTtcbiAgICAgIHZhbHVlc1tpICsgMV0gPSByZWFkTWV0aG9kLmNhbGwoXG4gICAgICAgIGRhdGFTbGljZSwgb2Zmc2V0ICsgKChpICogZmllbGRUeXBlTGVuZ3RoKSArIDQpLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZmllbGRUeXBlID09PSBmaWVsZFR5cGVzLkFTQ0lJKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKS5kZWNvZGUodmFsdWVzKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuXG4vKipcbiAqIERhdGEgY2xhc3MgdG8gc3RvcmUgdGhlIHBhcnNlZCBmaWxlIGRpcmVjdG9yeSwgZ2VvIGtleSBkaXJlY3RvcnkgYW5kXG4gKiBvZmZzZXQgdG8gdGhlIG5leHQgSUZEXG4gKi9cbmNsYXNzIEltYWdlRmlsZURpcmVjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKGZpbGVEaXJlY3RvcnksIGdlb0tleURpcmVjdG9yeSwgbmV4dElGREJ5dGVPZmZzZXQpIHtcbiAgICB0aGlzLmZpbGVEaXJlY3RvcnkgPSBmaWxlRGlyZWN0b3J5O1xuICAgIHRoaXMuZ2VvS2V5RGlyZWN0b3J5ID0gZ2VvS2V5RGlyZWN0b3J5O1xuICAgIHRoaXMubmV4dElGREJ5dGVPZmZzZXQgPSBuZXh0SUZEQnl0ZU9mZnNldDtcbiAgfVxufVxuXG4vKipcbiAqIEVycm9yIGNsYXNzIGZvciBjYXNlcyB3aGVuIGFuIElGRCBpbmRleCB3YXMgcmVxdWVzdGVkLCB0aGF0IGRvZXMgbm90IGV4aXN0XG4gKiBpbiB0aGUgZmlsZS5cbiAqL1xuY2xhc3MgR2VvVElGRkltYWdlSW5kZXhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoaW5kZXgpIHtcbiAgICBzdXBlcihgTm8gaW1hZ2UgYXQgaW5kZXggJHtpbmRleH1gKTtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gIH1cbn1cblxuY2xhc3MgR2VvVElGRkJhc2Uge1xuICAvKipcbiAgICogKGV4cGVyaW1lbnRhbCkgUmVhZHMgcmFzdGVyIGRhdGEgZnJvbSB0aGUgYmVzdCBmaXR0aW5nIGltYWdlLiBUaGlzIGZ1bmN0aW9uIHVzZXNcbiAgICogdGhlIGltYWdlIHdpdGggdGhlIGxvd2VzdCByZXNvbHV0aW9uIHRoYXQgaXMgc3RpbGwgYSBoaWdoZXIgcmVzb2x1dGlvbiB0aGFuIHRoZVxuICAgKiByZXF1ZXN0ZWQgcmVzb2x1dGlvbi5cbiAgICogV2hlbiBzcGVjaWZpZWQsIHRoZSBgYmJveGAgb3B0aW9uIGlzIHRyYW5zbGF0ZWQgdG8gdGhlIGB3aW5kb3dgIG9wdGlvbiBhbmQgdGhlXG4gICAqIGByZXNYYCBhbmQgYHJlc1lgIHRvIGB3aWR0aGAgYW5kIGBoZWlnaHRgIHJlc3BlY3RpdmVseS5cbiAgICogVGhlbiwgdGhlIFtyZWFkUmFzdGVyc117QGxpbmsgR2VvVElGRkltYWdlI3JlYWRSYXN0ZXJzfSBtZXRob2Qgb2YgdGhlIHNlbGVjdGVkXG4gICAqIGltYWdlIGlzIGNhbGxlZCBhbmQgdGhlIHJlc3VsdCByZXR1cm5lZC5cbiAgICogQHNlZSBHZW9USUZGSW1hZ2UucmVhZFJhc3RlcnNcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vZ2VvdGlmZmltYWdlJykuUmVhZFJhc3Rlck9wdGlvbnN9IFtvcHRpb25zPXt9XSBvcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRSYXN0ZXJSZXN1bHQ+fSB0aGUgZGVjb2RlZCBhcnJheShzKSwgd2l0aCBgaGVpZ2h0YCBhbmQgYHdpZHRoYCwgYXMgYSBwcm9taXNlXG4gICAqL1xuICBhc3luYyByZWFkUmFzdGVycyhvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHdpbmRvdzogaW1hZ2VXaW5kb3csIHdpZHRoLCBoZWlnaHQgfSA9IG9wdGlvbnM7XG4gICAgbGV0IHsgcmVzWCwgcmVzWSwgYmJveCB9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGZpcnN0SW1hZ2UgPSBhd2FpdCB0aGlzLmdldEltYWdlKCk7XG4gICAgbGV0IHVzZWRJbWFnZSA9IGZpcnN0SW1hZ2U7XG4gICAgY29uc3QgaW1hZ2VDb3VudCA9IGF3YWl0IHRoaXMuZ2V0SW1hZ2VDb3VudCgpO1xuICAgIGNvbnN0IGltZ0JCb3ggPSBmaXJzdEltYWdlLmdldEJvdW5kaW5nQm94KCk7XG5cbiAgICBpZiAoaW1hZ2VXaW5kb3cgJiYgYmJveCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIFwiYmJveFwiIGFuZCBcIndpbmRvd1wiIHBhc3NlZC4nKTtcbiAgICB9XG5cbiAgICAvLyBpZiB3aWR0aC9oZWlnaHQgaXMgcGFzc2VkLCB0cmFuc2Zvcm0gaXQgdG8gcmVzb2x1dGlvblxuICAgIGlmICh3aWR0aCB8fCBoZWlnaHQpIHtcbiAgICAgIC8vIGlmIHdlIGhhdmUgYW4gaW1hZ2Ugd2luZG93IChwaXhlbCBjb29yZGluYXRlcyksIHRyYW5zZm9ybSBpdCB0byBhIEJCb3hcbiAgICAgIC8vIHVzaW5nIHRoZSBvcmlnaW4vcmVzb2x1dGlvbiBvZiB0aGUgZmlyc3QgaW1hZ2UuXG4gICAgICBpZiAoaW1hZ2VXaW5kb3cpIHtcbiAgICAgICAgY29uc3QgW29YLCBvWV0gPSBmaXJzdEltYWdlLmdldE9yaWdpbigpO1xuICAgICAgICBjb25zdCBbclgsIHJZXSA9IGZpcnN0SW1hZ2UuZ2V0UmVzb2x1dGlvbigpO1xuXG4gICAgICAgIGJib3ggPSBbXG4gICAgICAgICAgb1ggKyAoaW1hZ2VXaW5kb3dbMF0gKiByWCksXG4gICAgICAgICAgb1kgKyAoaW1hZ2VXaW5kb3dbMV0gKiByWSksXG4gICAgICAgICAgb1ggKyAoaW1hZ2VXaW5kb3dbMl0gKiByWCksXG4gICAgICAgICAgb1kgKyAoaW1hZ2VXaW5kb3dbM10gKiByWSksXG4gICAgICAgIF07XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlIGhhdmUgYSBiYm94IChvciBjYWxjdWxhdGVkIG9uZSlcblxuICAgICAgY29uc3QgdXNlZEJCb3ggPSBiYm94IHx8IGltZ0JCb3g7XG5cbiAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICBpZiAocmVzWCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCB3aWR0aCBhbmQgcmVzWCBwYXNzZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXNYID0gKHVzZWRCQm94WzJdIC0gdXNlZEJCb3hbMF0pIC8gd2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0KSB7XG4gICAgICAgIGlmIChyZXNZKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIHdpZHRoIGFuZCByZXNZIHBhc3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJlc1kgPSAodXNlZEJCb3hbM10gLSB1c2VkQkJveFsxXSkgLyBoZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgcmVzb2x1dGlvbiBpcyBzZXQgb3IgY2FsY3VsYXRlZCwgdHJ5IHRvIGdldCB0aGUgaW1hZ2Ugd2l0aCB0aGUgd29yc3QgYWNjZXB0YWJsZSByZXNvbHV0aW9uXG4gICAgaWYgKHJlc1ggfHwgcmVzWSkge1xuICAgICAgY29uc3QgYWxsSW1hZ2VzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlQ291bnQ7ICsraSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IGF3YWl0IHRoaXMuZ2V0SW1hZ2UoaSk7XG4gICAgICAgIGNvbnN0IHsgU3ViZmlsZVR5cGU6IHN1YmZpbGVUeXBlLCBOZXdTdWJmaWxlVHlwZTogbmV3U3ViZmlsZVR5cGUgfSA9IGltYWdlLmZpbGVEaXJlY3Rvcnk7XG4gICAgICAgIGlmIChpID09PSAwIHx8IHN1YmZpbGVUeXBlID09PSAyIHx8IG5ld1N1YmZpbGVUeXBlICYgMSkge1xuICAgICAgICAgIGFsbEltYWdlcy5wdXNoKGltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhbGxJbWFnZXMuc29ydCgoYSwgYikgPT4gYS5nZXRXaWR0aCgpIC0gYi5nZXRXaWR0aCgpKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsSW1hZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gYWxsSW1hZ2VzW2ldO1xuICAgICAgICBjb25zdCBpbWdSZXNYID0gKGltZ0JCb3hbMl0gLSBpbWdCQm94WzBdKSAvIGltYWdlLmdldFdpZHRoKCk7XG4gICAgICAgIGNvbnN0IGltZ1Jlc1kgPSAoaW1nQkJveFszXSAtIGltZ0JCb3hbMV0pIC8gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgdXNlZEltYWdlID0gaW1hZ2U7XG4gICAgICAgIGlmICgocmVzWCAmJiByZXNYID4gaW1nUmVzWCkgfHwgKHJlc1kgJiYgcmVzWSA+IGltZ1Jlc1kpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgd25kID0gaW1hZ2VXaW5kb3c7XG4gICAgaWYgKGJib3gpIHtcbiAgICAgIGNvbnN0IFtvWCwgb1ldID0gZmlyc3RJbWFnZS5nZXRPcmlnaW4oKTtcbiAgICAgIGNvbnN0IFtpbWFnZVJlc1gsIGltYWdlUmVzWV0gPSB1c2VkSW1hZ2UuZ2V0UmVzb2x1dGlvbihmaXJzdEltYWdlKTtcblxuICAgICAgd25kID0gW1xuICAgICAgICBNYXRoLnJvdW5kKChiYm94WzBdIC0gb1gpIC8gaW1hZ2VSZXNYKSxcbiAgICAgICAgTWF0aC5yb3VuZCgoYmJveFsxXSAtIG9ZKSAvIGltYWdlUmVzWSksXG4gICAgICAgIE1hdGgucm91bmQoKGJib3hbMl0gLSBvWCkgLyBpbWFnZVJlc1gpLFxuICAgICAgICBNYXRoLnJvdW5kKChiYm94WzNdIC0gb1kpIC8gaW1hZ2VSZXNZKSxcbiAgICAgIF07XG4gICAgICB3bmQgPSBbXG4gICAgICAgIE1hdGgubWluKHduZFswXSwgd25kWzJdKSxcbiAgICAgICAgTWF0aC5taW4od25kWzFdLCB3bmRbM10pLFxuICAgICAgICBNYXRoLm1heCh3bmRbMF0sIHduZFsyXSksXG4gICAgICAgIE1hdGgubWF4KHduZFsxXSwgd25kWzNdKSxcbiAgICAgIF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHVzZWRJbWFnZS5yZWFkUmFzdGVycyh7IC4uLm9wdGlvbnMsIHdpbmRvdzogd25kIH0pO1xuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gR2VvVElGRk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NhY2hlPWZhbHNlXSB3aGV0aGVyIG9yIG5vdCBkZWNvZGVkIHRpbGVzIHNoYWxsIGJlIGNhY2hlZC5cbiAqL1xuXG4vKipcbiAqIFRoZSBhYnN0cmFjdGlvbiBmb3IgYSB3aG9sZSBHZW9USUZGIGZpbGUuXG4gKiBAYXVnbWVudHMgR2VvVElGRkJhc2VcbiAqL1xuY2xhc3MgR2VvVElGRiBleHRlbmRzIEdlb1RJRkZCYXNlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0geyp9IHNvdXJjZSBUaGUgZGF0YXNvdXJjZSB0byByZWFkIGZyb20uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdGhlIGltYWdlIHVzZXMgbGl0dGxlIGVuZGlhbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBiaWdUaWZmIFdoZXRoZXIgdGhlIGltYWdlIHVzZXMgYmlnVElGRiBjb252ZW50aW9ucy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZpcnN0SUZET2Zmc2V0IFRoZSBudW1lcmljIGJ5dGUtb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBpbWFnZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gdGhlIGZpcnN0IElGRC5cbiAgICogQHBhcmFtIHtHZW9USUZGT3B0aW9uc30gW29wdGlvbnNdIGZ1cnRoZXIgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgbGl0dGxlRW5kaWFuLCBiaWdUaWZmLCBmaXJzdElGRE9mZnNldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IGxpdHRsZUVuZGlhbjtcbiAgICB0aGlzLmJpZ1RpZmYgPSBiaWdUaWZmO1xuICAgIHRoaXMuZmlyc3RJRkRPZmZzZXQgPSBmaXJzdElGRE9mZnNldDtcbiAgICB0aGlzLmNhY2hlID0gb3B0aW9ucy5jYWNoZSB8fCBmYWxzZTtcbiAgICB0aGlzLmlmZFJlcXVlc3RzID0gW107XG4gICAgdGhpcy5naG9zdFZhbHVlcyA9IG51bGw7XG4gIH1cblxuICBhc3luYyBnZXRTbGljZShvZmZzZXQsIHNpemUpIHtcbiAgICBjb25zdCBmYWxsYmFja1NpemUgPSB0aGlzLmJpZ1RpZmYgPyA0MDQ4IDogMTAyNDtcbiAgICByZXR1cm4gbmV3IERhdGFTbGljZShcbiAgICAgIChhd2FpdCB0aGlzLnNvdXJjZS5mZXRjaChbe1xuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGxlbmd0aDogdHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnID8gc2l6ZSA6IGZhbGxiYWNrU2l6ZSxcbiAgICAgIH1dKSlbMF0sXG4gICAgICBvZmZzZXQsXG4gICAgICB0aGlzLmxpdHRsZUVuZGlhbixcbiAgICAgIHRoaXMuYmlnVGlmZixcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3RydWN0cyB0byBwYXJzZSBhbiBpbWFnZSBmaWxlIGRpcmVjdG9yeSBhdCB0aGUgZ2l2ZW4gZmlsZSBvZmZzZXQuXG4gICAqIEFzIHRoZXJlIGlzIG5vIHdheSB0byBlbnN1cmUgdGhhdCBhIGxvY2F0aW9uIGlzIGluZGVlZCB0aGUgc3RhcnQgb2YgYW4gSUZELFxuICAgKiB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIHdpdGggY2F1dGlvbiAoZS5nIG9ubHkgdXNpbmcgdGhlIElGRCBvZmZzZXRzIGZyb21cbiAgICogdGhlIGhlYWRlcnMgb3Igb3RoZXIgSUZEcykuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgdGhlIG9mZnNldCB0byBwYXJzZSB0aGUgSUZEIGF0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEltYWdlRmlsZURpcmVjdG9yeT59IHRoZSBwYXJzZWQgSUZEXG4gICAqL1xuICBhc3luYyBwYXJzZUZpbGVEaXJlY3RvcnlBdChvZmZzZXQpIHtcbiAgICBjb25zdCBlbnRyeVNpemUgPSB0aGlzLmJpZ1RpZmYgPyAyMCA6IDEyO1xuICAgIGNvbnN0IG9mZnNldFNpemUgPSB0aGlzLmJpZ1RpZmYgPyA4IDogMjtcblxuICAgIGxldCBkYXRhU2xpY2UgPSBhd2FpdCB0aGlzLmdldFNsaWNlKG9mZnNldCk7XG4gICAgY29uc3QgbnVtRGlyRW50cmllcyA9IHRoaXMuYmlnVGlmZlxuICAgICAgPyBkYXRhU2xpY2UucmVhZFVpbnQ2NChvZmZzZXQpXG4gICAgICA6IGRhdGFTbGljZS5yZWFkVWludDE2KG9mZnNldCk7XG5cbiAgICAvLyBpZiB0aGUgc2xpY2UgZG9lcyBub3QgY292ZXIgdGhlIHdob2xlIElGRCwgcmVxdWVzdCBhIGJpZ2dlciBzbGljZSwgd2hlcmUgdGhlXG4gICAgLy8gd2hvbGUgSUZEIGZpdHM6IG51bSBvZiBlbnRyaWVzICsgbiB4IHRhZyBsZW5ndGggKyBvZmZzZXQgdG8gbmV4dCBJRkRcbiAgICBjb25zdCBieXRlU2l6ZSA9IChudW1EaXJFbnRyaWVzICogZW50cnlTaXplKSArICh0aGlzLmJpZ1RpZmYgPyAxNiA6IDYpO1xuICAgIGlmICghZGF0YVNsaWNlLmNvdmVycyhvZmZzZXQsIGJ5dGVTaXplKSkge1xuICAgICAgZGF0YVNsaWNlID0gYXdhaXQgdGhpcy5nZXRTbGljZShvZmZzZXQsIGJ5dGVTaXplKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlRGlyZWN0b3J5ID0ge307XG5cbiAgICAvLyBsb29wIG92ZXIgdGhlIElGRCBhbmQgY3JlYXRlIGEgZmlsZSBkaXJlY3Rvcnkgb2JqZWN0XG4gICAgbGV0IGkgPSBvZmZzZXQgKyAodGhpcy5iaWdUaWZmID8gOCA6IDIpO1xuICAgIGZvciAobGV0IGVudHJ5Q291bnQgPSAwOyBlbnRyeUNvdW50IDwgbnVtRGlyRW50cmllczsgaSArPSBlbnRyeVNpemUsICsrZW50cnlDb3VudCkge1xuICAgICAgY29uc3QgZmllbGRUYWcgPSBkYXRhU2xpY2UucmVhZFVpbnQxNihpKTtcbiAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IGRhdGFTbGljZS5yZWFkVWludDE2KGkgKyAyKTtcbiAgICAgIGNvbnN0IHR5cGVDb3VudCA9IHRoaXMuYmlnVGlmZlxuICAgICAgICA/IGRhdGFTbGljZS5yZWFkVWludDY0KGkgKyA0KVxuICAgICAgICA6IGRhdGFTbGljZS5yZWFkVWludDMyKGkgKyA0KTtcblxuICAgICAgbGV0IGZpZWxkVmFsdWVzO1xuICAgICAgbGV0IHZhbHVlO1xuICAgICAgY29uc3QgZmllbGRUeXBlTGVuZ3RoID0gZ2V0RmllbGRUeXBlTGVuZ3RoKGZpZWxkVHlwZSk7XG4gICAgICBjb25zdCB2YWx1ZU9mZnNldCA9IGkgKyAodGhpcy5iaWdUaWZmID8gMTIgOiA4KTtcblxuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgdmFsdWUgaXMgZGlyZWN0bHkgZW5jb2RlZCBpbiB0aGUgdGFnIG9yIHJlZmVycyB0byBhXG4gICAgICAvLyBkaWZmZXJlbnQgZXh0ZXJuYWwgYnl0ZSByYW5nZVxuICAgICAgaWYgKGZpZWxkVHlwZUxlbmd0aCAqIHR5cGVDb3VudCA8PSAodGhpcy5iaWdUaWZmID8gOCA6IDQpKSB7XG4gICAgICAgIGZpZWxkVmFsdWVzID0gZ2V0VmFsdWVzKGRhdGFTbGljZSwgZmllbGRUeXBlLCB0eXBlQ291bnQsIHZhbHVlT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlc29sdmUgdGhlIHJlZmVyZW5jZSB0byB0aGUgYWN0dWFsIGJ5dGUgcmFuZ2VcbiAgICAgICAgY29uc3QgYWN0dWFsT2Zmc2V0ID0gZGF0YVNsaWNlLnJlYWRPZmZzZXQodmFsdWVPZmZzZXQpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZFR5cGVMZW5ndGgoZmllbGRUeXBlKSAqIHR5cGVDb3VudDtcblxuICAgICAgICAvLyBjaGVjaywgd2hldGhlciB3ZSBhY3R1YWxseSBjb3ZlciB0aGUgcmVmZXJlbmNlZCBieXRlIHJhbmdlOyBpZiBub3QsXG4gICAgICAgIC8vIHJlcXVlc3QgYSBuZXcgc2xpY2Ugb2YgYnl0ZXMgdG8gcmVhZCBmcm9tIGl0XG4gICAgICAgIGlmIChkYXRhU2xpY2UuY292ZXJzKGFjdHVhbE9mZnNldCwgbGVuZ3RoKSkge1xuICAgICAgICAgIGZpZWxkVmFsdWVzID0gZ2V0VmFsdWVzKGRhdGFTbGljZSwgZmllbGRUeXBlLCB0eXBlQ291bnQsIGFjdHVhbE9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZmllbGREYXRhU2xpY2UgPSBhd2FpdCB0aGlzLmdldFNsaWNlKGFjdHVhbE9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgICBmaWVsZFZhbHVlcyA9IGdldFZhbHVlcyhmaWVsZERhdGFTbGljZSwgZmllbGRUeXBlLCB0eXBlQ291bnQsIGFjdHVhbE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdW5wYWNrIHNpbmdsZSB2YWx1ZXMgZnJvbSB0aGUgYXJyYXlcbiAgICAgIGlmICh0eXBlQ291bnQgPT09IDEgJiYgYXJyYXlGaWVsZHMuaW5kZXhPZihmaWVsZFRhZykgPT09IC0xXG4gICAgICAgICYmICEoZmllbGRUeXBlID09PSBmaWVsZFR5cGVzLlJBVElPTkFMIHx8IGZpZWxkVHlwZSA9PT0gZmllbGRUeXBlcy5TUkFUSU9OQUwpKSB7XG4gICAgICAgIHZhbHVlID0gZmllbGRWYWx1ZXNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGZpZWxkVmFsdWVzO1xuICAgICAgfVxuXG4gICAgICAvLyB3cml0ZSB0aGUgdGFncyB2YWx1ZSB0byB0aGUgZmlsZSBkaXJlY3RseVxuICAgICAgZmlsZURpcmVjdG9yeVtmaWVsZFRhZ05hbWVzW2ZpZWxkVGFnXV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgZ2VvS2V5RGlyZWN0b3J5ID0gcGFyc2VHZW9LZXlEaXJlY3RvcnkoZmlsZURpcmVjdG9yeSk7XG4gICAgY29uc3QgbmV4dElGREJ5dGVPZmZzZXQgPSBkYXRhU2xpY2UucmVhZE9mZnNldChcbiAgICAgIG9mZnNldCArIG9mZnNldFNpemUgKyAoZW50cnlTaXplICogbnVtRGlyRW50cmllcyksXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgSW1hZ2VGaWxlRGlyZWN0b3J5KFxuICAgICAgZmlsZURpcmVjdG9yeSxcbiAgICAgIGdlb0tleURpcmVjdG9yeSxcbiAgICAgIG5leHRJRkRCeXRlT2Zmc2V0LFxuICAgICk7XG4gIH1cblxuICBhc3luYyByZXF1ZXN0SUZEKGluZGV4KSB7XG4gICAgLy8gc2VlIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGF0IElGRCBpbmRleCByZXF1ZXN0ZWQuXG4gICAgaWYgKHRoaXMuaWZkUmVxdWVzdHNbaW5kZXhdKSB7XG4gICAgICAvLyBhdHRhY2ggdG8gYW4gYWxyZWFkeSByZXF1ZXN0ZWQgSUZEXG4gICAgICByZXR1cm4gdGhpcy5pZmRSZXF1ZXN0c1tpbmRleF07XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBpbmRleCAwXG4gICAgICB0aGlzLmlmZFJlcXVlc3RzW2luZGV4XSA9IHRoaXMucGFyc2VGaWxlRGlyZWN0b3J5QXQodGhpcy5maXJzdElGRE9mZnNldCk7XG4gICAgICByZXR1cm4gdGhpcy5pZmRSZXF1ZXN0c1tpbmRleF07XG4gICAgfSBlbHNlIGlmICghdGhpcy5pZmRSZXF1ZXN0c1tpbmRleCAtIDFdKSB7XG4gICAgICAvLyBpZiB0aGUgcHJldmlvdXMgSUZEIHdhcyBub3QgeWV0IGxvYWRlZCwgbG9hZCB0aGF0IG9uZSBmaXJzdFxuICAgICAgLy8gdGhpcyBpcyB0aGUgcmVjdXJzaXZlIGNhbGwuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmlmZFJlcXVlc3RzW2luZGV4IC0gMV0gPSB0aGlzLnJlcXVlc3RJRkQoaW5kZXggLSAxKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWYgdGhlIHByZXZpb3VzIG9uZSBhbHJlYWR5IHdhcyBhbiBpbmRleCBlcnJvciwgcmV0aHJvd1xuICAgICAgICAvLyB3aXRoIHRoZSBjdXJyZW50IGluZGV4XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgR2VvVElGRkltYWdlSW5kZXhFcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBHZW9USUZGSW1hZ2VJbmRleEVycm9yKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXRocm93IGFueXRoaW5nIGVsc2VcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgdGhlIHByZXZpb3VzIElGRCB3YXMgbG9hZGVkLCB3ZSBjYW4gZmluYWxseSBmZXRjaCB0aGUgb25lIHdlIGFyZSBpbnRlcmVzdGVkIGluLlxuICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIGFuIElJRkUsIG90aGVyd2lzZSB0aGlzLmlmZFJlcXVlc3RzW2luZGV4XSB3b3VsZCBiZSBkZWxheWVkXG4gICAgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleF0gPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJldmlvdXNJZmQgPSBhd2FpdCB0aGlzLmlmZFJlcXVlc3RzW2luZGV4IC0gMV07XG4gICAgICBpZiAocHJldmlvdXNJZmQubmV4dElGREJ5dGVPZmZzZXQgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEdlb1RJRkZJbWFnZUluZGV4RXJyb3IoaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGaWxlRGlyZWN0b3J5QXQocHJldmlvdXNJZmQubmV4dElGREJ5dGVPZmZzZXQpO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHRoaXMuaWZkUmVxdWVzdHNbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbi10aCBpbnRlcm5hbCBzdWJmaWxlIG9mIGFuIGltYWdlLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MF0gdGhlIGluZGV4IG9mIHRoZSBpbWFnZSB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEdlb1RJRkZJbWFnZT59IHRoZSBpbWFnZSBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICovXG4gIGFzeW5jIGdldEltYWdlKGluZGV4ID0gMCkge1xuICAgIGNvbnN0IGlmZCA9IGF3YWl0IHRoaXMucmVxdWVzdElGRChpbmRleCk7XG4gICAgcmV0dXJuIG5ldyBHZW9USUZGSW1hZ2UoXG4gICAgICBpZmQuZmlsZURpcmVjdG9yeSwgaWZkLmdlb0tleURpcmVjdG9yeSxcbiAgICAgIHRoaXMuZGF0YVZpZXcsIHRoaXMubGl0dGxlRW5kaWFuLCB0aGlzLmNhY2hlLCB0aGlzLnNvdXJjZSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvdW50IG9mIHRoZSBpbnRlcm5hbCBzdWJmaWxlcy5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn0gdGhlIG51bWJlciBvZiBpbnRlcm5hbCBzdWJmaWxlIGltYWdlc1xuICAgKi9cbiAgYXN5bmMgZ2V0SW1hZ2VDb3VudCgpIHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIC8vIGxvb3AgdW50aWwgd2UgcnVuIG91dCBvZiBJRkRzXG4gICAgbGV0IGhhc05leHQgPSB0cnVlO1xuICAgIHdoaWxlIChoYXNOZXh0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlcXVlc3RJRkQoaW5kZXgpO1xuICAgICAgICArK2luZGV4O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEdlb1RJRkZJbWFnZUluZGV4RXJyb3IpIHtcbiAgICAgICAgICBoYXNOZXh0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZXMgb2YgdGhlIENPRyBnaG9zdCBhcmVhIGFzIGEgcGFyc2VkIG1hcC5cbiAgICogU2VlIGh0dHBzOi8vZ2RhbC5vcmcvZHJpdmVycy9yYXN0ZXIvY29nLmh0bWwjaGVhZGVyLWdob3N0LWFyZWEgZm9yIHJlZmVyZW5jZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSB0aGUgcGFyc2VkIGdob3N0IGFyZWEgb3IgbnVsbCwgaWYgbm8gc3VjaCBhcmVhIHdhcyBmb3VuZFxuICAgKi9cbiAgYXN5bmMgZ2V0R2hvc3RWYWx1ZXMoKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iaWdUaWZmID8gMTYgOiA4O1xuICAgIGlmICh0aGlzLmdob3N0VmFsdWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5naG9zdFZhbHVlcztcbiAgICB9XG4gICAgY29uc3QgZGV0ZWN0aW9uU3RyaW5nID0gJ0dEQUxfU1RSVUNUVVJBTF9NRVRBREFUQV9TSVpFPSc7XG4gICAgY29uc3QgaGV1cmlzdGljQXJlYVNpemUgPSBkZXRlY3Rpb25TdHJpbmcubGVuZ3RoICsgMTAwO1xuICAgIGxldCBzbGljZSA9IGF3YWl0IHRoaXMuZ2V0U2xpY2Uob2Zmc2V0LCBoZXVyaXN0aWNBcmVhU2l6ZSk7XG4gICAgaWYgKGRldGVjdGlvblN0cmluZyA9PT0gZ2V0VmFsdWVzKHNsaWNlLCBmaWVsZFR5cGVzLkFTQ0lJLCBkZXRlY3Rpb25TdHJpbmcubGVuZ3RoLCBvZmZzZXQpKSB7XG4gICAgICBjb25zdCB2YWx1ZXNTdHJpbmcgPSBnZXRWYWx1ZXMoc2xpY2UsIGZpZWxkVHlwZXMuQVNDSUksIGhldXJpc3RpY0FyZWFTaXplLCBvZmZzZXQpO1xuICAgICAgY29uc3QgZmlyc3RMaW5lID0gdmFsdWVzU3RyaW5nLnNwbGl0KCdcXG4nKVswXTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhU2l6ZSA9IE51bWJlcihmaXJzdExpbmUuc3BsaXQoJz0nKVsxXS5zcGxpdCgnICcpWzBdKSArIGZpcnN0TGluZS5sZW5ndGg7XG4gICAgICBpZiAobWV0YWRhdGFTaXplID4gaGV1cmlzdGljQXJlYVNpemUpIHtcbiAgICAgICAgc2xpY2UgPSBhd2FpdCB0aGlzLmdldFNsaWNlKG9mZnNldCwgbWV0YWRhdGFTaXplKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZ1bGxTdHJpbmcgPSBnZXRWYWx1ZXMoc2xpY2UsIGZpZWxkVHlwZXMuQVNDSUksIG1ldGFkYXRhU2l6ZSwgb2Zmc2V0KTtcbiAgICAgIHRoaXMuZ2hvc3RWYWx1ZXMgPSB7fTtcbiAgICAgIGZ1bGxTdHJpbmdcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAuZmlsdGVyKChsaW5lKSA9PiBsaW5lLmxlbmd0aCA+IDApXG4gICAgICAgIC5tYXAoKGxpbmUpID0+IGxpbmUuc3BsaXQoJz0nKSlcbiAgICAgICAgLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIHRoaXMuZ2hvc3RWYWx1ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2hvc3RWYWx1ZXM7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSAoR2VvKVRJRkYgZmlsZSBmcm9tIHRoZSBnaXZlbiBzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gc291cmNlIFRoZSBzb3VyY2Ugb2YgZGF0YSB0byBwYXJzZSBmcm9tLlxuICAgKiBAcGFyYW0ge0dlb1RJRkZPcHRpb25zfSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBbc2lnbmFsXSBBbiBBYm9ydFNpZ25hbCB0aGF0IG1heSBiZSBzaWduYWxsZWQgaWYgdGhlIHJlcXVlc3QgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21Tb3VyY2Uoc291cmNlLCBvcHRpb25zLCBzaWduYWwpIHtcbiAgICBjb25zdCBoZWFkZXJEYXRhID0gKGF3YWl0IHNvdXJjZS5mZXRjaChbeyBvZmZzZXQ6IDAsIGxlbmd0aDogMTAyNCB9XSwgc2lnbmFsKSlbMF07XG4gICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXc2NChoZWFkZXJEYXRhKTtcblxuICAgIGNvbnN0IEJPTSA9IGRhdGFWaWV3LmdldFVpbnQxNigwLCAwKTtcbiAgICBsZXQgbGl0dGxlRW5kaWFuO1xuICAgIGlmIChCT00gPT09IDB4NDk0OSkge1xuICAgICAgbGl0dGxlRW5kaWFuID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKEJPTSA9PT0gMHg0RDREKSB7XG4gICAgICBsaXR0bGVFbmRpYW4gPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBieXRlIG9yZGVyIHZhbHVlLicpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hZ2ljTnVtYmVyID0gZGF0YVZpZXcuZ2V0VWludDE2KDIsIGxpdHRsZUVuZGlhbik7XG4gICAgbGV0IGJpZ1RpZmY7XG4gICAgaWYgKG1hZ2ljTnVtYmVyID09PSA0Mikge1xuICAgICAgYmlnVGlmZiA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAobWFnaWNOdW1iZXIgPT09IDQzKSB7XG4gICAgICBiaWdUaWZmID0gdHJ1ZTtcbiAgICAgIGNvbnN0IG9mZnNldEJ5dGVTaXplID0gZGF0YVZpZXcuZ2V0VWludDE2KDQsIGxpdHRsZUVuZGlhbik7XG4gICAgICBpZiAob2Zmc2V0Qnl0ZVNpemUgIT09IDgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvZmZzZXQgYnl0ZS1zaXplLicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1hZ2ljIG51bWJlci4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdElGRE9mZnNldCA9IGJpZ1RpZmZcbiAgICAgID8gZGF0YVZpZXcuZ2V0VWludDY0KDgsIGxpdHRsZUVuZGlhbilcbiAgICAgIDogZGF0YVZpZXcuZ2V0VWludDMyKDQsIGxpdHRsZUVuZGlhbik7XG4gICAgcmV0dXJuIG5ldyBHZW9USUZGKHNvdXJjZSwgbGl0dGxlRW5kaWFuLCBiaWdUaWZmLCBmaXJzdElGRE9mZnNldCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSB1bmRlcmx5aW5nIGZpbGUgYnVmZmVyXG4gICAqIE4uQi4gQWZ0ZXIgdGhlIEdlb1RJRkYgaGFzIGJlZW4gY29tcGxldGVseSBwcm9jZXNzZWQgaXQgbmVlZHNcbiAgICogdG8gYmUgY2xvc2VkIGJ1dCBvbmx5IGlmIGl0IGhhcyBiZWVuIGNvbnN0cnVjdGVkIGZyb20gYSBmaWxlLlxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZS5jbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmNsb3NlKCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgeyBHZW9USUZGIH07XG5leHBvcnQgZGVmYXVsdCBHZW9USUZGO1xuXG4vKipcbiAqIFdyYXBwZXIgZm9yIEdlb1RJRkYgZmlsZXMgdGhhdCBoYXZlIGV4dGVybmFsIG92ZXJ2aWV3cy5cbiAqIEBhdWdtZW50cyBHZW9USUZGQmFzZVxuICovXG5jbGFzcyBNdWx0aUdlb1RJRkYgZXh0ZW5kcyBHZW9USUZGQmFzZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgTXVsdGlHZW9USUZGIGZyb20gYSBtYWluIGFuZCBzZXZlcmFsIG92ZXJ2aWV3IGZpbGVzLlxuICAgKiBAcGFyYW0ge0dlb1RJRkZ9IG1haW5GaWxlIFRoZSBtYWluIEdlb1RJRkYgZmlsZS5cbiAgICogQHBhcmFtIHtHZW9USUZGW119IG92ZXJ2aWV3RmlsZXMgQW4gYXJyYXkgb2Ygb3ZlcnZpZXcgZmlsZXMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtYWluRmlsZSwgb3ZlcnZpZXdGaWxlcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5tYWluRmlsZSA9IG1haW5GaWxlO1xuICAgIHRoaXMub3ZlcnZpZXdGaWxlcyA9IG92ZXJ2aWV3RmlsZXM7XG4gICAgdGhpcy5pbWFnZUZpbGVzID0gW21haW5GaWxlXS5jb25jYXQob3ZlcnZpZXdGaWxlcyk7XG5cbiAgICB0aGlzLmZpbGVEaXJlY3Rvcmllc1BlckZpbGUgPSBudWxsO1xuICAgIHRoaXMuZmlsZURpcmVjdG9yaWVzUGVyRmlsZVBhcnNpbmcgPSBudWxsO1xuICAgIHRoaXMuaW1hZ2VDb3VudCA9IG51bGw7XG4gIH1cblxuICBhc3luYyBwYXJzZUZpbGVEaXJlY3Rvcmllc1BlckZpbGUoKSB7XG4gICAgY29uc3QgcmVxdWVzdHMgPSBbdGhpcy5tYWluRmlsZS5wYXJzZUZpbGVEaXJlY3RvcnlBdCh0aGlzLm1haW5GaWxlLmZpcnN0SUZET2Zmc2V0KV1cbiAgICAgIC5jb25jYXQodGhpcy5vdmVydmlld0ZpbGVzLm1hcCgoZmlsZSkgPT4gZmlsZS5wYXJzZUZpbGVEaXJlY3RvcnlBdChmaWxlLmZpcnN0SUZET2Zmc2V0KSkpO1xuXG4gICAgdGhpcy5maWxlRGlyZWN0b3JpZXNQZXJGaWxlID0gYXdhaXQgUHJvbWlzZS5hbGwocmVxdWVzdHMpO1xuICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3Rvcmllc1BlckZpbGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuLXRoIGludGVybmFsIHN1YmZpbGUgb2YgYW4gaW1hZ2UuIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBpcyByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleD0wXSB0aGUgaW5kZXggb2YgdGhlIGltYWdlIHRvIHJldHVybi5cbiAgICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRkltYWdlPn0gdGhlIGltYWdlIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgKi9cbiAgYXN5bmMgZ2V0SW1hZ2UoaW5kZXggPSAwKSB7XG4gICAgYXdhaXQgdGhpcy5nZXRJbWFnZUNvdW50KCk7XG4gICAgYXdhaXQgdGhpcy5wYXJzZUZpbGVEaXJlY3Rvcmllc1BlckZpbGUoKTtcbiAgICBsZXQgdmlzaXRlZCA9IDA7XG4gICAgbGV0IHJlbGF0aXZlSW5kZXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbWFnZUZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbWFnZUZpbGUgPSB0aGlzLmltYWdlRmlsZXNbaV07XG4gICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgdGhpcy5pbWFnZUNvdW50c1tpXTsgaWkrKykge1xuICAgICAgICBpZiAoaW5kZXggPT09IHZpc2l0ZWQpIHtcbiAgICAgICAgICBjb25zdCBpZmQgPSBhd2FpdCBpbWFnZUZpbGUucmVxdWVzdElGRChyZWxhdGl2ZUluZGV4KTtcbiAgICAgICAgICByZXR1cm4gbmV3IEdlb1RJRkZJbWFnZShcbiAgICAgICAgICAgIGlmZC5maWxlRGlyZWN0b3J5LCBpZmQuZ2VvS2V5RGlyZWN0b3J5LFxuICAgICAgICAgICAgaW1hZ2VGaWxlLmRhdGFWaWV3LCBpbWFnZUZpbGUubGl0dGxlRW5kaWFuLCBpbWFnZUZpbGUuY2FjaGUsIGltYWdlRmlsZS5zb3VyY2UsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2aXNpdGVkKys7XG4gICAgICAgIHJlbGF0aXZlSW5kZXgrKztcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlSW5kZXggPSAwO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGltYWdlIGluZGV4Jyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY291bnQgb2YgdGhlIGludGVybmFsIHN1YmZpbGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fSB0aGUgbnVtYmVyIG9mIGludGVybmFsIHN1YmZpbGUgaW1hZ2VzXG4gICAqL1xuICBhc3luYyBnZXRJbWFnZUNvdW50KCkge1xuICAgIGlmICh0aGlzLmltYWdlQ291bnQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlQ291bnQ7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RzID0gW3RoaXMubWFpbkZpbGUuZ2V0SW1hZ2VDb3VudCgpXVxuICAgICAgLmNvbmNhdCh0aGlzLm92ZXJ2aWV3RmlsZXMubWFwKChmaWxlKSA9PiBmaWxlLmdldEltYWdlQ291bnQoKSkpO1xuICAgIHRoaXMuaW1hZ2VDb3VudHMgPSBhd2FpdCBQcm9taXNlLmFsbChyZXF1ZXN0cyk7XG4gICAgdGhpcy5pbWFnZUNvdW50ID0gdGhpcy5pbWFnZUNvdW50cy5yZWR1Y2UoKGNvdW50LCBpZmRzKSA9PiBjb3VudCArIGlmZHMsIDApO1xuICAgIHJldHVybiB0aGlzLmltYWdlQ291bnQ7XG4gIH1cbn1cblxuZXhwb3J0IHsgTXVsdGlHZW9USUZGIH07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBHZW9USUZGIGZyb20gYSByZW1vdGUgVVJMLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIGFjY2VzcyB0aGUgaW1hZ2UgZnJvbVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgc291cmNlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUge0BsaW5rIG1ha2VSZW1vdGVTb3VyY2V9IGZvciBkZXRhaWxzLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGPn0gVGhlIHJlc3VsdGluZyBHZW9USUZGIGZpbGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmcm9tVXJsKHVybCwgb3B0aW9ucyA9IHt9LCBzaWduYWwpIHtcbiAgcmV0dXJuIEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlUmVtb3RlU291cmNlKHVybCwgb3B0aW9ucyksIHNpZ25hbCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBHZW9USUZGIGZyb20gYSBjdXN0b20ge0BsaW5rIEJhc2VDbGllbnR9LlxuICogQHBhcmFtIHtCYXNlQ2xpZW50fSBjbGllbnQgVGhlIGNsaWVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNvdXJjZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayBtYWtlUmVtb3RlU291cmNlfSBmb3IgZGV0YWlscy5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRj59IFRoZSByZXN1bHRpbmcgR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbUN1c3RvbUNsaWVudChjbGllbnQsIG9wdGlvbnMgPSB7fSwgc2lnbmFsKSB7XG4gIHJldHVybiBHZW9USUZGLmZyb21Tb3VyY2UobWFrZUN1c3RvbVNvdXJjZShjbGllbnQsIG9wdGlvbnMpLCBzaWduYWwpO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdCBhIG5ldyBHZW9USUZGIGZyb20gYW5cbiAqIFtBcnJheUJ1ZmZlcl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXlCdWZmZXJ9LlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGRhdGEgdG8gcmVhZCB0aGUgZmlsZSBmcm9tLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGPn0gVGhlIHJlc3VsdGluZyBHZW9USUZGIGZpbGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIsIHNpZ25hbCkge1xuICByZXR1cm4gR2VvVElGRi5mcm9tU291cmNlKG1ha2VCdWZmZXJTb3VyY2UoYXJyYXlCdWZmZXIpLCBzaWduYWwpO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdCBhIEdlb1RJRkYgZnJvbSBhIGxvY2FsIGZpbGUgcGF0aC4gVGhpcyB1c2VzIHRoZSBub2RlXG4gKiBbZmlsZXN5c3RlbSBBUElde0BsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbH0gYW5kIGlzXG4gKiBub3QgYXZhaWxhYmxlIG9uIGJyb3dzZXJzLlxuICpcbiAqIE4uQi4gQWZ0ZXIgdGhlIEdlb1RJRkYgaGFzIGJlZW4gY29tcGxldGVseSBwcm9jZXNzZWQgaXQgbmVlZHNcbiAqIHRvIGJlIGNsb3NlZCBidXQgb25seSBpZiBpdCBoYXMgYmVlbiBjb25zdHJ1Y3RlZCBmcm9tIGEgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBmaWxlIHBhdGggdG8gcmVhZCBmcm9tLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGPn0gVGhlIHJlc3VsdGluZyBHZW9USUZGIGZpbGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmcm9tRmlsZShwYXRoLCBzaWduYWwpIHtcbiAgcmV0dXJuIEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlRmlsZVNvdXJjZShwYXRoKSwgc2lnbmFsKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBHZW9USUZGIGZyb20gYW4gSFRNTFxuICogW0Jsb2Jde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9CbG9ifSBvclxuICogW0ZpbGVde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GaWxlfVxuICogb2JqZWN0LlxuICogQHBhcmFtIHtCbG9ifEZpbGV9IGJsb2IgVGhlIEJsb2Igb3IgRmlsZSBvYmplY3QgdG8gcmVhZCBmcm9tLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGPn0gVGhlIHJlc3VsdGluZyBHZW9USUZGIGZpbGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmcm9tQmxvYihibG9iLCBzaWduYWwpIHtcbiAgcmV0dXJuIEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlRmlsZVJlYWRlclNvdXJjZShibG9iKSwgc2lnbmFsKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBNdWx0aUdlb1RJRkYgZnJvbSB0aGUgZ2l2ZW4gVVJMcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYWluVXJsIFRoZSBVUkwgZm9yIHRoZSBtYWluIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvdmVydmlld1VybHMgQW4gYXJyYXkgb2YgVVJMcyBmb3IgdGhlIG92ZXJ2aWV3IGltYWdlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNvdXJjZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIFttYWtlUmVtb3RlU291cmNlXXtAbGluayBtb2R1bGU6c291cmNlLm1ha2VSZW1vdGVTb3VyY2V9XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBkZXRhaWxzLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNdWx0aUdlb1RJRkY+fSBUaGUgcmVzdWx0aW5nIE11bHRpR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbVVybHMobWFpblVybCwgb3ZlcnZpZXdVcmxzID0gW10sIG9wdGlvbnMgPSB7fSwgc2lnbmFsKSB7XG4gIGNvbnN0IG1haW5GaWxlID0gYXdhaXQgR2VvVElGRi5mcm9tU291cmNlKG1ha2VSZW1vdGVTb3VyY2UobWFpblVybCwgb3B0aW9ucyksIHNpZ25hbCk7XG4gIGNvbnN0IG92ZXJ2aWV3RmlsZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBvdmVydmlld1VybHMubWFwKCh1cmwpID0+IEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlUmVtb3RlU291cmNlKHVybCwgb3B0aW9ucykpKSxcbiAgKTtcblxuICByZXR1cm4gbmV3IE11bHRpR2VvVElGRihtYWluRmlsZSwgb3ZlcnZpZXdGaWxlcyk7XG59XG5cbi8qKlxuICogTWFpbiBjcmVhdGluZyBmdW5jdGlvbiBmb3IgR2VvVElGRiBmaWxlcy5cbiAqIEBwYXJhbSB7KEFycmF5KX0gYXJyYXkgb2YgcGl4ZWwgdmFsdWVzXG4gKiBAcmV0dXJucyB7bWV0YWRhdGF9IG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZUFycmF5QnVmZmVyKHZhbHVlcywgbWV0YWRhdGEpIHtcbiAgcmV0dXJuIHdyaXRlR2VvdGlmZih2YWx1ZXMsIG1ldGFkYXRhKTtcbn1cblxuZXhwb3J0IHsgUG9vbCB9O1xuZXhwb3J0IHsgR2VvVElGRkltYWdlIH07XG5leHBvcnQgeyBCYXNlQ2xpZW50LCBCYXNlUmVzcG9uc2UgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/geotiff.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/geotiffimage.js":
/*!**********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiffimage.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _petamoriken_float16__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @petamoriken/float16 */ \"(app-pages-browser)/./node_modules/@petamoriken/float16/src/DataView.mjs\");\n/* harmony import */ var xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xml-utils/get-attribute.js */ \"(app-pages-browser)/./node_modules/geotiff/node_modules/xml-utils/get-attribute.js\");\n/* harmony import */ var xml_utils_find_tags_by_name_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xml-utils/find-tags-by-name.js */ \"(app-pages-browser)/./node_modules/geotiff/node_modules/xml-utils/find-tags-by-name.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./globals.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rgb.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/rgb.js\");\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./compression/index.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/index.js\");\n/* harmony import */ var _resample_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resample.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/resample.js\");\n/** @module geotiffimage */\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return (0,_petamoriken_float16__WEBPACK_IMPORTED_MODULE_2__.getFloat16)(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        let getPromise;\n        if (this.planarConfiguration === 1) {\n          getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);\n        }\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n            getPromise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          }\n          const promise = getPromise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = (0,_resample_js__WEBPACK_IMPORTED_MODULE_3__.resampleInterleaved)(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = (0,_resample_js__WEBPACK_IMPORTED_MODULE_3__.resample)(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await (0,_compression_index_js__WEBPACK_IMPORTED_MODULE_4__.getDecoder)(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === _globals_js__WEBPACK_IMPORTED_MODULE_5__.ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.WhiteIsZero:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.BlackIsZero:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.YCbCr:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.WhiteIsZero:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromWhiteIsZero)(raster, max);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.BlackIsZero:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromBlackIsZero)(raster, max);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.Palette:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromPalette)(raster, fileDirectory.ColorMap);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CMYK:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromCMYK)(raster);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.YCbCr:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromYCbCr)(raster);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CIELab:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromCIELab)(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = xml_utils_find_tags_by_name_js__WEBPACK_IMPORTED_MODULE_1__(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      if (modelTransformation[1] === 0 && modelTransformation[4] === 0) {\n        return [\n          modelTransformation[0],\n          -modelTransformation[5],\n          modelTransformation[10],\n        ];\n      }\n      return [\n        Math.sqrt((modelTransformation[0] * modelTransformation[0])\n          + (modelTransformation[4] * modelTransformation[4])),\n        -Math.sqrt((modelTransformation[1] * modelTransformation[1])\n          + (modelTransformation[5] * modelTransformation[5])),\n        modelTransformation[10]];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid\n   *                                   without adjustment for ModelTransformation.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox(tilegrid = false) {\n    const height = this.getHeight();\n    const width = this.getWidth();\n\n    if (this.fileDirectory.ModelTransformation && !tilegrid) {\n      // eslint-disable-next-line no-unused-vars\n      const [a, b, c, d, e, f, g, h] = this.fileDirectory.ModelTransformation;\n\n      const corners = [\n        [0, 0],\n        [0, height],\n        [width, 0],\n        [width, height],\n      ];\n\n      const projected = corners.map(([I, J]) => [\n        d + (a * I) + (b * J),\n        h + (e * I) + (f * J),\n      ]);\n\n      const xs = projected.map((pt) => pt[0]);\n      const ys = projected.map((pt) => pt[1]);\n\n      return [\n        Math.min(...xs),\n        Math.min(...ys),\n        Math.max(...xs),\n        Math.max(...ys),\n      ];\n    } else {\n      const origin = this.getOrigin();\n      const resolution = this.getResolution();\n\n      const x1 = origin[0];\n      const y1 = origin[1];\n\n      const x2 = x1 + (resolution[0] * width);\n      const y2 = y1 + (resolution[1] * height);\n\n      return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n      ];\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GeoTIFFImage);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2dlb3RpZmZpbWFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ2tEO0FBQ0k7QUFDTTs7QUFFa0I7QUFDNEI7QUFDdEQ7QUFDVTs7QUFFOUQ7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxlQUFlO0FBQzdCLGNBQWMsZUFBZTtBQUM3QjtBQUNBLGNBQWMsZUFBZTtBQUM3QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxhQUFhO0FBQzNCO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxtQ0FBbUM7QUFDakQsY0FBYyx5Q0FBeUM7O0FBRXZEO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5QkFBeUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsMENBQTBDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnRUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLDBEQUEwRDtBQUN2RSxhQUFhLGFBQWE7QUFDMUI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMkJBQTJCOztBQUV6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSx5QkFBeUI7QUFDdEMsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsYUFBYTtBQUMxQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGVBQWU7O0FBRTNCLCtCQUErQixrQkFBa0I7QUFDakQsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4QkFBOEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0VBQWtFLFVBQVU7QUFDNUUsbUVBQW1FLFVBQVU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpRUFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isb0JBQW9CLHNEQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CLFdBQVc7QUFDM0MsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBLE1BQU07QUFDTixzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0Esd0VBQXdFLFdBQVc7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsaUVBQVU7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGVBQWU7QUFDNUIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QyxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsYUFBYTtBQUMxQjtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0Esa0JBQWtCO0FBQ2xCLGtEQUFrRCxJQUFJO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsbUVBQTBCO0FBQ3pDO0FBQ0EsaURBQWlELDJEQUFrQjtBQUNuRTtBQUNBLHdCQUF3Qiw2Q0FBNkM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG1FQUEwQjtBQUNyQyxXQUFXLG1FQUEwQjtBQUNyQyxXQUFXLG1FQUEwQjtBQUNyQztBQUNBO0FBQ0EsV0FBVyxtRUFBMEI7QUFDckM7QUFDQTtBQUNBLFdBQVcsbUVBQTBCO0FBQ3JDLFdBQVcsbUVBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1FQUEwQjtBQUNyQyxlQUFlLHdEQUFlO0FBQzlCO0FBQ0EsV0FBVyxtRUFBMEI7QUFDckMsZUFBZSx3REFBZTtBQUM5QjtBQUNBLFdBQVcsbUVBQTBCO0FBQ3JDLGVBQWUsb0RBQVc7QUFDMUI7QUFDQSxXQUFXLG1FQUEwQjtBQUNyQyxlQUFlLGlEQUFRO0FBQ3ZCO0FBQ0EsV0FBVyxtRUFBMEI7QUFDckMsZUFBZSxrREFBUztBQUN4QjtBQUNBLFdBQVcsbUVBQTBCO0FBQ3JDLGVBQWUsbURBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDZDQUE2QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsMkRBQWM7O0FBRTlCO0FBQ0EscUNBQXFDLHVEQUFZO0FBQ2pELE1BQU07QUFDTiw0Q0FBNEMsdURBQVk7QUFDeEQ7O0FBRUEsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLGVBQWUsdURBQVk7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrREFBZSxZQUFZLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvZ2VvdGlmZmltYWdlLmpzPzYzZjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBtb2R1bGUgZ2VvdGlmZmltYWdlICovXG5pbXBvcnQgeyBnZXRGbG9hdDE2IH0gZnJvbSAnQHBldGFtb3Jpa2VuL2Zsb2F0MTYnO1xuaW1wb3J0IGdldEF0dHJpYnV0ZSBmcm9tICd4bWwtdXRpbHMvZ2V0LWF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgZmluZFRhZ3NCeU5hbWUgZnJvbSAneG1sLXV0aWxzL2ZpbmQtdGFncy1ieS1uYW1lLmpzJztcblxuaW1wb3J0IHsgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMsIEV4dHJhU2FtcGxlc1ZhbHVlcyB9IGZyb20gJy4vZ2xvYmFscy5qcyc7XG5pbXBvcnQgeyBmcm9tV2hpdGVJc1plcm8sIGZyb21CbGFja0lzWmVybywgZnJvbVBhbGV0dGUsIGZyb21DTVlLLCBmcm9tWUNiQ3IsIGZyb21DSUVMYWIgfSBmcm9tICcuL3JnYi5qcyc7XG5pbXBvcnQgeyBnZXREZWNvZGVyIH0gZnJvbSAnLi9jb21wcmVzc2lvbi9pbmRleC5qcyc7XG5pbXBvcnQgeyByZXNhbXBsZSwgcmVzYW1wbGVJbnRlcmxlYXZlZCB9IGZyb20gJy4vcmVzYW1wbGUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlYWRSYXN0ZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFt3aW5kb3c9d2hvbGUgd2luZG93XSB0aGUgc3Vic2V0IHRvIHJlYWQgZGF0YSBmcm9tIGluIHBpeGVscy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW2Jib3g9d2hvbGUgaW1hZ2VdIHRoZSBzdWJzZXQgdG8gcmVhZCBkYXRhIGZyb20gaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW3NhbXBsZXM9YWxsIHNhbXBsZXNdIHRoZSBzZWxlY3Rpb24gb2Ygc2FtcGxlcyB0byByZWFkIGZyb20uIERlZmF1bHQgaXMgYWxsIHNhbXBsZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnRlcmxlYXZlPWZhbHNlXSB3aGV0aGVyIHRoZSBkYXRhIHNoYWxsIGJlIHJlYWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gb25lIHNpbmdsZSBhcnJheSBvciBzZXBhcmF0ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheXMuXG4gKiBAcHJvcGVydHkge1Bvb2x9IFtwb29sPW51bGxdIFRoZSBvcHRpb25hbCBkZWNvZGVyIHBvb2wgdG8gdXNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt3aWR0aF0gVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIG91dHB1dC4gV2hlbiB0aGUgd2lkdGggaXMgbm90IHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1lIGFzIHRoZSBpbWFnZXMsIHJlc2FtcGxpbmcgd2lsbCBiZSBwZXJmb3JtZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2hlaWdodF0gVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQuIFdoZW4gdGhlIHdpZHRoIGlzIG5vdCB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbWUgYXMgdGhlIGltYWdlcywgcmVzYW1wbGluZyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcmVzYW1wbGVNZXRob2Q9J25lYXJlc3QnXSBUaGUgZGVzaXJlZCByZXNhbXBsaW5nIG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcHJvcGVydHkge251bWJlcnxudW1iZXJbXX0gW2ZpbGxWYWx1ZV0gVGhlIHZhbHVlIHRvIHVzZSBmb3IgcGFydHMgb2YgdGhlIGltYWdlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRzaWRlIG9mIHRoZSBpbWFnZXMgZXh0ZW50LiBXaGVuIG11bHRpcGxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVzIGFyZSByZXF1ZXN0ZWQsIGFuIGFycmF5IG9mIGZpbGwgdmFsdWVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW4gYmUgcGFzc2VkLlxuICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9nZW90aWZmLmpzXCIpLlR5cGVkQXJyYXl9IFR5cGVkQXJyYXkgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9nZW90aWZmLmpzXCIpLlJlYWRSYXN0ZXJSZXN1bHR9IFJlYWRSYXN0ZXJSZXN1bHQgKi9cblxuZnVuY3Rpb24gc3VtKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIGxldCBzID0gMDtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBzICs9IGFycmF5W2ldO1xuICB9XG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBhcnJheUZvclR5cGUoZm9ybWF0LCBiaXRzUGVyU2FtcGxlLCBzaXplKSB7XG4gIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgY2FzZSAxOiAvLyB1bnNpZ25lZCBpbnRlZ2VyIGRhdGFcbiAgICAgIGlmIChiaXRzUGVyU2FtcGxlIDw9IDgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlIDw9IDE2KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPD0gMzIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShzaXplKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjogLy8gdHdvcyBjb21wbGVtZW50IHNpZ25lZCBpbnRlZ2VyIGRhdGFcbiAgICAgIGlmIChiaXRzUGVyU2FtcGxlID09PSA4KSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KHNpemUpO1xuICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlID09PSAxNikge1xuICAgICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPT09IDMyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzogLy8gZmxvYXRpbmcgcG9pbnQgZGF0YVxuICAgICAgc3dpdGNoIChiaXRzUGVyU2FtcGxlKSB7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoc2l6ZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbiAgdGhyb3cgRXJyb3IoJ1Vuc3VwcG9ydGVkIGRhdGEgZm9ybWF0L2JpdHNQZXJTYW1wbGUnKTtcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uKGZvcm1hdCwgYml0c1BlclNhbXBsZSkge1xuICBpZiAoKGZvcm1hdCA9PT0gMSB8fCBmb3JtYXQgPT09IDIpICYmIGJpdHNQZXJTYW1wbGUgPD0gMzIgJiYgYml0c1BlclNhbXBsZSAlIDggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAzICYmIChiaXRzUGVyU2FtcGxlID09PSAxNiB8fCBiaXRzUGVyU2FtcGxlID09PSAzMiB8fCBiaXRzUGVyU2FtcGxlID09PSA2NCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KGluQnVmZmVyLCBmb3JtYXQsIHBsYW5hckNvbmZpZ3VyYXRpb24sIHNhbXBsZXNQZXJQaXhlbCwgYml0c1BlclNhbXBsZSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0KSB7XG4gIC8vIGNvbnN0IGluQnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaW5CdWZmZXIpO1xuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGluQnVmZmVyKTtcbiAgY29uc3Qgb3V0U2l6ZSA9IHBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDJcbiAgICA/IHRpbGVIZWlnaHQgKiB0aWxlV2lkdGhcbiAgICA6IHRpbGVIZWlnaHQgKiB0aWxlV2lkdGggKiBzYW1wbGVzUGVyUGl4ZWw7XG4gIGNvbnN0IHNhbXBsZXNUb1RyYW5zZmVyID0gcGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMlxuICAgID8gMSA6IHNhbXBsZXNQZXJQaXhlbDtcbiAgY29uc3Qgb3V0QXJyYXkgPSBhcnJheUZvclR5cGUoZm9ybWF0LCBiaXRzUGVyU2FtcGxlLCBvdXRTaXplKTtcbiAgLy8gbGV0IHBpeGVsID0gMDtcblxuICBjb25zdCBiaXRNYXNrID0gcGFyc2VJbnQoJzEnLnJlcGVhdChiaXRzUGVyU2FtcGxlKSwgMik7XG5cbiAgaWYgKGZvcm1hdCA9PT0gMSkgeyAvLyB1bnNpZ25lZCBpbnRlZ2VyXG4gICAgLy8gdHJhbnNsYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL09TR2VvL2dkYWwvYmxvYi9tYXN0ZXIvZ2RhbC9mcm10cy9ndGlmZi9nZW90aWZmLmNwcCNMNzMzN1xuICAgIGxldCBwaXhlbEJpdFNraXA7XG4gICAgLy8gbGV0IHNhbXBsZUJpdE9mZnNldCA9IDA7XG4gICAgaWYgKHBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDEpIHtcbiAgICAgIHBpeGVsQml0U2tpcCA9IHNhbXBsZXNQZXJQaXhlbCAqIGJpdHNQZXJTYW1wbGU7XG4gICAgICAvLyBzYW1wbGVCaXRPZmZzZXQgPSAoc2FtcGxlc1BlclBpeGVsIC0gMSkgKiBiaXRzUGVyU2FtcGxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwaXhlbEJpdFNraXAgPSBiaXRzUGVyU2FtcGxlO1xuICAgIH1cblxuICAgIC8vIEJpdHMgcGVyIGxpbmUgcm91bmRzIHVwIHRvIG5leHQgYnl0ZSBib3VuZGFyeS5cbiAgICBsZXQgYml0c1BlckxpbmUgPSB0aWxlV2lkdGggKiBwaXhlbEJpdFNraXA7XG4gICAgaWYgKChiaXRzUGVyTGluZSAmIDcpICE9PSAwKSB7XG4gICAgICBiaXRzUGVyTGluZSA9IChiaXRzUGVyTGluZSArIDcpICYgKH43KTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRpbGVIZWlnaHQ7ICsreSkge1xuICAgICAgY29uc3QgbGluZUJpdE9mZnNldCA9IHkgKiBiaXRzUGVyTGluZTtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGlsZVdpZHRoOyArK3gpIHtcbiAgICAgICAgY29uc3QgcGl4ZWxCaXRPZmZzZXQgPSBsaW5lQml0T2Zmc2V0ICsgKHggKiBzYW1wbGVzVG9UcmFuc2ZlciAqIGJpdHNQZXJTYW1wbGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXNUb1RyYW5zZmVyOyArK2kpIHtcbiAgICAgICAgICBjb25zdCBiaXRPZmZzZXQgPSBwaXhlbEJpdE9mZnNldCArIChpICogYml0c1BlclNhbXBsZSk7XG4gICAgICAgICAgY29uc3Qgb3V0SW5kZXggPSAoKCh5ICogdGlsZVdpZHRoKSArIHgpICogc2FtcGxlc1RvVHJhbnNmZXIpICsgaTtcblxuICAgICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBNYXRoLmZsb29yKGJpdE9mZnNldCAvIDgpO1xuICAgICAgICAgIGNvbnN0IGlubmVyQml0T2Zmc2V0ID0gYml0T2Zmc2V0ICUgODtcbiAgICAgICAgICBpZiAoaW5uZXJCaXRPZmZzZXQgKyBiaXRzUGVyU2FtcGxlIDw9IDgpIHtcbiAgICAgICAgICAgIG91dEFycmF5W291dEluZGV4XSA9ICh2aWV3LmdldFVpbnQ4KGJ5dGVPZmZzZXQpID4+ICg4IC0gYml0c1BlclNhbXBsZSkgLSBpbm5lckJpdE9mZnNldCkgJiBiaXRNYXNrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5uZXJCaXRPZmZzZXQgKyBiaXRzUGVyU2FtcGxlIDw9IDE2KSB7XG4gICAgICAgICAgICBvdXRBcnJheVtvdXRJbmRleF0gPSAodmlldy5nZXRVaW50MTYoYnl0ZU9mZnNldCkgPj4gKDE2IC0gYml0c1BlclNhbXBsZSkgLSBpbm5lckJpdE9mZnNldCkgJiBiaXRNYXNrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5uZXJCaXRPZmZzZXQgKyBiaXRzUGVyU2FtcGxlIDw9IDI0KSB7XG4gICAgICAgICAgICBjb25zdCByYXcgPSAodmlldy5nZXRVaW50MTYoYnl0ZU9mZnNldCkgPDwgOCkgfCAodmlldy5nZXRVaW50OChieXRlT2Zmc2V0ICsgMikpO1xuICAgICAgICAgICAgb3V0QXJyYXlbb3V0SW5kZXhdID0gKHJhdyA+PiAoMjQgLSBiaXRzUGVyU2FtcGxlKSAtIGlubmVyQml0T2Zmc2V0KSAmIGJpdE1hc2s7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dEFycmF5W291dEluZGV4XSA9ICh2aWV3LmdldFVpbnQzMihieXRlT2Zmc2V0KSA+PiAoMzIgLSBiaXRzUGVyU2FtcGxlKSAtIGlubmVyQml0T2Zmc2V0KSAmIGJpdE1hc2s7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbGV0IG91dFdvcmQgPSAwO1xuICAgICAgICAgIC8vIGZvciAobGV0IGJpdCA9IDA7IGJpdCA8IGJpdHNQZXJTYW1wbGU7ICsrYml0KSB7XG4gICAgICAgICAgLy8gICBpZiAoaW5CeXRlQXJyYXlbYml0T2Zmc2V0ID4+IDNdXG4gICAgICAgICAgLy8gICAgICYgKDB4ODAgPj4gKGJpdE9mZnNldCAmIDcpKSkge1xuICAgICAgICAgIC8vICAgICBvdXRXb3JkIHw9ICgxIDw8IChiaXRzUGVyU2FtcGxlIC0gMSAtIGJpdCkpO1xuICAgICAgICAgIC8vICAgfVxuICAgICAgICAgIC8vICAgKytiaXRPZmZzZXQ7XG4gICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgLy8gb3V0QXJyYXlbb3V0SW5kZXhdID0gb3V0V29yZDtcbiAgICAgICAgICAvLyBvdXRBcnJheVtwaXhlbF0gPSBvdXRXb3JkO1xuICAgICAgICAgIC8vIHBpeGVsICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYml0T2Zmc2V0ID0gYml0T2Zmc2V0ICsgcGl4ZWxCaXRTa2lwIC0gYml0c1BlclNhbXBsZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAzKSB7IC8vIGZsb2F0aW5nIHBvaW50XG4gICAgLy8gRmxvYXQxNiBpcyBoYW5kbGVkIGVsc2V3aGVyZVxuICAgIC8vIG5vcm1hbGl6ZSAxNi8yNCBiaXQgZmxvYXRzIHRvIDMyIGJpdCBmbG9hdHMgaW4gdGhlIGFycmF5XG4gICAgLy8gY29uc29sZS50aW1lKCk7XG4gICAgLy8gaWYgKGJpdHNQZXJTYW1wbGUgPT09IDE2KSB7XG4gICAgLy8gICBmb3IgKGxldCBieXRlID0gMCwgb3V0SW5kZXggPSAwOyBieXRlIDwgaW5CdWZmZXIuYnl0ZUxlbmd0aDsgYnl0ZSArPSAyLCArK291dEluZGV4KSB7XG4gICAgLy8gICAgIG91dEFycmF5W291dEluZGV4XSA9IGdldEZsb2F0MTYodmlldywgYnl0ZSk7XG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIC8vIGNvbnNvbGUudGltZUVuZCgpXG4gIH1cblxuICByZXR1cm4gb3V0QXJyYXkuYnVmZmVyO1xufVxuXG4vKipcbiAqIEdlb1RJRkYgc3ViLWZpbGUgaW1hZ2UuXG4gKi9cbmNsYXNzIEdlb1RJRkZJbWFnZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IGZpbGVEaXJlY3RvcnkgVGhlIHBhcnNlZCBmaWxlIGRpcmVjdG9yeVxuICAgKiBAcGFyYW0ge09iamVjdH0gZ2VvS2V5cyBUaGUgcGFyc2VkIGdlby1rZXlzXG4gICAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFWaWV3IFRoZSBEYXRhVmlldyBmb3IgdGhlIHVuZGVybHlpbmcgZmlsZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsaXR0bGVFbmRpYW4gV2hldGhlciB0aGUgZmlsZSBpcyBlbmNvZGVkIGluIGxpdHRsZSBvciBiaWcgZW5kaWFuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FjaGUgV2hldGhlciBvciBub3QgZGVjb2RlZCB0aWxlcyBzaGFsbCBiZSBjYWNoZWRcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vc291cmNlL2Jhc2Vzb3VyY2UnKS5CYXNlU291cmNlfSBzb3VyY2UgVGhlIGRhdGFzb3VyY2UgdG8gcmVhZCBmcm9tXG4gICAqL1xuICBjb25zdHJ1Y3RvcihmaWxlRGlyZWN0b3J5LCBnZW9LZXlzLCBkYXRhVmlldywgbGl0dGxlRW5kaWFuLCBjYWNoZSwgc291cmNlKSB7XG4gICAgdGhpcy5maWxlRGlyZWN0b3J5ID0gZmlsZURpcmVjdG9yeTtcbiAgICB0aGlzLmdlb0tleXMgPSBnZW9LZXlzO1xuICAgIHRoaXMuZGF0YVZpZXcgPSBkYXRhVmlldztcbiAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IGxpdHRsZUVuZGlhbjtcbiAgICB0aGlzLnRpbGVzID0gY2FjaGUgPyB7fSA6IG51bGw7XG4gICAgdGhpcy5pc1RpbGVkID0gIWZpbGVEaXJlY3RvcnkuU3RyaXBPZmZzZXRzO1xuICAgIGNvbnN0IHBsYW5hckNvbmZpZ3VyYXRpb24gPSBmaWxlRGlyZWN0b3J5LlBsYW5hckNvbmZpZ3VyYXRpb247XG4gICAgdGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID0gKHR5cGVvZiBwbGFuYXJDb25maWd1cmF0aW9uID09PSAndW5kZWZpbmVkJykgPyAxIDogcGxhbmFyQ29uZmlndXJhdGlvbjtcbiAgICBpZiAodGhpcy5wbGFuYXJDb25maWd1cmF0aW9uICE9PSAxICYmIHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBsYW5hciBjb25maWd1cmF0aW9uLicpO1xuICAgIH1cblxuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFzc29jaWF0ZWQgcGFyc2VkIGZpbGUgZGlyZWN0b3J5LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcGFyc2VkIGZpbGUgZGlyZWN0b3J5XG4gICAqL1xuICBnZXRGaWxlRGlyZWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3Rvcnk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXNzb2NpYXRlZCBwYXJzZWQgZ2VvIGtleXMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBwYXJzZWQgZ2VvIGtleXNcbiAgICovXG4gIGdldEdlb0tleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvS2V5cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgaW1hZ2UuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgaW1hZ2VcbiAgICovXG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3RvcnkuSW1hZ2VXaWR0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIGltYWdlLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZVxuICAgKi9cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3RvcnkuSW1hZ2VMZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHNhbXBsZXMgcGVyIHBpeGVsLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgbnVtYmVyIG9mIHNhbXBsZXMgcGVyIHBpeGVsXG4gICAqL1xuICBnZXRTYW1wbGVzUGVyUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLmZpbGVEaXJlY3RvcnkuU2FtcGxlc1BlclBpeGVsICE9PSAndW5kZWZpbmVkJ1xuICAgICAgPyB0aGlzLmZpbGVEaXJlY3RvcnkuU2FtcGxlc1BlclBpeGVsIDogMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiBlYWNoIHRpbGUuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSB3aWR0aCBvZiBlYWNoIHRpbGVcbiAgICovXG4gIGdldFRpbGVXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1RpbGVkID8gdGhpcy5maWxlRGlyZWN0b3J5LlRpbGVXaWR0aCA6IHRoaXMuZ2V0V2lkdGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgZWFjaCB0aWxlLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgaGVpZ2h0IG9mIGVhY2ggdGlsZVxuICAgKi9cbiAgZ2V0VGlsZUhlaWdodCgpIHtcbiAgICBpZiAodGhpcy5pc1RpbGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWxlRGlyZWN0b3J5LlRpbGVMZW5ndGg7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5maWxlRGlyZWN0b3J5LlJvd3NQZXJTdHJpcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmZpbGVEaXJlY3RvcnkuUm93c1BlclN0cmlwLCB0aGlzLmdldEhlaWdodCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0SGVpZ2h0KCk7XG4gIH1cblxuICBnZXRCbG9ja1dpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmdldFRpbGVXaWR0aCgpO1xuICB9XG5cbiAgZ2V0QmxvY2tIZWlnaHQoeSkge1xuICAgIGlmICh0aGlzLmlzVGlsZWQgfHwgKHkgKyAxKSAqIHRoaXMuZ2V0VGlsZUhlaWdodCgpIDw9IHRoaXMuZ2V0SGVpZ2h0KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRpbGVIZWlnaHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SGVpZ2h0KCkgLSAoeSAqIHRoaXMuZ2V0VGlsZUhlaWdodCgpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGZvciBlYWNoIHBpeGVsIGFjcm9zcyBhbGwgc2FtcGxlcy4gT25seSBmdWxsXG4gICAqIGJ5dGVzIGFyZSBzdXBwb3J0ZWQsIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gd2hlbiB0aGlzIGlzIG5vdCB0aGUgY2FzZS5cbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIGJ5dGVzIHBlciBwaXhlbFxuICAgKi9cbiAgZ2V0Qnl0ZXNQZXJQaXhlbCgpIHtcbiAgICBsZXQgYnl0ZXMgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzICs9IHRoaXMuZ2V0U2FtcGxlQnl0ZVNpemUoaSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbiAgfVxuXG4gIGdldFNhbXBsZUJ5dGVTaXplKGkpIHtcbiAgICBpZiAoaSA+PSB0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBTYW1wbGUgaW5kZXggJHtpfSBpcyBvdXQgb2YgcmFuZ2UuYCk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGVbaV0gLyA4KTtcbiAgfVxuXG4gIGdldFJlYWRlckZvclNhbXBsZShzYW1wbGVJbmRleCkge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVGb3JtYXRcbiAgICAgID8gdGhpcy5maWxlRGlyZWN0b3J5LlNhbXBsZUZvcm1hdFtzYW1wbGVJbmRleF0gOiAxO1xuICAgIGNvbnN0IGJpdHNQZXJTYW1wbGUgPSB0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZVtzYW1wbGVJbmRleF07XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgMTogLy8gdW5zaWduZWQgaW50ZWdlciBkYXRhXG4gICAgICAgIGlmIChiaXRzUGVyU2FtcGxlIDw9IDgpIHtcbiAgICAgICAgICByZXR1cm4gRGF0YVZpZXcucHJvdG90eXBlLmdldFVpbnQ4O1xuICAgICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPD0gMTYpIHtcbiAgICAgICAgICByZXR1cm4gRGF0YVZpZXcucHJvdG90eXBlLmdldFVpbnQxNjtcbiAgICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlIDw9IDMyKSB7XG4gICAgICAgICAgcmV0dXJuIERhdGFWaWV3LnByb3RvdHlwZS5nZXRVaW50MzI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6IC8vIHR3b3MgY29tcGxlbWVudCBzaWduZWQgaW50ZWdlciBkYXRhXG4gICAgICAgIGlmIChiaXRzUGVyU2FtcGxlIDw9IDgpIHtcbiAgICAgICAgICByZXR1cm4gRGF0YVZpZXcucHJvdG90eXBlLmdldEludDg7XG4gICAgICAgIH0gZWxzZSBpZiAoYml0c1BlclNhbXBsZSA8PSAxNikge1xuICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0SW50MTY7XG4gICAgICAgIH0gZWxzZSBpZiAoYml0c1BlclNhbXBsZSA8PSAzMikge1xuICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0SW50MzI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHN3aXRjaCAoYml0c1BlclNhbXBsZSkge1xuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRGbG9hdDE2KHRoaXMsIG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0RmxvYXQzMjtcbiAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgcmV0dXJuIERhdGFWaWV3LnByb3RvdHlwZS5nZXRGbG9hdDY0O1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgZGF0YSBmb3JtYXQvYml0c1BlclNhbXBsZScpO1xuICB9XG5cbiAgZ2V0U2FtcGxlRm9ybWF0KHNhbXBsZUluZGV4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3RvcnkuU2FtcGxlRm9ybWF0XG4gICAgICA/IHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVGb3JtYXRbc2FtcGxlSW5kZXhdIDogMTtcbiAgfVxuXG4gIGdldEJpdHNQZXJTYW1wbGUoc2FtcGxlSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlW3NhbXBsZUluZGV4XTtcbiAgfVxuXG4gIGdldEFycmF5Rm9yU2FtcGxlKHNhbXBsZUluZGV4LCBzaXplKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5nZXRTYW1wbGVGb3JtYXQoc2FtcGxlSW5kZXgpO1xuICAgIGNvbnN0IGJpdHNQZXJTYW1wbGUgPSB0aGlzLmdldEJpdHNQZXJTYW1wbGUoc2FtcGxlSW5kZXgpO1xuICAgIHJldHVybiBhcnJheUZvclR5cGUoZm9ybWF0LCBiaXRzUGVyU2FtcGxlLCBzaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZWNvZGVkIHN0cmlwIG9yIHRpbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IHRoZSBzdHJpcCBvciB0aWxlIHgtb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5IHRoZSB0aWxlIHktb2Zmc2V0ICgwIGZvciBzdHJpcHBlZCBpbWFnZXMpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzYW1wbGUgdGhlIHNhbXBsZSB0byBnZXQgZm9yIHNlcGFyYXRlZCBzYW1wbGVzXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW90aWZmXCIpLlBvb2x8aW1wb3J0KFwiLi9nZW90aWZmXCIpLkJhc2VEZWNvZGVyfSBwb29sT3JEZWNvZGVyIHRoZSBkZWNvZGVyIG9yIGRlY29kZXIgcG9vbFxuICAgKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBbc2lnbmFsXSBBbiBBYm9ydFNpZ25hbCB0aGF0IG1heSBiZSBzaWduYWxsZWQgaWYgdGhlIHJlcXVlc3QgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXlCdWZmZXI+fVxuICAgKi9cbiAgYXN5bmMgZ2V0VGlsZU9yU3RyaXAoeCwgeSwgc2FtcGxlLCBwb29sT3JEZWNvZGVyLCBzaWduYWwpIHtcbiAgICBjb25zdCBudW1UaWxlc1BlclJvdyA9IE1hdGguY2VpbCh0aGlzLmdldFdpZHRoKCkgLyB0aGlzLmdldFRpbGVXaWR0aCgpKTtcbiAgICBjb25zdCBudW1UaWxlc1BlckNvbCA9IE1hdGguY2VpbCh0aGlzLmdldEhlaWdodCgpIC8gdGhpcy5nZXRUaWxlSGVpZ2h0KCkpO1xuICAgIGxldCBpbmRleDtcbiAgICBjb25zdCB7IHRpbGVzIH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDEpIHtcbiAgICAgIGluZGV4ID0gKHkgKiBudW1UaWxlc1BlclJvdykgKyB4O1xuICAgIH0gZWxzZSBpZiAodGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID09PSAyKSB7XG4gICAgICBpbmRleCA9IChzYW1wbGUgKiBudW1UaWxlc1BlclJvdyAqIG51bVRpbGVzUGVyQ29sKSArICh5ICogbnVtVGlsZXNQZXJSb3cpICsgeDtcbiAgICB9XG5cbiAgICBsZXQgb2Zmc2V0O1xuICAgIGxldCBieXRlQ291bnQ7XG4gICAgaWYgKHRoaXMuaXNUaWxlZCkge1xuICAgICAgb2Zmc2V0ID0gdGhpcy5maWxlRGlyZWN0b3J5LlRpbGVPZmZzZXRzW2luZGV4XTtcbiAgICAgIGJ5dGVDb3VudCA9IHRoaXMuZmlsZURpcmVjdG9yeS5UaWxlQnl0ZUNvdW50c1tpbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IHRoaXMuZmlsZURpcmVjdG9yeS5TdHJpcE9mZnNldHNbaW5kZXhdO1xuICAgICAgYnl0ZUNvdW50ID0gdGhpcy5maWxlRGlyZWN0b3J5LlN0cmlwQnl0ZUNvdW50c1tpbmRleF07XG4gICAgfVxuICAgIGNvbnN0IHNsaWNlID0gKGF3YWl0IHRoaXMuc291cmNlLmZldGNoKFt7IG9mZnNldCwgbGVuZ3RoOiBieXRlQ291bnQgfV0sIHNpZ25hbCkpWzBdO1xuXG4gICAgbGV0IHJlcXVlc3Q7XG4gICAgaWYgKHRpbGVzID09PSBudWxsIHx8ICF0aWxlc1tpbmRleF0pIHtcbiAgICAvLyByZXNvbHZlIGVhY2ggcmVxdWVzdCBieSBwb3RlbnRpYWxseSBhcHBseWluZyBhcnJheSBub3JtYWxpemF0aW9uXG4gICAgICByZXF1ZXN0ID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCBwb29sT3JEZWNvZGVyLmRlY29kZSh0aGlzLmZpbGVEaXJlY3RvcnksIHNsaWNlKTtcbiAgICAgICAgY29uc3Qgc2FtcGxlRm9ybWF0ID0gdGhpcy5nZXRTYW1wbGVGb3JtYXQoKTtcbiAgICAgICAgY29uc3QgYml0c1BlclNhbXBsZSA9IHRoaXMuZ2V0Qml0c1BlclNhbXBsZSgpO1xuICAgICAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKHNhbXBsZUZvcm1hdCwgYml0c1BlclNhbXBsZSkpIHtcbiAgICAgICAgICBkYXRhID0gbm9ybWFsaXplQXJyYXkoXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgc2FtcGxlRm9ybWF0LFxuICAgICAgICAgICAgdGhpcy5wbGFuYXJDb25maWd1cmF0aW9uLFxuICAgICAgICAgICAgdGhpcy5nZXRTYW1wbGVzUGVyUGl4ZWwoKSxcbiAgICAgICAgICAgIGJpdHNQZXJTYW1wbGUsXG4gICAgICAgICAgICB0aGlzLmdldFRpbGVXaWR0aCgpLFxuICAgICAgICAgICAgdGhpcy5nZXRCbG9ja0hlaWdodCh5KSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSkoKTtcblxuICAgICAgLy8gc2V0IHRoZSBjYWNoZVxuICAgICAgaWYgKHRpbGVzICE9PSBudWxsKSB7XG4gICAgICAgIHRpbGVzW2luZGV4XSA9IHJlcXVlc3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdldCBmcm9tIHRoZSBjYWNoZVxuICAgICAgcmVxdWVzdCA9IHRpbGVzW2luZGV4XTtcbiAgICB9XG5cbiAgICAvLyBjYWNoZSB0aGUgdGlsZSByZXF1ZXN0XG4gICAgcmV0dXJuIHsgeCwgeSwgc2FtcGxlLCBkYXRhOiBhd2FpdCByZXF1ZXN0IH07XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgcmVhZCBmdW5jdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gaW1hZ2VXaW5kb3cgVGhlIGltYWdlIHdpbmRvdyBpbiBwaXhlbCBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzYW1wbGVzIFRoZSBzZWxlY3RlZCBzYW1wbGVzICgwLWJhc2VkIGluZGljZXMpXG4gICAqIEBwYXJhbSB7VHlwZWRBcnJheXxUeXBlZEFycmF5W119IHZhbHVlQXJyYXlzIFRoZSBhcnJheShzKSB0byB3cml0ZSBpbnRvXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW50ZXJsZWF2ZSBXaGV0aGVyIG9yIG5vdCB0byB3cml0ZSBpbiBhbiBpbnRlcmxlYXZlZCBtYW5uZXJcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb3RpZmZcIikuUG9vbHxBYnN0cmFjdERlY29kZXJ9IHBvb2xPckRlY29kZXIgdGhlIGRlY29kZXIgb3IgZGVjb2RlciBwb29sXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCB0aGUgd2lkdGggb2Ygd2luZG93IHRvIGJlIHJlYWQgaW50b1xuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IHRoZSBoZWlnaHQgb2Ygd2luZG93IHRvIGJlIHJlYWQgaW50b1xuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzYW1wbGVNZXRob2QgdGhlIHJlc2FtcGxpbmcgbWV0aG9kIHRvIGJlIHVzZWQgd2hlbiBpbnRlcnBvbGF0aW5nXG4gICAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRSYXN0ZXJSZXN1bHQ+fVxuICAgKi9cbiAgYXN5bmMgX3JlYWRSYXN0ZXIoaW1hZ2VXaW5kb3csIHNhbXBsZXMsIHZhbHVlQXJyYXlzLCBpbnRlcmxlYXZlLCBwb29sT3JEZWNvZGVyLCB3aWR0aCxcbiAgICBoZWlnaHQsIHJlc2FtcGxlTWV0aG9kLCBzaWduYWwpIHtcbiAgICBjb25zdCB0aWxlV2lkdGggPSB0aGlzLmdldFRpbGVXaWR0aCgpO1xuICAgIGNvbnN0IHRpbGVIZWlnaHQgPSB0aGlzLmdldFRpbGVIZWlnaHQoKTtcbiAgICBjb25zdCBpbWFnZVdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgIGNvbnN0IGltYWdlSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcblxuICAgIGNvbnN0IG1pblhUaWxlID0gTWF0aC5tYXgoTWF0aC5mbG9vcihpbWFnZVdpbmRvd1swXSAvIHRpbGVXaWR0aCksIDApO1xuICAgIGNvbnN0IG1heFhUaWxlID0gTWF0aC5taW4oXG4gICAgICBNYXRoLmNlaWwoaW1hZ2VXaW5kb3dbMl0gLyB0aWxlV2lkdGgpLFxuICAgICAgTWF0aC5jZWlsKGltYWdlV2lkdGggLyB0aWxlV2lkdGgpLFxuICAgICk7XG4gICAgY29uc3QgbWluWVRpbGUgPSBNYXRoLm1heChNYXRoLmZsb29yKGltYWdlV2luZG93WzFdIC8gdGlsZUhlaWdodCksIDApO1xuICAgIGNvbnN0IG1heFlUaWxlID0gTWF0aC5taW4oXG4gICAgICBNYXRoLmNlaWwoaW1hZ2VXaW5kb3dbM10gLyB0aWxlSGVpZ2h0KSxcbiAgICAgIE1hdGguY2VpbChpbWFnZUhlaWdodCAvIHRpbGVIZWlnaHQpLFxuICAgICk7XG4gICAgY29uc3Qgd2luZG93V2lkdGggPSBpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdO1xuXG4gICAgbGV0IGJ5dGVzUGVyUGl4ZWwgPSB0aGlzLmdldEJ5dGVzUGVyUGl4ZWwoKTtcblxuICAgIGNvbnN0IHNyY1NhbXBsZU9mZnNldHMgPSBbXTtcbiAgICBjb25zdCBzYW1wbGVSZWFkZXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID09PSAxKSB7XG4gICAgICAgIHNyY1NhbXBsZU9mZnNldHMucHVzaChzdW0odGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGUsIDAsIHNhbXBsZXNbaV0pIC8gOCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcmNTYW1wbGVPZmZzZXRzLnB1c2goMCk7XG4gICAgICB9XG4gICAgICBzYW1wbGVSZWFkZXJzLnB1c2godGhpcy5nZXRSZWFkZXJGb3JTYW1wbGUoc2FtcGxlc1tpXSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgY29uc3QgeyBsaXR0bGVFbmRpYW4gfSA9IHRoaXM7XG5cbiAgICBmb3IgKGxldCB5VGlsZSA9IG1pbllUaWxlOyB5VGlsZSA8IG1heFlUaWxlOyArK3lUaWxlKSB7XG4gICAgICBmb3IgKGxldCB4VGlsZSA9IG1pblhUaWxlOyB4VGlsZSA8IG1heFhUaWxlOyArK3hUaWxlKSB7XG4gICAgICAgIGxldCBnZXRQcm9taXNlO1xuICAgICAgICBpZiAodGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID09PSAxKSB7XG4gICAgICAgICAgZ2V0UHJvbWlzZSA9IHRoaXMuZ2V0VGlsZU9yU3RyaXAoeFRpbGUsIHlUaWxlLCAwLCBwb29sT3JEZWNvZGVyLCBzaWduYWwpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHNhbXBsZUluZGV4ID0gMDsgc2FtcGxlSW5kZXggPCBzYW1wbGVzLmxlbmd0aDsgKytzYW1wbGVJbmRleCkge1xuICAgICAgICAgIGNvbnN0IHNpID0gc2FtcGxlSW5kZXg7XG4gICAgICAgICAgY29uc3Qgc2FtcGxlID0gc2FtcGxlc1tzYW1wbGVJbmRleF07XG4gICAgICAgICAgaWYgKHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMikge1xuICAgICAgICAgICAgYnl0ZXNQZXJQaXhlbCA9IHRoaXMuZ2V0U2FtcGxlQnl0ZVNpemUoc2FtcGxlKTtcbiAgICAgICAgICAgIGdldFByb21pc2UgPSB0aGlzLmdldFRpbGVPclN0cmlwKHhUaWxlLCB5VGlsZSwgc2FtcGxlLCBwb29sT3JEZWNvZGVyLCBzaWduYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwcm9taXNlID0gZ2V0UHJvbWlzZS50aGVuKCh0aWxlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSB0aWxlLmRhdGE7XG4gICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tIZWlnaHQgPSB0aGlzLmdldEJsb2NrSGVpZ2h0KHRpbGUueSk7XG4gICAgICAgICAgICBjb25zdCBmaXJzdExpbmUgPSB0aWxlLnkgKiB0aWxlSGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgZmlyc3RDb2wgPSB0aWxlLnggKiB0aWxlV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBsYXN0TGluZSA9IGZpcnN0TGluZSArIGJsb2NrSGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgbGFzdENvbCA9ICh0aWxlLnggKyAxKSAqIHRpbGVXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHNhbXBsZVJlYWRlcnNbc2ldO1xuXG4gICAgICAgICAgICBjb25zdCB5bWF4ID0gTWF0aC5taW4oYmxvY2tIZWlnaHQsIGJsb2NrSGVpZ2h0IC0gKGxhc3RMaW5lIC0gaW1hZ2VXaW5kb3dbM10pLCBpbWFnZUhlaWdodCAtIGZpcnN0TGluZSk7XG4gICAgICAgICAgICBjb25zdCB4bWF4ID0gTWF0aC5taW4odGlsZVdpZHRoLCB0aWxlV2lkdGggLSAobGFzdENvbCAtIGltYWdlV2luZG93WzJdKSwgaW1hZ2VXaWR0aCAtIGZpcnN0Q29sKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IE1hdGgubWF4KDAsIGltYWdlV2luZG93WzFdIC0gZmlyc3RMaW5lKTsgeSA8IHltYXg7ICsreSkge1xuICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gTWF0aC5tYXgoMCwgaW1hZ2VXaW5kb3dbMF0gLSBmaXJzdENvbCk7IHggPCB4bWF4OyArK3gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaXhlbE9mZnNldCA9ICgoeSAqIHRpbGVXaWR0aCkgKyB4KSAqIGJ5dGVzUGVyUGl4ZWw7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZWFkZXIuY2FsbChcbiAgICAgICAgICAgICAgICAgIGRhdGFWaWV3LCBwaXhlbE9mZnNldCArIHNyY1NhbXBsZU9mZnNldHNbc2ldLCBsaXR0bGVFbmRpYW4sXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBsZXQgd2luZG93Q29vcmRpbmF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJsZWF2ZSkge1xuICAgICAgICAgICAgICAgICAgd2luZG93Q29vcmRpbmF0ZSA9ICgoeSArIGZpcnN0TGluZSAtIGltYWdlV2luZG93WzFdKSAqIHdpbmRvd1dpZHRoICogc2FtcGxlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICsgKCh4ICsgZmlyc3RDb2wgLSBpbWFnZVdpbmRvd1swXSkgKiBzYW1wbGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgKyBzaTtcbiAgICAgICAgICAgICAgICAgIHZhbHVlQXJyYXlzW3dpbmRvd0Nvb3JkaW5hdGVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHdpbmRvd0Nvb3JkaW5hdGUgPSAoXG4gICAgICAgICAgICAgICAgICAgICh5ICsgZmlyc3RMaW5lIC0gaW1hZ2VXaW5kb3dbMV0pICogd2luZG93V2lkdGhcbiAgICAgICAgICAgICAgICAgICkgKyB4ICsgZmlyc3RDb2wgLSBpbWFnZVdpbmRvd1swXTtcbiAgICAgICAgICAgICAgICAgIHZhbHVlQXJyYXlzW3NpXVt3aW5kb3dDb29yZGluYXRlXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgaWYgKCh3aWR0aCAmJiAoaW1hZ2VXaW5kb3dbMl0gLSBpbWFnZVdpbmRvd1swXSkgIT09IHdpZHRoKVxuICAgICAgICB8fCAoaGVpZ2h0ICYmIChpbWFnZVdpbmRvd1szXSAtIGltYWdlV2luZG93WzFdKSAhPT0gaGVpZ2h0KSkge1xuICAgICAgbGV0IHJlc2FtcGxlZDtcbiAgICAgIGlmIChpbnRlcmxlYXZlKSB7XG4gICAgICAgIHJlc2FtcGxlZCA9IHJlc2FtcGxlSW50ZXJsZWF2ZWQoXG4gICAgICAgICAgdmFsdWVBcnJheXMsXG4gICAgICAgICAgaW1hZ2VXaW5kb3dbMl0gLSBpbWFnZVdpbmRvd1swXSxcbiAgICAgICAgICBpbWFnZVdpbmRvd1szXSAtIGltYWdlV2luZG93WzFdLFxuICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgc2FtcGxlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzYW1wbGVNZXRob2QsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNhbXBsZWQgPSByZXNhbXBsZShcbiAgICAgICAgICB2YWx1ZUFycmF5cyxcbiAgICAgICAgICBpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdLFxuICAgICAgICAgIGltYWdlV2luZG93WzNdIC0gaW1hZ2VXaW5kb3dbMV0sXG4gICAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICByZXNhbXBsZU1ldGhvZCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlc2FtcGxlZC53aWR0aCA9IHdpZHRoO1xuICAgICAgcmVzYW1wbGVkLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHJldHVybiByZXNhbXBsZWQ7XG4gICAgfVxuXG4gICAgdmFsdWVBcnJheXMud2lkdGggPSB3aWR0aCB8fCBpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdO1xuICAgIHZhbHVlQXJyYXlzLmhlaWdodCA9IGhlaWdodCB8fCBpbWFnZVdpbmRvd1szXSAtIGltYWdlV2luZG93WzFdO1xuXG4gICAgcmV0dXJuIHZhbHVlQXJyYXlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHJhc3RlciBkYXRhIGZyb20gdGhlIGltYWdlLiBUaGlzIGZ1bmN0aW9uIHJlYWRzIGFsbCBzZWxlY3RlZCBzYW1wbGVzXG4gICAqIGludG8gc2VwYXJhdGUgYXJyYXlzIG9mIHRoZSBjb3JyZWN0IHR5cGUgZm9yIHRoYXQgc2FtcGxlIG9yIGludG8gYSBzaW5nbGVcbiAgICogY29tYmluZWQgYXJyYXkgd2hlbiBgaW50ZXJsZWF2ZWAgaXMgc2V0LiBXaGVuIHByb3ZpZGVkLCBvbmx5IGEgc3Vic2V0XG4gICAqIG9mIHRoZSByYXN0ZXIgaXMgcmVhZCBmb3IgZWFjaCBzYW1wbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhZFJhc3Rlck9wdGlvbnN9IFtvcHRpb25zPXt9XSBvcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRSYXN0ZXJSZXN1bHQ+fSB0aGUgZGVjb2RlZCBhcnJheXMgYXMgYSBwcm9taXNlXG4gICAqL1xuICBhc3luYyByZWFkUmFzdGVycyh7XG4gICAgd2luZG93OiB3bmQsIHNhbXBsZXMgPSBbXSwgaW50ZXJsZWF2ZSwgcG9vbCA9IG51bGwsXG4gICAgd2lkdGgsIGhlaWdodCwgcmVzYW1wbGVNZXRob2QsIGZpbGxWYWx1ZSwgc2lnbmFsLFxuICB9ID0ge30pIHtcbiAgICBjb25zdCBpbWFnZVdpbmRvdyA9IHduZCB8fCBbMCwgMCwgdGhpcy5nZXRXaWR0aCgpLCB0aGlzLmdldEhlaWdodCgpXTtcblxuICAgIC8vIGNoZWNrIHBhcmFtZXRlcnNcbiAgICBpZiAoaW1hZ2VXaW5kb3dbMF0gPiBpbWFnZVdpbmRvd1syXSB8fCBpbWFnZVdpbmRvd1sxXSA+IGltYWdlV2luZG93WzNdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic2V0cycpO1xuICAgIH1cblxuICAgIGNvbnN0IGltYWdlV2luZG93V2lkdGggPSBpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdO1xuICAgIGNvbnN0IGltYWdlV2luZG93SGVpZ2h0ID0gaW1hZ2VXaW5kb3dbM10gLSBpbWFnZVdpbmRvd1sxXTtcbiAgICBjb25zdCBudW1QaXhlbHMgPSBpbWFnZVdpbmRvd1dpZHRoICogaW1hZ2VXaW5kb3dIZWlnaHQ7XG4gICAgY29uc3Qgc2FtcGxlc1BlclBpeGVsID0gdGhpcy5nZXRTYW1wbGVzUGVyUGl4ZWwoKTtcblxuICAgIGlmICghc2FtcGxlcyB8fCAhc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlc1BlclBpeGVsOyArK2kpIHtcbiAgICAgICAgc2FtcGxlcy5wdXNoKGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHNhbXBsZXNbaV0gPj0gc2FtcGxlc1BlclBpeGVsKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHNhbXBsZSBpbmRleCAnJHtzYW1wbGVzW2ldfScuYCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB2YWx1ZUFycmF5cztcbiAgICBpZiAoaW50ZXJsZWF2ZSkge1xuICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5maWxlRGlyZWN0b3J5LlNhbXBsZUZvcm1hdFxuICAgICAgICA/IE1hdGgubWF4LmFwcGx5KG51bGwsIHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVGb3JtYXQpIDogMTtcbiAgICAgIGNvbnN0IGJpdHNQZXJTYW1wbGUgPSBNYXRoLm1heC5hcHBseShudWxsLCB0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZSk7XG4gICAgICB2YWx1ZUFycmF5cyA9IGFycmF5Rm9yVHlwZShmb3JtYXQsIGJpdHNQZXJTYW1wbGUsIG51bVBpeGVscyAqIHNhbXBsZXMubGVuZ3RoKTtcbiAgICAgIGlmIChmaWxsVmFsdWUpIHtcbiAgICAgICAgdmFsdWVBcnJheXMuZmlsbChmaWxsVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZUFycmF5cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlQXJyYXkgPSB0aGlzLmdldEFycmF5Rm9yU2FtcGxlKHNhbXBsZXNbaV0sIG51bVBpeGVscyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbGxWYWx1ZSkgJiYgaSA8IGZpbGxWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWx1ZUFycmF5LmZpbGwoZmlsbFZhbHVlW2ldKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxsVmFsdWUgJiYgIUFycmF5LmlzQXJyYXkoZmlsbFZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlQXJyYXkuZmlsbChmaWxsVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlQXJyYXlzLnB1c2godmFsdWVBcnJheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcG9vbE9yRGVjb2RlciA9IHBvb2wgfHwgYXdhaXQgZ2V0RGVjb2Rlcih0aGlzLmZpbGVEaXJlY3RvcnkpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fcmVhZFJhc3RlcihcbiAgICAgIGltYWdlV2luZG93LCBzYW1wbGVzLCB2YWx1ZUFycmF5cywgaW50ZXJsZWF2ZSwgcG9vbE9yRGVjb2Rlciwgd2lkdGgsIGhlaWdodCwgcmVzYW1wbGVNZXRob2QsIHNpZ25hbCxcbiAgICApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgcmFzdGVyIGRhdGEgZnJvbSB0aGUgaW1hZ2UgYXMgUkdCLiBUaGUgcmVzdWx0IGlzIGFsd2F5cyBhblxuICAgKiBpbnRlcmxlYXZlZCB0eXBlZCBhcnJheS5cbiAgICogQ29sb3JzcGFjZXMgb3RoZXIgdGhhbiBSR0Igd2lsbCBiZSB0cmFuc2Zvcm1lZCB0byBSR0IsIGNvbG9yIG1hcHMgZXhwYW5kZWQuXG4gICAqIFdoZW4gbm8gb3RoZXIgbWV0aG9kIGlzIGFwcGxpY2FibGUsIHRoZSBmaXJzdCBzYW1wbGUgaXMgdXNlZCB0byBwcm9kdWNlIGFcbiAgICogZ3JheXNjYWxlIGltYWdlLlxuICAgKiBXaGVuIHByb3ZpZGVkLCBvbmx5IGEgc3Vic2V0IG9mIHRoZSByYXN0ZXIgaXMgcmVhZCBmb3IgZWFjaCBzYW1wbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLndpbmRvd10gdGhlIHN1YnNldCB0byByZWFkIGRhdGEgZnJvbSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaW50ZXJsZWF2ZT10cnVlXSB3aGV0aGVyIHRoZSBkYXRhIHNoYWxsIGJlIHJlYWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBvbmUgc2luZ2xlIGFycmF5IG9yIHNlcGFyYXRlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZ2VvdGlmZlwiKS5Qb29sfSBbb3B0aW9ucy5wb29sPW51bGxdIFRoZSBvcHRpb25hbCBkZWNvZGVyIHBvb2wgdG8gdXNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud2lkdGhdIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQuIFdoZW4gdGhlIHdpZHRoIGlzIG5vIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbWUgYXMgdGhlIGltYWdlcywgcmVzYW1wbGluZyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQuIFdoZW4gdGhlIHdpZHRoIGlzIG5vIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1lIGFzIHRoZSBpbWFnZXMsIHJlc2FtcGxpbmcgd2lsbCBiZSBwZXJmb3JtZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZXNhbXBsZU1ldGhvZD0nbmVhcmVzdCddIFRoZSBkZXNpcmVkIHJlc2FtcGxpbmcgbWV0aG9kLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZUFscGhhPWZhbHNlXSBFbmFibGUgcmVhZGluZyBhbHBoYSBjaGFubmVsIGlmIHByZXNlbnQuXG4gICAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtvcHRpb25zLnNpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFkUmFzdGVyUmVzdWx0Pn0gdGhlIFJHQiBhcnJheSBhcyBhIFByb21pc2VcbiAgICovXG4gIGFzeW5jIHJlYWRSR0IoeyB3aW5kb3csIGludGVybGVhdmUgPSB0cnVlLCBwb29sID0gbnVsbCwgd2lkdGgsIGhlaWdodCxcbiAgICByZXNhbXBsZU1ldGhvZCwgZW5hYmxlQWxwaGEgPSBmYWxzZSwgc2lnbmFsIH0gPSB7fSkge1xuICAgIGNvbnN0IGltYWdlV2luZG93ID0gd2luZG93IHx8IFswLCAwLCB0aGlzLmdldFdpZHRoKCksIHRoaXMuZ2V0SGVpZ2h0KCldO1xuXG4gICAgLy8gY2hlY2sgcGFyYW1ldGVyc1xuICAgIGlmIChpbWFnZVdpbmRvd1swXSA+IGltYWdlV2luZG93WzJdIHx8IGltYWdlV2luZG93WzFdID4gaW1hZ2VXaW5kb3dbM10pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdWJzZXRzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcGkgPSB0aGlzLmZpbGVEaXJlY3RvcnkuUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbjtcblxuICAgIGlmIChwaSA9PT0gcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuUkdCKSB7XG4gICAgICBsZXQgcyA9IFswLCAxLCAyXTtcbiAgICAgIGlmICgoISh0aGlzLmZpbGVEaXJlY3RvcnkuRXh0cmFTYW1wbGVzID09PSBFeHRyYVNhbXBsZXNWYWx1ZXMuVW5zcGVjaWZpZWQpKSAmJiBlbmFibGVBbHBoYSkge1xuICAgICAgICBzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlYWRSYXN0ZXJzKHtcbiAgICAgICAgd2luZG93LFxuICAgICAgICBpbnRlcmxlYXZlLFxuICAgICAgICBzYW1wbGVzOiBzLFxuICAgICAgICBwb29sLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICByZXNhbXBsZU1ldGhvZCxcbiAgICAgICAgc2lnbmFsLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IHNhbXBsZXM7XG4gICAgc3dpdGNoIChwaSkge1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5XaGl0ZUlzWmVybzpcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuQmxhY2tJc1plcm86XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLlBhbGV0dGU6XG4gICAgICAgIHNhbXBsZXMgPSBbMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5DTVlLOlxuICAgICAgICBzYW1wbGVzID0gWzAsIDEsIDIsIDNdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuWUNiQ3I6XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLkNJRUxhYjpcbiAgICAgICAgc2FtcGxlcyA9IFswLCAxLCAyXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3IgdW5zdXBwb3J0ZWQgcGhvdG9tZXRyaWMgaW50ZXJwcmV0YXRpb24uJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ViT3B0aW9ucyA9IHtcbiAgICAgIHdpbmRvdzogaW1hZ2VXaW5kb3csXG4gICAgICBpbnRlcmxlYXZlOiB0cnVlLFxuICAgICAgc2FtcGxlcyxcbiAgICAgIHBvb2wsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHJlc2FtcGxlTWV0aG9kLFxuICAgICAgc2lnbmFsLFxuICAgIH07XG4gICAgY29uc3QgeyBmaWxlRGlyZWN0b3J5IH0gPSB0aGlzO1xuICAgIGNvbnN0IHJhc3RlciA9IGF3YWl0IHRoaXMucmVhZFJhc3RlcnMoc3ViT3B0aW9ucyk7XG5cbiAgICBjb25zdCBtYXggPSAyICoqIHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlWzBdO1xuICAgIGxldCBkYXRhO1xuICAgIHN3aXRjaCAocGkpIHtcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuV2hpdGVJc1plcm86XG4gICAgICAgIGRhdGEgPSBmcm9tV2hpdGVJc1plcm8ocmFzdGVyLCBtYXgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuQmxhY2tJc1plcm86XG4gICAgICAgIGRhdGEgPSBmcm9tQmxhY2tJc1plcm8ocmFzdGVyLCBtYXgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuUGFsZXR0ZTpcbiAgICAgICAgZGF0YSA9IGZyb21QYWxldHRlKHJhc3RlciwgZmlsZURpcmVjdG9yeS5Db2xvck1hcCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5DTVlLOlxuICAgICAgICBkYXRhID0gZnJvbUNNWUsocmFzdGVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLllDYkNyOlxuICAgICAgICBkYXRhID0gZnJvbVlDYkNyKHJhc3Rlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5DSUVMYWI6XG4gICAgICAgIGRhdGEgPSBmcm9tQ0lFTGFiKHJhc3Rlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwaG90b21ldHJpYyBpbnRlcnByZXRhdGlvbi4nKTtcbiAgICB9XG5cbiAgICAvLyBpZiBub24taW50ZXJsZWF2ZWQgZGF0YSBpcyByZXF1ZXN0ZWQsIHdlIG11c3Qgc3BsaXQgdGhlIGNoYW5uZWxzXG4gICAgLy8gaW50byB0aGVpciByZXNwZWN0aXZlIGFycmF5c1xuICAgIGlmICghaW50ZXJsZWF2ZSkge1xuICAgICAgY29uc3QgcmVkID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggLyAzKTtcbiAgICAgIGNvbnN0IGdyZWVuID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggLyAzKTtcbiAgICAgIGNvbnN0IGJsdWUgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCAvIDMpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gMywgKytqKSB7XG4gICAgICAgIHJlZFtqXSA9IGRhdGFbaV07XG4gICAgICAgIGdyZWVuW2pdID0gZGF0YVtpICsgMV07XG4gICAgICAgIGJsdWVbal0gPSBkYXRhW2kgKyAyXTtcbiAgICAgIH1cbiAgICAgIGRhdGEgPSBbcmVkLCBncmVlbiwgYmx1ZV07XG4gICAgfVxuXG4gICAgZGF0YS53aWR0aCA9IHJhc3Rlci53aWR0aDtcbiAgICBkYXRhLmhlaWdodCA9IHJhc3Rlci5oZWlnaHQ7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aWVwb2ludHMuXG4gICAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAgICovXG4gIGdldFRpZVBvaW50cygpIHtcbiAgICBpZiAoIXRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgdGllUG9pbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludC5sZW5ndGg7IGkgKz0gNikge1xuICAgICAgdGllUG9pbnRzLnB1c2goe1xuICAgICAgICBpOiB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludFtpXSxcbiAgICAgICAgajogdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnRbaSArIDFdLFxuICAgICAgICBrOiB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludFtpICsgMl0sXG4gICAgICAgIHg6IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50W2kgKyAzXSxcbiAgICAgICAgeTogdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnRbaSArIDRdLFxuICAgICAgICB6OiB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludFtpICsgNV0sXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpZVBvaW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJzZWQgR0RBTCBtZXRhZGF0YSBpdGVtcy5cbiAgICpcbiAgICogSWYgc2FtcGxlIGlzIHBhc3NlZCB0byBudWxsLCBkYXRhc2V0LWxldmVsIG1ldGFkYXRhIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIE90aGVyd2lzZSBvbmx5IG1ldGFkYXRhIHNwZWNpZmljIHRvIHRoZSBwcm92aWRlZCBzYW1wbGUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzYW1wbGU9bnVsbF0gVGhlIHNhbXBsZSBpbmRleC5cbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIGdldEdEQUxNZXRhZGF0YShzYW1wbGUgPSBudWxsKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB7fTtcbiAgICBpZiAoIXRoaXMuZmlsZURpcmVjdG9yeS5HREFMX01FVEFEQVRBKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3RyaW5nID0gdGhpcy5maWxlRGlyZWN0b3J5LkdEQUxfTUVUQURBVEE7XG5cbiAgICBsZXQgaXRlbXMgPSBmaW5kVGFnc0J5TmFtZShzdHJpbmcsICdJdGVtJyk7XG5cbiAgICBpZiAoc2FtcGxlID09PSBudWxsKSB7XG4gICAgICBpdGVtcyA9IGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gZ2V0QXR0cmlidXRlKGl0ZW0sICdzYW1wbGUnKSA9PT0gdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbXMgPSBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IE51bWJlcihnZXRBdHRyaWJ1dGUoaXRlbSwgJ3NhbXBsZScpKSA9PT0gc2FtcGxlKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICBtZXRhZGF0YVtnZXRBdHRyaWJ1dGUoaXRlbSwgJ25hbWUnKV0gPSBpdGVtLmlubmVyO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgR0RBTCBub2RhdGEgdmFsdWVcbiAgICogQHJldHVybnMge251bWJlcnxudWxsfVxuICAgKi9cbiAgZ2V0R0RBTE5vRGF0YSgpIHtcbiAgICBpZiAoIXRoaXMuZmlsZURpcmVjdG9yeS5HREFMX05PREFUQSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZyA9IHRoaXMuZmlsZURpcmVjdG9yeS5HREFMX05PREFUQTtcbiAgICByZXR1cm4gTnVtYmVyKHN0cmluZy5zdWJzdHJpbmcoMCwgc3RyaW5nLmxlbmd0aCAtIDEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbWFnZSBvcmlnaW4gYXMgYSBYWVotdmVjdG9yLiBXaGVuIHRoZSBpbWFnZSBoYXMgbm8gYWZmaW5lXG4gICAqIHRyYW5zZm9ybWF0aW9uLCB0aGVuIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBUaGUgb3JpZ2luIGFzIGEgdmVjdG9yXG4gICAqL1xuICBnZXRPcmlnaW4oKSB7XG4gICAgY29uc3QgdGllUG9pbnRzID0gdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnQ7XG4gICAgY29uc3QgbW9kZWxUcmFuc2Zvcm1hdGlvbiA9IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRyYW5zZm9ybWF0aW9uO1xuICAgIGlmICh0aWVQb2ludHMgJiYgdGllUG9pbnRzLmxlbmd0aCA9PT0gNikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdGllUG9pbnRzWzNdLFxuICAgICAgICB0aWVQb2ludHNbNF0sXG4gICAgICAgIHRpZVBvaW50c1s1XSxcbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChtb2RlbFRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzNdLFxuICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzddLFxuICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzExXSxcbiAgICAgIF07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGltYWdlIGRvZXMgbm90IGhhdmUgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGltYWdlIHJlc29sdXRpb24gYXMgYSBYWVotdmVjdG9yLiBXaGVuIHRoZSBpbWFnZSBoYXMgbm8gYWZmaW5lXG4gICAqIHRyYW5zZm9ybWF0aW9uLCB0aGVuIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAqIEBwYXJhbSB7R2VvVElGRkltYWdlfSBbcmVmZXJlbmNlSW1hZ2U9bnVsbF0gQSByZWZlcmVuY2UgaW1hZ2UgdG8gY2FsY3VsYXRlIHRoZSByZXNvbHV0aW9uIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBjYXNlcyB3aGVuIHRoZSBjdXJyZW50IGltYWdlIGRvZXMgbm90IGhhdmUgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQgdGFncyBvbiBpdHMgb3duLlxuICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gVGhlIHJlc29sdXRpb24gYXMgYSB2ZWN0b3JcbiAgICovXG4gIGdldFJlc29sdXRpb24ocmVmZXJlbmNlSW1hZ2UgPSBudWxsKSB7XG4gICAgY29uc3QgbW9kZWxQaXhlbFNjYWxlID0gdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsUGl4ZWxTY2FsZTtcbiAgICBjb25zdCBtb2RlbFRyYW5zZm9ybWF0aW9uID0gdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVHJhbnNmb3JtYXRpb247XG5cbiAgICBpZiAobW9kZWxQaXhlbFNjYWxlKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBtb2RlbFBpeGVsU2NhbGVbMF0sXG4gICAgICAgIC1tb2RlbFBpeGVsU2NhbGVbMV0sXG4gICAgICAgIG1vZGVsUGl4ZWxTY2FsZVsyXSxcbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChtb2RlbFRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICBpZiAobW9kZWxUcmFuc2Zvcm1hdGlvblsxXSA9PT0gMCAmJiBtb2RlbFRyYW5zZm9ybWF0aW9uWzRdID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgbW9kZWxUcmFuc2Zvcm1hdGlvblswXSxcbiAgICAgICAgICAtbW9kZWxUcmFuc2Zvcm1hdGlvbls1XSxcbiAgICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzEwXSxcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgIE1hdGguc3FydCgobW9kZWxUcmFuc2Zvcm1hdGlvblswXSAqIG1vZGVsVHJhbnNmb3JtYXRpb25bMF0pXG4gICAgICAgICAgKyAobW9kZWxUcmFuc2Zvcm1hdGlvbls0XSAqIG1vZGVsVHJhbnNmb3JtYXRpb25bNF0pKSxcbiAgICAgICAgLU1hdGguc3FydCgobW9kZWxUcmFuc2Zvcm1hdGlvblsxXSAqIG1vZGVsVHJhbnNmb3JtYXRpb25bMV0pXG4gICAgICAgICAgKyAobW9kZWxUcmFuc2Zvcm1hdGlvbls1XSAqIG1vZGVsVHJhbnNmb3JtYXRpb25bNV0pKSxcbiAgICAgICAgbW9kZWxUcmFuc2Zvcm1hdGlvblsxMF1dO1xuICAgIH1cblxuICAgIGlmIChyZWZlcmVuY2VJbWFnZSkge1xuICAgICAgY29uc3QgW3JlZlJlc1gsIHJlZlJlc1ksIHJlZlJlc1pdID0gcmVmZXJlbmNlSW1hZ2UuZ2V0UmVzb2x1dGlvbigpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgcmVmUmVzWCAqIHJlZmVyZW5jZUltYWdlLmdldFdpZHRoKCkgLyB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgIHJlZlJlc1kgKiByZWZlcmVuY2VJbWFnZS5nZXRIZWlnaHQoKSAvIHRoaXMuZ2V0SGVpZ2h0KCksXG4gICAgICAgIHJlZlJlc1ogKiByZWZlcmVuY2VJbWFnZS5nZXRXaWR0aCgpIC8gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgXTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbWFnZSBkb2VzIG5vdCBoYXZlIGFuIGFmZmluZSB0cmFuc2Zvcm1hdGlvbi4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwaXhlbHMgb2YgdGhlIGltYWdlIGRlcGljdCBhbiBhcmVhIChvciBwb2ludCkuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBwaXhlbHMgYXJlIGEgcG9pbnRcbiAgICovXG4gIHBpeGVsSXNBcmVhKCkge1xuICAgIHJldHVybiB0aGlzLmdlb0tleXMuR1RSYXN0ZXJUeXBlR2VvS2V5ID09PSAxO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGltYWdlIGJvdW5kaW5nIGJveCBhcyBhbiBhcnJheSBvZiA0IHZhbHVlczogbWluLXgsIG1pbi15LFxuICAgKiBtYXgteCBhbmQgbWF4LXkuIFdoZW4gdGhlIGltYWdlIGhhcyBubyBhZmZpbmUgdHJhbnNmb3JtYXRpb24sIHRoZW4gYW5cbiAgICogZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbdGlsZWdyaWQ9ZmFsc2VdIElmIHRydWUgcmV0dXJuIGV4dGVudCBmb3IgYSB0aWxlZ3JpZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aG91dCBhZGp1c3RtZW50IGZvciBNb2RlbFRyYW5zZm9ybWF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gVGhlIGJvdW5kaW5nIGJveFxuICAgKi9cbiAgZ2V0Qm91bmRpbmdCb3godGlsZWdyaWQgPSBmYWxzZSkge1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG5cbiAgICBpZiAodGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVHJhbnNmb3JtYXRpb24gJiYgIXRpbGVncmlkKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGNvbnN0IFthLCBiLCBjLCBkLCBlLCBmLCBnLCBoXSA9IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRyYW5zZm9ybWF0aW9uO1xuXG4gICAgICBjb25zdCBjb3JuZXJzID0gW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFswLCBoZWlnaHRdLFxuICAgICAgICBbd2lkdGgsIDBdLFxuICAgICAgICBbd2lkdGgsIGhlaWdodF0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBwcm9qZWN0ZWQgPSBjb3JuZXJzLm1hcCgoW0ksIEpdKSA9PiBbXG4gICAgICAgIGQgKyAoYSAqIEkpICsgKGIgKiBKKSxcbiAgICAgICAgaCArIChlICogSSkgKyAoZiAqIEopLFxuICAgICAgXSk7XG5cbiAgICAgIGNvbnN0IHhzID0gcHJvamVjdGVkLm1hcCgocHQpID0+IHB0WzBdKTtcbiAgICAgIGNvbnN0IHlzID0gcHJvamVjdGVkLm1hcCgocHQpID0+IHB0WzFdKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5taW4oLi4ueHMpLFxuICAgICAgICBNYXRoLm1pbiguLi55cyksXG4gICAgICAgIE1hdGgubWF4KC4uLnhzKSxcbiAgICAgICAgTWF0aC5tYXgoLi4ueXMpLFxuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4oKTtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcblxuICAgICAgY29uc3QgeDEgPSBvcmlnaW5bMF07XG4gICAgICBjb25zdCB5MSA9IG9yaWdpblsxXTtcblxuICAgICAgY29uc3QgeDIgPSB4MSArIChyZXNvbHV0aW9uWzBdICogd2lkdGgpO1xuICAgICAgY29uc3QgeTIgPSB5MSArIChyZXNvbHV0aW9uWzFdICogaGVpZ2h0KTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5taW4oeDEsIHgyKSxcbiAgICAgICAgTWF0aC5taW4oeTEsIHkyKSxcbiAgICAgICAgTWF0aC5tYXgoeDEsIHgyKSxcbiAgICAgICAgTWF0aC5tYXgoeTEsIHkyKSxcbiAgICAgIF07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdlb1RJRkZJbWFnZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/geotiffimage.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/geotiffwriter.js":
/*!***********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiffwriter.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   writeGeotiff: function() { return /* binding */ writeGeotiff; }\n/* harmony export */ });\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/utils.js\");\n/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\n\n\n\nconst tagName2Code = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagNames);\nconst geoKeyName2Code = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.geoKeyNames);\nconst name2code = {};\n(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.assign)(name2code, tagName2Code);\n(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.assign)(name2code, geoKeyName2Code);\nconst typeName2byte = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTypeNames);\n\n// config variables\nconst numBytesInIfd = 1000;\n\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return (buff[p] << 8) | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map((i) => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(4, (i) => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(8, (i) => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = (n >> 8) & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = (n >> 24) & 255;\n    buff[p + 1] = (n >> 16) & 255;\n    buff[p + 2] = (n >> 8) & 255;\n    buff[p + 3] = (n >> 0) & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(s.length, (i) => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8),\n};\n\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(8, (i) => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n\n  const keys = Object.keys(ifd).filter((key) => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n\n  let eoff = offset + (12 * keys.length) + 4;\n\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = _globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (val === undefined) {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.endsWith)(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n\n    bin.writeUint(data, offset, num);\n    offset += 4;\n\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeUshort(data, toff + (2 * i), val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeUint(data, toff + (4 * i), val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeUint(data, toff + (8 * i), Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + (8 * i) + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeDouble(data, toff + (8 * i), val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += (dlen & 1);\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = (ifds) => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n\n  let ifdo = 8;\n\n  bin.writeUint(data, offset, ifdo);\n\n  offset += 4;\n\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width], // ImageWidth\n    257: [height], // ImageLength\n    273: [numBytesInIfd], // strips offset\n    278: [height], // RowsPerStrip\n    305: 'geotiff.js', // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n\n  const img = new Uint8Array(values);\n\n  const samplesPerPixel = ifd[277];\n\n  const data = new Uint8Array(numBytesInIfd + (width * height * samplesPerPixel));\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(prfx.length, (i) => {\n    data[i] = prfx[i];\n  });\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.forEach)(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n\n  return data.buffer;\n};\n\nconst convertToTids = (input) => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\n\nconst toArray = (input) => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\n\nconst metadataDefaults = [\n  ['Compression', 1], // no compression\n  ['PlanarConfiguration', 1],\n  ['ExtraSamples', 0],\n];\n\nfunction writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(height, (rowIndex) => {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(width, (columnIndex) => {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, (bandIndex) => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach((tag) => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, () => 1);\n  }\n\n  // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n\n  const geoKeys = Object.keys(metadata)\n    .filter((key) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.endsWith)(key, 'GeoKey'))\n    .sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoAsciiParams) {\n    let geoAsciiParams = '';\n    geoKeys.forEach((name) => {\n      const code = Number(name2code[name]);\n      const tagType = _globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[code];\n      if (tagType === 'ASCII') {\n        geoAsciiParams += `${metadata[name].toString()}\\u0000`;\n      }\n    });\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach((geoKey) => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey of geoKeys) {\n    if (metadata.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  [\n    'Compression',\n    'ExtraSamples',\n    'GeographicTypeGeoKey',\n    'GTModelTypeGeoKey',\n    'GTRasterTypeGeoKey',\n    'ImageLength', // synonym of ImageHeight\n    'ImageWidth',\n    'Orientation',\n    'PhotometricInterpretation',\n    'ProjectedCSTypeGeoKey',\n    'PlanarConfiguration',\n    'ResolutionUnit',\n    'SamplesPerPixel',\n    'XPosition',\n    'YPosition',\n    'RowsPerStrip',\n  ].forEach((name) => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n\n  const encodedMetadata = convertToTids(metadata);\n\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n\n  return outputImage;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2dlb3RpZmZ3cml0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lGO0FBQ25COztBQUV0RSxxQkFBcUIsaURBQU0sQ0FBQyxzREFBYTtBQUN6Qyx3QkFBd0IsaURBQU0sQ0FBQyxvREFBVztBQUMxQztBQUNBLGlEQUFNO0FBQ04saURBQU07QUFDTixzQkFBc0IsaURBQU0sQ0FBQyx1REFBYzs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSSxnREFBSztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJLGdEQUFLO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxJQUFJLGdEQUFLO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUUsZ0RBQUs7QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxxQkFBcUIsc0RBQWE7QUFDbEM7O0FBRUE7QUFDQSw4Q0FBOEMsSUFBSTtBQUNsRDs7QUFFQTs7QUFFQTtBQUNBLHFEQUFxRCxJQUFJO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxtREFBUTtBQUNuRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNLGdEQUFLO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLE1BQU0sZ0RBQUs7QUFDWDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sTUFBTSxnREFBSztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLE1BQU0sZ0RBQUs7QUFDWDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUVBQW1FLE9BQU87QUFDMUU7O0FBRUE7QUFDQSxtRUFBbUUsTUFBTTtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUUsZ0RBQUs7QUFDUDtBQUNBLEdBQUc7QUFDSCxFQUFFLGtEQUFPO0FBQ1Q7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQUs7QUFDVCxNQUFNLGdEQUFLO0FBQ1gsUUFBUSxnREFBSztBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkIsZ0RBQUs7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGdEQUFLO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsbURBQVE7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWE7QUFDbkM7QUFDQSw2QkFBNkIsMEJBQTBCO0FBQ3ZEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzREFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHFFQUFxRSxPQUFPO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmd3JpdGVyLmpzP2Y0NWUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgU29tZSBwYXJ0cyBvZiB0aGlzIGZpbGUgYXJlIGJhc2VkIG9uIFVUSUYuanMsXG4gIHdoaWNoIHdhcyByZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gIFlvdSBjYW4gdmlldyB0aGF0IGhlcmU6XG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b3BlYS9VVElGLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiovXG5pbXBvcnQgeyBmaWVsZFRhZ05hbWVzLCBmaWVsZFRhZ1R5cGVzLCBmaWVsZFR5cGVOYW1lcywgZ2VvS2V5TmFtZXMgfSBmcm9tICcuL2dsb2JhbHMuanMnO1xuaW1wb3J0IHsgYXNzaWduLCBlbmRzV2l0aCwgZm9yRWFjaCwgaW52ZXJ0LCB0aW1lcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5jb25zdCB0YWdOYW1lMkNvZGUgPSBpbnZlcnQoZmllbGRUYWdOYW1lcyk7XG5jb25zdCBnZW9LZXlOYW1lMkNvZGUgPSBpbnZlcnQoZ2VvS2V5TmFtZXMpO1xuY29uc3QgbmFtZTJjb2RlID0ge307XG5hc3NpZ24obmFtZTJjb2RlLCB0YWdOYW1lMkNvZGUpO1xuYXNzaWduKG5hbWUyY29kZSwgZ2VvS2V5TmFtZTJDb2RlKTtcbmNvbnN0IHR5cGVOYW1lMmJ5dGUgPSBpbnZlcnQoZmllbGRUeXBlTmFtZXMpO1xuXG4vLyBjb25maWcgdmFyaWFibGVzXG5jb25zdCBudW1CeXRlc0luSWZkID0gMTAwMDtcblxuY29uc3QgX2JpbkJFID0ge1xuICBuZXh0WmVybzogKGRhdGEsIG8pID0+IHtcbiAgICBsZXQgb2luY3IgPSBvO1xuICAgIHdoaWxlIChkYXRhW29pbmNyXSAhPT0gMCkge1xuICAgICAgb2luY3IrKztcbiAgICB9XG4gICAgcmV0dXJuIG9pbmNyO1xuICB9LFxuICByZWFkVXNob3J0OiAoYnVmZiwgcCkgPT4ge1xuICAgIHJldHVybiAoYnVmZltwXSA8PCA4KSB8IGJ1ZmZbcCArIDFdO1xuICB9LFxuICByZWFkU2hvcnQ6IChidWZmLCBwKSA9PiB7XG4gICAgY29uc3QgYSA9IF9iaW5CRS51aTg7XG4gICAgYVswXSA9IGJ1ZmZbcCArIDFdO1xuICAgIGFbMV0gPSBidWZmW3AgKyAwXTtcbiAgICByZXR1cm4gX2JpbkJFLmkxNlswXTtcbiAgfSxcbiAgcmVhZEludDogKGJ1ZmYsIHApID0+IHtcbiAgICBjb25zdCBhID0gX2JpbkJFLnVpODtcbiAgICBhWzBdID0gYnVmZltwICsgM107XG4gICAgYVsxXSA9IGJ1ZmZbcCArIDJdO1xuICAgIGFbMl0gPSBidWZmW3AgKyAxXTtcbiAgICBhWzNdID0gYnVmZltwICsgMF07XG4gICAgcmV0dXJuIF9iaW5CRS5pMzJbMF07XG4gIH0sXG4gIHJlYWRVaW50OiAoYnVmZiwgcCkgPT4ge1xuICAgIGNvbnN0IGEgPSBfYmluQkUudWk4O1xuICAgIGFbMF0gPSBidWZmW3AgKyAzXTtcbiAgICBhWzFdID0gYnVmZltwICsgMl07XG4gICAgYVsyXSA9IGJ1ZmZbcCArIDFdO1xuICAgIGFbM10gPSBidWZmW3AgKyAwXTtcbiAgICByZXR1cm4gX2JpbkJFLnVpMzJbMF07XG4gIH0sXG4gIHJlYWRBU0NJSTogKGJ1ZmYsIHAsIGwpID0+IHtcbiAgICByZXR1cm4gbC5tYXAoKGkpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZltwICsgaV0pKS5qb2luKCcnKTtcbiAgfSxcbiAgcmVhZEZsb2F0OiAoYnVmZiwgcCkgPT4ge1xuICAgIGNvbnN0IGEgPSBfYmluQkUudWk4O1xuICAgIHRpbWVzKDQsIChpKSA9PiB7XG4gICAgICBhW2ldID0gYnVmZltwICsgMyAtIGldO1xuICAgIH0pO1xuICAgIHJldHVybiBfYmluQkUuZmwzMlswXTtcbiAgfSxcbiAgcmVhZERvdWJsZTogKGJ1ZmYsIHApID0+IHtcbiAgICBjb25zdCBhID0gX2JpbkJFLnVpODtcbiAgICB0aW1lcyg4LCAoaSkgPT4ge1xuICAgICAgYVtpXSA9IGJ1ZmZbcCArIDcgLSBpXTtcbiAgICB9KTtcbiAgICByZXR1cm4gX2JpbkJFLmZsNjRbMF07XG4gIH0sXG4gIHdyaXRlVXNob3J0OiAoYnVmZiwgcCwgbikgPT4ge1xuICAgIGJ1ZmZbcF0gPSAobiA+PiA4KSAmIDI1NTtcbiAgICBidWZmW3AgKyAxXSA9IG4gJiAyNTU7XG4gIH0sXG4gIHdyaXRlVWludDogKGJ1ZmYsIHAsIG4pID0+IHtcbiAgICBidWZmW3BdID0gKG4gPj4gMjQpICYgMjU1O1xuICAgIGJ1ZmZbcCArIDFdID0gKG4gPj4gMTYpICYgMjU1O1xuICAgIGJ1ZmZbcCArIDJdID0gKG4gPj4gOCkgJiAyNTU7XG4gICAgYnVmZltwICsgM10gPSAobiA+PiAwKSAmIDI1NTtcbiAgfSxcbiAgd3JpdGVBU0NJSTogKGJ1ZmYsIHAsIHMpID0+IHtcbiAgICB0aW1lcyhzLmxlbmd0aCwgKGkpID0+IHtcbiAgICAgIGJ1ZmZbcCArIGldID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIH0pO1xuICB9LFxuICB1aTg6IG5ldyBVaW50OEFycmF5KDgpLFxufTtcblxuX2JpbkJFLmZsNjQgPSBuZXcgRmxvYXQ2NEFycmF5KF9iaW5CRS51aTguYnVmZmVyKTtcblxuX2JpbkJFLndyaXRlRG91YmxlID0gKGJ1ZmYsIHAsIG4pID0+IHtcbiAgX2JpbkJFLmZsNjRbMF0gPSBuO1xuICB0aW1lcyg4LCAoaSkgPT4ge1xuICAgIGJ1ZmZbcCArIGldID0gX2JpbkJFLnVpOFs3IC0gaV07XG4gIH0pO1xufTtcblxuY29uc3QgX3dyaXRlSUZEID0gKGJpbiwgZGF0YSwgX29mZnNldCwgaWZkKSA9PiB7XG4gIGxldCBvZmZzZXQgPSBfb2Zmc2V0O1xuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpZmQpLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgcmV0dXJuIGtleSAhPT0gdW5kZWZpbmVkICYmIGtleSAhPT0gbnVsbCAmJiBrZXkgIT09ICd1bmRlZmluZWQnO1xuICB9KTtcblxuICBiaW4ud3JpdGVVc2hvcnQoZGF0YSwgb2Zmc2V0LCBrZXlzLmxlbmd0aCk7XG4gIG9mZnNldCArPSAyO1xuXG4gIGxldCBlb2ZmID0gb2Zmc2V0ICsgKDEyICoga2V5cy5sZW5ndGgpICsgNDtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgbGV0IHRhZyA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdudW1iZXInKSB7XG4gICAgICB0YWcgPSBrZXk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGFnID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZU5hbWUgPSBmaWVsZFRhZ1R5cGVzW3RhZ107XG4gICAgY29uc3QgdHlwZU51bSA9IHR5cGVOYW1lMmJ5dGVbdHlwZU5hbWVdO1xuXG4gICAgaWYgKHR5cGVOYW1lID09IG51bGwgfHwgdHlwZU5hbWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZU5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZSBvZiB0YWc6ICR7dGFnfWApO1xuICAgIH1cblxuICAgIGxldCB2YWwgPSBpZmRba2V5XTtcblxuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gZ2V0IHZhbHVlIGZvciBrZXkgJHtrZXl9YCk7XG4gICAgfVxuXG4gICAgLy8gQVNDSUlaIGZvcm1hdCB3aXRoIHRyYWlsaW5nIDAgY2hhcmFjdGVyXG4gICAgLy8gaHR0cDovL3d3dy5maWxlZm9ybWF0LmluZm8vZm9ybWF0L3RpZmYvY29yaW9uLmh0bVxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc3ODMwNDQvd2hhdHMtdGhlLWRpZmZlcmVuY2UtYmV0d2Vlbi1hc2NpaXotdnMtYXNjaWlcbiAgICBpZiAodHlwZU5hbWUgPT09ICdBU0NJSScgJiYgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgZW5kc1dpdGgodmFsLCAnXFx1MDAwMCcpID09PSBmYWxzZSkge1xuICAgICAgdmFsICs9ICdcXHUwMDAwJztcbiAgICB9XG5cbiAgICBjb25zdCBudW0gPSB2YWwubGVuZ3RoO1xuXG4gICAgYmluLndyaXRlVXNob3J0KGRhdGEsIG9mZnNldCwgdGFnKTtcbiAgICBvZmZzZXQgKz0gMjtcblxuICAgIGJpbi53cml0ZVVzaG9ydChkYXRhLCBvZmZzZXQsIHR5cGVOdW0pO1xuICAgIG9mZnNldCArPSAyO1xuXG4gICAgYmluLndyaXRlVWludChkYXRhLCBvZmZzZXQsIG51bSk7XG4gICAgb2Zmc2V0ICs9IDQ7XG5cbiAgICBsZXQgZGxlbiA9IFstMSwgMSwgMSwgMiwgNCwgOCwgMCwgMCwgMCwgMCwgMCwgMCwgOF1bdHlwZU51bV0gKiBudW07XG4gICAgbGV0IHRvZmYgPSBvZmZzZXQ7XG5cbiAgICBpZiAoZGxlbiA+IDQpIHtcbiAgICAgIGJpbi53cml0ZVVpbnQoZGF0YSwgb2Zmc2V0LCBlb2ZmKTtcbiAgICAgIHRvZmYgPSBlb2ZmO1xuICAgIH1cblxuICAgIGlmICh0eXBlTmFtZSA9PT0gJ0FTQ0lJJykge1xuICAgICAgYmluLndyaXRlQVNDSUkoZGF0YSwgdG9mZiwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSAnU0hPUlQnKSB7XG4gICAgICB0aW1lcyhudW0sIChpKSA9PiB7XG4gICAgICAgIGJpbi53cml0ZVVzaG9ydChkYXRhLCB0b2ZmICsgKDIgKiBpKSwgdmFsW2ldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZU5hbWUgPT09ICdMT05HJykge1xuICAgICAgdGltZXMobnVtLCAoaSkgPT4ge1xuICAgICAgICBiaW4ud3JpdGVVaW50KGRhdGEsIHRvZmYgKyAoNCAqIGkpLCB2YWxbaV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlTmFtZSA9PT0gJ1JBVElPTkFMJykge1xuICAgICAgdGltZXMobnVtLCAoaSkgPT4ge1xuICAgICAgICBiaW4ud3JpdGVVaW50KGRhdGEsIHRvZmYgKyAoOCAqIGkpLCBNYXRoLnJvdW5kKHZhbFtpXSAqIDEwMDAwKSk7XG4gICAgICAgIGJpbi53cml0ZVVpbnQoZGF0YSwgdG9mZiArICg4ICogaSkgKyA0LCAxMDAwMCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSAnRE9VQkxFJykge1xuICAgICAgdGltZXMobnVtLCAoaSkgPT4ge1xuICAgICAgICBiaW4ud3JpdGVEb3VibGUoZGF0YSwgdG9mZiArICg4ICogaSksIHZhbFtpXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZGxlbiA+IDQpIHtcbiAgICAgIGRsZW4gKz0gKGRsZW4gJiAxKTtcbiAgICAgIGVvZmYgKz0gZGxlbjtcbiAgICB9XG5cbiAgICBvZmZzZXQgKz0gNDtcbiAgfVxuXG4gIHJldHVybiBbb2Zmc2V0LCBlb2ZmXTtcbn07XG5cbmNvbnN0IGVuY29kZUlmZHMgPSAoaWZkcykgPT4ge1xuICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobnVtQnl0ZXNJbklmZCk7XG4gIGxldCBvZmZzZXQgPSA0O1xuICBjb25zdCBiaW4gPSBfYmluQkU7XG5cbiAgLy8gc2V0IGJpZy1lbmRpYW4gYnl0ZS1vcmRlclxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9USUZGI0J5dGVfb3JkZXJcbiAgZGF0YVswXSA9IDc3O1xuICBkYXRhWzFdID0gNzc7XG5cbiAgLy8gc2V0IGZvcm1hdC12ZXJzaW9uIG51bWJlclxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9USUZGI0J5dGVfb3JkZXJcbiAgZGF0YVszXSA9IDQyO1xuXG4gIGxldCBpZmRvID0gODtcblxuICBiaW4ud3JpdGVVaW50KGRhdGEsIG9mZnNldCwgaWZkbyk7XG5cbiAgb2Zmc2V0ICs9IDQ7XG5cbiAgaWZkcy5mb3JFYWNoKChpZmQsIGkpID0+IHtcbiAgICBjb25zdCBub2ZmcyA9IF93cml0ZUlGRChiaW4sIGRhdGEsIGlmZG8sIGlmZCk7XG4gICAgaWZkbyA9IG5vZmZzWzFdO1xuICAgIGlmIChpIDwgaWZkcy5sZW5ndGggLSAxKSB7XG4gICAgICBiaW4ud3JpdGVVaW50KGRhdGEsIG5vZmZzWzBdLCBpZmRvKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkYXRhLnNsaWNlKSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2UoMCwgaWZkbykuYnVmZmVyO1xuICB9XG5cbiAgLy8gbm9kZSBoYXNuJ3QgaW1wbGVtZW50ZWQgc2xpY2Ugb24gVWludDhBcnJheSB5ZXRcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoaWZkbyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWZkbzsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gZGF0YVtpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn07XG5cbmNvbnN0IGVuY29kZUltYWdlID0gKHZhbHVlcywgd2lkdGgsIGhlaWdodCwgbWV0YWRhdGEpID0+IHtcbiAgaWYgKGhlaWdodCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgeW91IHBhc3NlZCBpbnRvIGVuY29kZUltYWdlIGEgd2lkdGggb2YgdHlwZSAke2hlaWdodH1gKTtcbiAgfVxuXG4gIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHdpZHRoID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGB5b3UgcGFzc2VkIGludG8gZW5jb2RlSW1hZ2UgYSB3aWR0aCBvZiB0eXBlICR7d2lkdGh9YCk7XG4gIH1cblxuICBjb25zdCBpZmQgPSB7XG4gICAgMjU2OiBbd2lkdGhdLCAvLyBJbWFnZVdpZHRoXG4gICAgMjU3OiBbaGVpZ2h0XSwgLy8gSW1hZ2VMZW5ndGhcbiAgICAyNzM6IFtudW1CeXRlc0luSWZkXSwgLy8gc3RyaXBzIG9mZnNldFxuICAgIDI3ODogW2hlaWdodF0sIC8vIFJvd3NQZXJTdHJpcFxuICAgIDMwNTogJ2dlb3RpZmYuanMnLCAvLyBubyBhcnJheSBmb3IgQVNDSUkoWilcbiAgfTtcblxuICBpZiAobWV0YWRhdGEpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gbWV0YWRhdGEpIHtcbiAgICAgIGlmIChtZXRhZGF0YS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBpZmRbaV0gPSBtZXRhZGF0YVtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBwcmZ4ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlSWZkcyhbaWZkXSkpO1xuXG4gIGNvbnN0IGltZyA9IG5ldyBVaW50OEFycmF5KHZhbHVlcyk7XG5cbiAgY29uc3Qgc2FtcGxlc1BlclBpeGVsID0gaWZkWzI3N107XG5cbiAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KG51bUJ5dGVzSW5JZmQgKyAod2lkdGggKiBoZWlnaHQgKiBzYW1wbGVzUGVyUGl4ZWwpKTtcbiAgdGltZXMocHJmeC5sZW5ndGgsIChpKSA9PiB7XG4gICAgZGF0YVtpXSA9IHByZnhbaV07XG4gIH0pO1xuICBmb3JFYWNoKGltZywgKHZhbHVlLCBpKSA9PiB7XG4gICAgZGF0YVtudW1CeXRlc0luSWZkICsgaV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGEuYnVmZmVyO1xufTtcblxuY29uc3QgY29udmVydFRvVGlkcyA9IChpbnB1dCkgPT4ge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gaW5wdXQpIHtcbiAgICBpZiAoa2V5ICE9PSAnU3RyaXBPZmZzZXRzJykge1xuICAgICAgaWYgKCFuYW1lMmNvZGVba2V5XSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGtleSwgJ25vdCBpbiBuYW1lMmNvZGU6JywgT2JqZWN0LmtleXMobmFtZTJjb2RlKSk7XG4gICAgICB9XG4gICAgICByZXN1bHRbbmFtZTJjb2RlW2tleV1dID0gaW5wdXRba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHRvQXJyYXkgPSAoaW5wdXQpID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIHJldHVybiBbaW5wdXRdO1xufTtcblxuY29uc3QgbWV0YWRhdGFEZWZhdWx0cyA9IFtcbiAgWydDb21wcmVzc2lvbicsIDFdLCAvLyBubyBjb21wcmVzc2lvblxuICBbJ1BsYW5hckNvbmZpZ3VyYXRpb24nLCAxXSxcbiAgWydFeHRyYVNhbXBsZXMnLCAwXSxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZUdlb3RpZmYoZGF0YSwgbWV0YWRhdGEpIHtcbiAgY29uc3QgaXNGbGF0dGVuZWQgPSB0eXBlb2YgZGF0YVswXSA9PT0gJ251bWJlcic7XG5cbiAgbGV0IGhlaWdodDtcbiAgbGV0IG51bUJhbmRzO1xuICBsZXQgd2lkdGg7XG4gIGxldCBmbGF0dGVuZWRWYWx1ZXM7XG5cbiAgaWYgKGlzRmxhdHRlbmVkKSB7XG4gICAgaGVpZ2h0ID0gbWV0YWRhdGEuaGVpZ2h0IHx8IG1ldGFkYXRhLkltYWdlTGVuZ3RoO1xuICAgIHdpZHRoID0gbWV0YWRhdGEud2lkdGggfHwgbWV0YWRhdGEuSW1hZ2VXaWR0aDtcbiAgICBudW1CYW5kcyA9IGRhdGEubGVuZ3RoIC8gKGhlaWdodCAqIHdpZHRoKTtcbiAgICBmbGF0dGVuZWRWYWx1ZXMgPSBkYXRhO1xuICB9IGVsc2Uge1xuICAgIG51bUJhbmRzID0gZGF0YS5sZW5ndGg7XG4gICAgaGVpZ2h0ID0gZGF0YVswXS5sZW5ndGg7XG4gICAgd2lkdGggPSBkYXRhWzBdWzBdLmxlbmd0aDtcbiAgICBmbGF0dGVuZWRWYWx1ZXMgPSBbXTtcbiAgICB0aW1lcyhoZWlnaHQsIChyb3dJbmRleCkgPT4ge1xuICAgICAgdGltZXMod2lkdGgsIChjb2x1bW5JbmRleCkgPT4ge1xuICAgICAgICB0aW1lcyhudW1CYW5kcywgKGJhbmRJbmRleCkgPT4ge1xuICAgICAgICAgIGZsYXR0ZW5lZFZhbHVlcy5wdXNoKGRhdGFbYmFuZEluZGV4XVtyb3dJbmRleF1bY29sdW1uSW5kZXhdKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIG1ldGFkYXRhLkltYWdlTGVuZ3RoID0gaGVpZ2h0O1xuICBkZWxldGUgbWV0YWRhdGEuaGVpZ2h0O1xuICBtZXRhZGF0YS5JbWFnZVdpZHRoID0gd2lkdGg7XG4gIGRlbGV0ZSBtZXRhZGF0YS53aWR0aDtcblxuICAvLyBjb25zdWx0IGh0dHBzOi8vd3d3LmxvYy5nb3YvcHJlc2VydmF0aW9uL2RpZ2l0YWwvZm9ybWF0cy9jb250ZW50L3RpZmZfdGFncy5zaHRtbFxuXG4gIGlmICghbWV0YWRhdGEuQml0c1BlclNhbXBsZSkge1xuICAgIG1ldGFkYXRhLkJpdHNQZXJTYW1wbGUgPSB0aW1lcyhudW1CYW5kcywgKCkgPT4gOCk7XG4gIH1cblxuICBtZXRhZGF0YURlZmF1bHRzLmZvckVhY2goKHRhZykgPT4ge1xuICAgIGNvbnN0IGtleSA9IHRhZ1swXTtcbiAgICBpZiAoIW1ldGFkYXRhW2tleV0pIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGFnWzFdO1xuICAgICAgbWV0YWRhdGFba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVGhlIGNvbG9yIHNwYWNlIG9mIHRoZSBpbWFnZSBkYXRhLlxuICAvLyAxPWJsYWNrIGlzIHplcm8gYW5kIDI9UkdCLlxuICBpZiAoIW1ldGFkYXRhLlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24pIHtcbiAgICBtZXRhZGF0YS5QaG90b21ldHJpY0ludGVycHJldGF0aW9uID0gbWV0YWRhdGEuQml0c1BlclNhbXBsZS5sZW5ndGggPT09IDMgPyAyIDogMTtcbiAgfVxuXG4gIC8vIFRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBwZXIgcGl4ZWwuXG4gIGlmICghbWV0YWRhdGEuU2FtcGxlc1BlclBpeGVsKSB7XG4gICAgbWV0YWRhdGEuU2FtcGxlc1BlclBpeGVsID0gW251bUJhbmRzXTtcbiAgfVxuXG4gIGlmICghbWV0YWRhdGEuU3RyaXBCeXRlQ291bnRzKSB7XG4gICAgLy8gd2UgYXJlIG9ubHkgd3JpdGluZyBvbmUgc3RyaXBcbiAgICBtZXRhZGF0YS5TdHJpcEJ5dGVDb3VudHMgPSBbbnVtQmFuZHMgKiBoZWlnaHQgKiB3aWR0aF07XG4gIH1cblxuICBpZiAoIW1ldGFkYXRhLk1vZGVsUGl4ZWxTY2FsZSkge1xuICAgIC8vIGFzc3VtZXMgcmFzdGVyIHRha2VzIHVwIGV4YWN0bHkgdGhlIHdob2xlIGdsb2JlXG4gICAgbWV0YWRhdGEuTW9kZWxQaXhlbFNjYWxlID0gWzM2MCAvIHdpZHRoLCAxODAgLyBoZWlnaHQsIDBdO1xuICB9XG5cbiAgaWYgKCFtZXRhZGF0YS5TYW1wbGVGb3JtYXQpIHtcbiAgICBtZXRhZGF0YS5TYW1wbGVGb3JtYXQgPSB0aW1lcyhudW1CYW5kcywgKCkgPT4gMSk7XG4gIH1cblxuICAvLyBpZiBkaWRuJ3QgcGFzcyBpbiBwcm9qZWN0aW9uIGluZm9ybWF0aW9uLCBhc3N1bWUgdGhlIHBvcHVsYXIgNDMyNiBcImdlb2dyYXBoaWMgcHJvamVjdGlvblwiXG4gIGlmICghbWV0YWRhdGEuaGFzT3duUHJvcGVydHkoJ0dlb2dyYXBoaWNUeXBlR2VvS2V5JykgJiYgIW1ldGFkYXRhLmhhc093blByb3BlcnR5KCdQcm9qZWN0ZWRDU1R5cGVHZW9LZXknKSkge1xuICAgIG1ldGFkYXRhLkdlb2dyYXBoaWNUeXBlR2VvS2V5ID0gNDMyNjtcbiAgICBtZXRhZGF0YS5Nb2RlbFRpZXBvaW50ID0gWzAsIDAsIDAsIC0xODAsIDkwLCAwXTsgLy8gcmFzdGVyIGZpdHMgd2hvbGUgZ2xvYmVcbiAgICBtZXRhZGF0YS5HZW9nQ2l0YXRpb25HZW9LZXkgPSAnV0dTIDg0JztcbiAgICBtZXRhZGF0YS5HVE1vZGVsVHlwZUdlb0tleSA9IDI7XG4gIH1cblxuICBjb25zdCBnZW9LZXlzID0gT2JqZWN0LmtleXMobWV0YWRhdGEpXG4gICAgLmZpbHRlcigoa2V5KSA9PiBlbmRzV2l0aChrZXksICdHZW9LZXknKSlcbiAgICAuc29ydCgoYSwgYikgPT4gbmFtZTJjb2RlW2FdIC0gbmFtZTJjb2RlW2JdKTtcblxuICBpZiAoIW1ldGFkYXRhLkdlb0FzY2lpUGFyYW1zKSB7XG4gICAgbGV0IGdlb0FzY2lpUGFyYW1zID0gJyc7XG4gICAgZ2VvS2V5cy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBjb25zdCBjb2RlID0gTnVtYmVyKG5hbWUyY29kZVtuYW1lXSk7XG4gICAgICBjb25zdCB0YWdUeXBlID0gZmllbGRUYWdUeXBlc1tjb2RlXTtcbiAgICAgIGlmICh0YWdUeXBlID09PSAnQVNDSUknKSB7XG4gICAgICAgIGdlb0FzY2lpUGFyYW1zICs9IGAke21ldGFkYXRhW25hbWVdLnRvU3RyaW5nKCl9XFx1MDAwMGA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGdlb0FzY2lpUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIG1ldGFkYXRhLkdlb0FzY2lpUGFyYW1zID0gZ2VvQXNjaWlQYXJhbXM7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFtZXRhZGF0YS5HZW9LZXlEaXJlY3RvcnkpIHtcbiAgICBjb25zdCBOdW1iZXJPZktleXMgPSBnZW9LZXlzLmxlbmd0aDtcblxuICAgIGNvbnN0IEdlb0tleURpcmVjdG9yeSA9IFsxLCAxLCAwLCBOdW1iZXJPZktleXNdO1xuICAgIGdlb0tleXMuZm9yRWFjaCgoZ2VvS2V5KSA9PiB7XG4gICAgICBjb25zdCBLZXlJRCA9IE51bWJlcihuYW1lMmNvZGVbZ2VvS2V5XSk7XG4gICAgICBHZW9LZXlEaXJlY3RvcnkucHVzaChLZXlJRCk7XG5cbiAgICAgIGxldCBDb3VudDtcbiAgICAgIGxldCBUSUZGVGFnTG9jYXRpb247XG4gICAgICBsZXQgdmFsdWVPZmZzZXQ7XG4gICAgICBpZiAoZmllbGRUYWdUeXBlc1tLZXlJRF0gPT09ICdTSE9SVCcpIHtcbiAgICAgICAgQ291bnQgPSAxO1xuICAgICAgICBUSUZGVGFnTG9jYXRpb24gPSAwO1xuICAgICAgICB2YWx1ZU9mZnNldCA9IG1ldGFkYXRhW2dlb0tleV07XG4gICAgICB9IGVsc2UgaWYgKGdlb0tleSA9PT0gJ0dlb2dDaXRhdGlvbkdlb0tleScpIHtcbiAgICAgICAgQ291bnQgPSBtZXRhZGF0YS5HZW9Bc2NpaVBhcmFtcy5sZW5ndGg7XG4gICAgICAgIFRJRkZUYWdMb2NhdGlvbiA9IE51bWJlcihuYW1lMmNvZGUuR2VvQXNjaWlQYXJhbXMpO1xuICAgICAgICB2YWx1ZU9mZnNldCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhgW2dlb3RpZmYuanNdIGNvdWxkbid0IGdldCBUSUZGVGFnTG9jYXRpb24gZm9yICR7Z2VvS2V5fWApO1xuICAgICAgfVxuICAgICAgR2VvS2V5RGlyZWN0b3J5LnB1c2goVElGRlRhZ0xvY2F0aW9uKTtcbiAgICAgIEdlb0tleURpcmVjdG9yeS5wdXNoKENvdW50KTtcbiAgICAgIEdlb0tleURpcmVjdG9yeS5wdXNoKHZhbHVlT2Zmc2V0KTtcbiAgICB9KTtcbiAgICBtZXRhZGF0YS5HZW9LZXlEaXJlY3RvcnkgPSBHZW9LZXlEaXJlY3Rvcnk7XG4gIH1cblxuICAvLyBkZWxldGUgR2VvS2V5cyBmcm9tIG1ldGFkYXRhLCBiZWNhdXNlIHN0b3JlZCBpbiBHZW9LZXlEaXJlY3RvcnkgdGFnXG4gIGZvciAoY29uc3QgZ2VvS2V5IG9mIGdlb0tleXMpIHtcbiAgICBpZiAobWV0YWRhdGEuaGFzT3duUHJvcGVydHkoZ2VvS2V5KSkge1xuICAgICAgZGVsZXRlIG1ldGFkYXRhW2dlb0tleV07XG4gICAgfVxuICB9XG5cbiAgW1xuICAgICdDb21wcmVzc2lvbicsXG4gICAgJ0V4dHJhU2FtcGxlcycsXG4gICAgJ0dlb2dyYXBoaWNUeXBlR2VvS2V5JyxcbiAgICAnR1RNb2RlbFR5cGVHZW9LZXknLFxuICAgICdHVFJhc3RlclR5cGVHZW9LZXknLFxuICAgICdJbWFnZUxlbmd0aCcsIC8vIHN5bm9ueW0gb2YgSW1hZ2VIZWlnaHRcbiAgICAnSW1hZ2VXaWR0aCcsXG4gICAgJ09yaWVudGF0aW9uJyxcbiAgICAnUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbicsXG4gICAgJ1Byb2plY3RlZENTVHlwZUdlb0tleScsXG4gICAgJ1BsYW5hckNvbmZpZ3VyYXRpb24nLFxuICAgICdSZXNvbHV0aW9uVW5pdCcsXG4gICAgJ1NhbXBsZXNQZXJQaXhlbCcsXG4gICAgJ1hQb3NpdGlvbicsXG4gICAgJ1lQb3NpdGlvbicsXG4gICAgJ1Jvd3NQZXJTdHJpcCcsXG4gIF0uZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIGlmIChtZXRhZGF0YVtuYW1lXSkge1xuICAgICAgbWV0YWRhdGFbbmFtZV0gPSB0b0FycmF5KG1ldGFkYXRhW25hbWVdKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGVuY29kZWRNZXRhZGF0YSA9IGNvbnZlcnRUb1RpZHMobWV0YWRhdGEpO1xuXG4gIGNvbnN0IG91dHB1dEltYWdlID0gZW5jb2RlSW1hZ2UoZmxhdHRlbmVkVmFsdWVzLCB3aWR0aCwgaGVpZ2h0LCBlbmNvZGVkTWV0YWRhdGEpO1xuXG4gIHJldHVybiBvdXRwdXRJbWFnZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/geotiffwriter.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/globals.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/globals.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtraSamplesValues: function() { return /* binding */ ExtraSamplesValues; },\n/* harmony export */   LercAddCompression: function() { return /* binding */ LercAddCompression; },\n/* harmony export */   LercParameters: function() { return /* binding */ LercParameters; },\n/* harmony export */   arrayFields: function() { return /* binding */ arrayFields; },\n/* harmony export */   fieldTagNames: function() { return /* binding */ fieldTagNames; },\n/* harmony export */   fieldTagTypes: function() { return /* binding */ fieldTagTypes; },\n/* harmony export */   fieldTags: function() { return /* binding */ fieldTags; },\n/* harmony export */   fieldTypeNames: function() { return /* binding */ fieldTypeNames; },\n/* harmony export */   fieldTypes: function() { return /* binding */ fieldTypes; },\n/* harmony export */   geoKeyNames: function() { return /* binding */ geoKeyNames; },\n/* harmony export */   geoKeys: function() { return /* binding */ geoKeys; },\n/* harmony export */   photometricInterpretations: function() { return /* binding */ photometricInterpretations; }\n/* harmony export */ });\nconst fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nconst fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nconst fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34264: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34736: 'DOUBLE',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nconst arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nconst fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nconst fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nconst photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nconst ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nconst LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nconst LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n  Zstandard: 2,\n};\n\nconst geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nconst geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2dsb2JhbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nbG9iYWxzLmpzPzY4YmYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGZpZWxkVGFnTmFtZXMgPSB7XG4gIC8vIFRJRkYgQmFzZWxpbmVcbiAgMHgwMTNCOiAnQXJ0aXN0JyxcbiAgMHgwMTAyOiAnQml0c1BlclNhbXBsZScsXG4gIDB4MDEwOTogJ0NlbGxMZW5ndGgnLFxuICAweDAxMDg6ICdDZWxsV2lkdGgnLFxuICAweDAxNDA6ICdDb2xvck1hcCcsXG4gIDB4MDEwMzogJ0NvbXByZXNzaW9uJyxcbiAgMHg4Mjk4OiAnQ29weXJpZ2h0JyxcbiAgMHgwMTMyOiAnRGF0ZVRpbWUnLFxuICAweDAxNTI6ICdFeHRyYVNhbXBsZXMnLFxuICAweDAxMEE6ICdGaWxsT3JkZXInLFxuICAweDAxMjE6ICdGcmVlQnl0ZUNvdW50cycsXG4gIDB4MDEyMDogJ0ZyZWVPZmZzZXRzJyxcbiAgMHgwMTIzOiAnR3JheVJlc3BvbnNlQ3VydmUnLFxuICAweDAxMjI6ICdHcmF5UmVzcG9uc2VVbml0JyxcbiAgMHgwMTNDOiAnSG9zdENvbXB1dGVyJyxcbiAgMHgwMTBFOiAnSW1hZ2VEZXNjcmlwdGlvbicsXG4gIDB4MDEwMTogJ0ltYWdlTGVuZ3RoJyxcbiAgMHgwMTAwOiAnSW1hZ2VXaWR0aCcsXG4gIDB4MDEwRjogJ01ha2UnLFxuICAweDAxMTk6ICdNYXhTYW1wbGVWYWx1ZScsXG4gIDB4MDExODogJ01pblNhbXBsZVZhbHVlJyxcbiAgMHgwMTEwOiAnTW9kZWwnLFxuICAweDAwRkU6ICdOZXdTdWJmaWxlVHlwZScsXG4gIDB4MDExMjogJ09yaWVudGF0aW9uJyxcbiAgMHgwMTA2OiAnUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbicsXG4gIDB4MDExQzogJ1BsYW5hckNvbmZpZ3VyYXRpb24nLFxuICAweDAxMjg6ICdSZXNvbHV0aW9uVW5pdCcsXG4gIDB4MDExNjogJ1Jvd3NQZXJTdHJpcCcsXG4gIDB4MDExNTogJ1NhbXBsZXNQZXJQaXhlbCcsXG4gIDB4MDEzMTogJ1NvZnR3YXJlJyxcbiAgMHgwMTE3OiAnU3RyaXBCeXRlQ291bnRzJyxcbiAgMHgwMTExOiAnU3RyaXBPZmZzZXRzJyxcbiAgMHgwMEZGOiAnU3ViZmlsZVR5cGUnLFxuICAweDAxMDc6ICdUaHJlc2hob2xkaW5nJyxcbiAgMHgwMTFBOiAnWFJlc29sdXRpb24nLFxuICAweDAxMUI6ICdZUmVzb2x1dGlvbicsXG5cbiAgLy8gVElGRiBFeHRlbmRlZFxuICAweDAxNDY6ICdCYWRGYXhMaW5lcycsXG4gIDB4MDE0NzogJ0NsZWFuRmF4RGF0YScsXG4gIDB4MDE1NzogJ0NsaXBQYXRoJyxcbiAgMHgwMTQ4OiAnQ29uc2VjdXRpdmVCYWRGYXhMaW5lcycsXG4gIDB4MDFCMTogJ0RlY29kZScsXG4gIDB4MDFCMjogJ0RlZmF1bHRJbWFnZUNvbG9yJyxcbiAgMHgwMTBEOiAnRG9jdW1lbnROYW1lJyxcbiAgMHgwMTUwOiAnRG90UmFuZ2UnLFxuICAweDAxNDE6ICdIYWxmdG9uZUhpbnRzJyxcbiAgMHgwMTVBOiAnSW5kZXhlZCcsXG4gIDB4MDE1QjogJ0pQRUdUYWJsZXMnLFxuICAweDAxMUQ6ICdQYWdlTmFtZScsXG4gIDB4MDEyOTogJ1BhZ2VOdW1iZXInLFxuICAweDAxM0Q6ICdQcmVkaWN0b3InLFxuICAweDAxM0Y6ICdQcmltYXJ5Q2hyb21hdGljaXRpZXMnLFxuICAweDAyMTQ6ICdSZWZlcmVuY2VCbGFja1doaXRlJyxcbiAgMHgwMTUzOiAnU2FtcGxlRm9ybWF0JyxcbiAgMHgwMTU0OiAnU01pblNhbXBsZVZhbHVlJyxcbiAgMHgwMTU1OiAnU01heFNhbXBsZVZhbHVlJyxcbiAgMHgwMjJGOiAnU3RyaXBSb3dDb3VudHMnLFxuICAweDAxNEE6ICdTdWJJRkRzJyxcbiAgMHgwMTI0OiAnVDRPcHRpb25zJyxcbiAgMHgwMTI1OiAnVDZPcHRpb25zJyxcbiAgMHgwMTQ1OiAnVGlsZUJ5dGVDb3VudHMnLFxuICAweDAxNDM6ICdUaWxlTGVuZ3RoJyxcbiAgMHgwMTQ0OiAnVGlsZU9mZnNldHMnLFxuICAweDAxNDI6ICdUaWxlV2lkdGgnLFxuICAweDAxMkQ6ICdUcmFuc2ZlckZ1bmN0aW9uJyxcbiAgMHgwMTNFOiAnV2hpdGVQb2ludCcsXG4gIDB4MDE1ODogJ1hDbGlwUGF0aFVuaXRzJyxcbiAgMHgwMTFFOiAnWFBvc2l0aW9uJyxcbiAgMHgwMjExOiAnWUNiQ3JDb2VmZmljaWVudHMnLFxuICAweDAyMTM6ICdZQ2JDclBvc2l0aW9uaW5nJyxcbiAgMHgwMjEyOiAnWUNiQ3JTdWJTYW1wbGluZycsXG4gIDB4MDE1OTogJ1lDbGlwUGF0aFVuaXRzJyxcbiAgMHgwMTFGOiAnWVBvc2l0aW9uJyxcblxuICAvLyBFWElGXG4gIDB4OTIwMjogJ0FwZXJ0dXJlVmFsdWUnLFxuICAweEEwMDE6ICdDb2xvclNwYWNlJyxcbiAgMHg5MDA0OiAnRGF0ZVRpbWVEaWdpdGl6ZWQnLFxuICAweDkwMDM6ICdEYXRlVGltZU9yaWdpbmFsJyxcbiAgMHg4NzY5OiAnRXhpZiBJRkQnLFxuICAweDkwMDA6ICdFeGlmVmVyc2lvbicsXG4gIDB4ODI5QTogJ0V4cG9zdXJlVGltZScsXG4gIDB4QTMwMDogJ0ZpbGVTb3VyY2UnLFxuICAweDkyMDk6ICdGbGFzaCcsXG4gIDB4QTAwMDogJ0ZsYXNocGl4VmVyc2lvbicsXG4gIDB4ODI5RDogJ0ZOdW1iZXInLFxuICAweEE0MjA6ICdJbWFnZVVuaXF1ZUlEJyxcbiAgMHg5MjA4OiAnTGlnaHRTb3VyY2UnLFxuICAweDkyN0M6ICdNYWtlck5vdGUnLFxuICAweDkyMDE6ICdTaHV0dGVyU3BlZWRWYWx1ZScsXG4gIDB4OTI4NjogJ1VzZXJDb21tZW50JyxcblxuICAvLyBJUFRDXG4gIDB4ODNCQjogJ0lQVEMnLFxuXG4gIC8vIElDQ1xuICAweDg3NzM6ICdJQ0MgUHJvZmlsZScsXG5cbiAgLy8gWE1QXG4gIDB4MDJCQzogJ1hNUCcsXG5cbiAgLy8gR0RBTFxuICAweEE0ODA6ICdHREFMX01FVEFEQVRBJyxcbiAgMHhBNDgxOiAnR0RBTF9OT0RBVEEnLFxuXG4gIC8vIFBob3Rvc2hvcFxuICAweDg2NDk6ICdQaG90b3Nob3AnLFxuXG4gIC8vIEdlb1RpZmZcbiAgMHg4MzBFOiAnTW9kZWxQaXhlbFNjYWxlJyxcbiAgMHg4NDgyOiAnTW9kZWxUaWVwb2ludCcsXG4gIDB4ODVEODogJ01vZGVsVHJhbnNmb3JtYXRpb24nLFxuICAweDg3QUY6ICdHZW9LZXlEaXJlY3RvcnknLFxuICAweDg3QjA6ICdHZW9Eb3VibGVQYXJhbXMnLFxuICAweDg3QjE6ICdHZW9Bc2NpaVBhcmFtcycsXG5cbiAgLy8gTEVSQ1xuICAweEM1RjI6ICdMZXJjUGFyYW1ldGVycycsXG59O1xuXG5leHBvcnQgY29uc3QgZmllbGRUYWdzID0ge307XG5mb3IgKGNvbnN0IGtleSBpbiBmaWVsZFRhZ05hbWVzKSB7XG4gIGlmIChmaWVsZFRhZ05hbWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICBmaWVsZFRhZ3NbZmllbGRUYWdOYW1lc1trZXldXSA9IHBhcnNlSW50KGtleSwgMTApO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBmaWVsZFRhZ1R5cGVzID0ge1xuICAyNTY6ICdTSE9SVCcsXG4gIDI1NzogJ1NIT1JUJyxcbiAgMjU4OiAnU0hPUlQnLFxuICAyNTk6ICdTSE9SVCcsXG4gIDI2MjogJ1NIT1JUJyxcbiAgMjczOiAnTE9ORycsXG4gIDI3NDogJ1NIT1JUJyxcbiAgMjc3OiAnU0hPUlQnLFxuICAyNzg6ICdMT05HJyxcbiAgMjc5OiAnTE9ORycsXG4gIDI4MjogJ1JBVElPTkFMJyxcbiAgMjgzOiAnUkFUSU9OQUwnLFxuICAyODQ6ICdTSE9SVCcsXG4gIDI4NjogJ1NIT1JUJyxcbiAgMjg3OiAnUkFUSU9OQUwnLFxuICAyOTY6ICdTSE9SVCcsXG4gIDI5NzogJ1NIT1JUJyxcbiAgMzA1OiAnQVNDSUknLFxuICAzMDY6ICdBU0NJSScsXG4gIDMzODogJ1NIT1JUJyxcbiAgMzM5OiAnU0hPUlQnLFxuICA1MTM6ICdMT05HJyxcbiAgNTE0OiAnTE9ORycsXG4gIDEwMjQ6ICdTSE9SVCcsXG4gIDEwMjU6ICdTSE9SVCcsXG4gIDIwNDg6ICdTSE9SVCcsXG4gIDIwNDk6ICdBU0NJSScsXG4gIDMwNzI6ICdTSE9SVCcsXG4gIDMwNzM6ICdBU0NJSScsXG4gIDMzNTUwOiAnRE9VQkxFJyxcbiAgMzM5MjI6ICdET1VCTEUnLFxuICAzNDI2NDogJ0RPVUJMRScsXG4gIDM0NjY1OiAnTE9ORycsXG4gIDM0NzM1OiAnU0hPUlQnLFxuICAzNDczNjogJ0RPVUJMRScsXG4gIDM0NzM3OiAnQVNDSUknLFxuICA0MjExMzogJ0FTQ0lJJyxcbn07XG5cbmV4cG9ydCBjb25zdCBhcnJheUZpZWxkcyA9IFtcbiAgZmllbGRUYWdzLkJpdHNQZXJTYW1wbGUsXG4gIGZpZWxkVGFncy5FeHRyYVNhbXBsZXMsXG4gIGZpZWxkVGFncy5TYW1wbGVGb3JtYXQsXG4gIGZpZWxkVGFncy5TdHJpcEJ5dGVDb3VudHMsXG4gIGZpZWxkVGFncy5TdHJpcE9mZnNldHMsXG4gIGZpZWxkVGFncy5TdHJpcFJvd0NvdW50cyxcbiAgZmllbGRUYWdzLlRpbGVCeXRlQ291bnRzLFxuICBmaWVsZFRhZ3MuVGlsZU9mZnNldHMsXG4gIGZpZWxkVGFncy5TdWJJRkRzLFxuXTtcblxuZXhwb3J0IGNvbnN0IGZpZWxkVHlwZU5hbWVzID0ge1xuICAweDAwMDE6ICdCWVRFJyxcbiAgMHgwMDAyOiAnQVNDSUknLFxuICAweDAwMDM6ICdTSE9SVCcsXG4gIDB4MDAwNDogJ0xPTkcnLFxuICAweDAwMDU6ICdSQVRJT05BTCcsXG4gIDB4MDAwNjogJ1NCWVRFJyxcbiAgMHgwMDA3OiAnVU5ERUZJTkVEJyxcbiAgMHgwMDA4OiAnU1NIT1JUJyxcbiAgMHgwMDA5OiAnU0xPTkcnLFxuICAweDAwMEE6ICdTUkFUSU9OQUwnLFxuICAweDAwMEI6ICdGTE9BVCcsXG4gIDB4MDAwQzogJ0RPVUJMRScsXG4gIC8vIElGRCBvZmZzZXQsIHN1Z2dlc3RlZCBieSBodHRwczovL293bC5waHkucXVlZW5zdS5jYS9+cGhpbC9leGlmdG9vbC9zdGFuZGFyZHMuaHRtbFxuICAweDAwMEQ6ICdJRkQnLFxuICAvLyBpbnRyb2R1Y2VkIGJ5IEJpZ1RJRkZcbiAgMHgwMDEwOiAnTE9ORzgnLFxuICAweDAwMTE6ICdTTE9ORzgnLFxuICAweDAwMTI6ICdJRkQ4Jyxcbn07XG5cbmV4cG9ydCBjb25zdCBmaWVsZFR5cGVzID0ge307XG5mb3IgKGNvbnN0IGtleSBpbiBmaWVsZFR5cGVOYW1lcykge1xuICBpZiAoZmllbGRUeXBlTmFtZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIGZpZWxkVHlwZXNbZmllbGRUeXBlTmFtZXNba2V5XV0gPSBwYXJzZUludChrZXksIDEwKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMgPSB7XG4gIFdoaXRlSXNaZXJvOiAwLFxuICBCbGFja0lzWmVybzogMSxcbiAgUkdCOiAyLFxuICBQYWxldHRlOiAzLFxuICBUcmFuc3BhcmVuY3lNYXNrOiA0LFxuICBDTVlLOiA1LFxuICBZQ2JDcjogNixcblxuICBDSUVMYWI6IDgsXG4gIElDQ0xhYjogOSxcbn07XG5cbmV4cG9ydCBjb25zdCBFeHRyYVNhbXBsZXNWYWx1ZXMgPSB7XG4gIFVuc3BlY2lmaWVkOiAwLFxuICBBc3NvY2FscGhhOiAxLFxuICBVbmFzc2FscGhhOiAyLFxufTtcblxuZXhwb3J0IGNvbnN0IExlcmNQYXJhbWV0ZXJzID0ge1xuICBWZXJzaW9uOiAwLFxuICBBZGRDb21wcmVzc2lvbjogMSxcbn07XG5cbmV4cG9ydCBjb25zdCBMZXJjQWRkQ29tcHJlc3Npb24gPSB7XG4gIE5vbmU6IDAsXG4gIERlZmxhdGU6IDEsXG4gIFpzdGFuZGFyZDogMixcbn07XG5cbmV4cG9ydCBjb25zdCBnZW9LZXlOYW1lcyA9IHtcbiAgMTAyNDogJ0dUTW9kZWxUeXBlR2VvS2V5JyxcbiAgMTAyNTogJ0dUUmFzdGVyVHlwZUdlb0tleScsXG4gIDEwMjY6ICdHVENpdGF0aW9uR2VvS2V5JyxcbiAgMjA0ODogJ0dlb2dyYXBoaWNUeXBlR2VvS2V5JyxcbiAgMjA0OTogJ0dlb2dDaXRhdGlvbkdlb0tleScsXG4gIDIwNTA6ICdHZW9nR2VvZGV0aWNEYXR1bUdlb0tleScsXG4gIDIwNTE6ICdHZW9nUHJpbWVNZXJpZGlhbkdlb0tleScsXG4gIDIwNTI6ICdHZW9nTGluZWFyVW5pdHNHZW9LZXknLFxuICAyMDUzOiAnR2VvZ0xpbmVhclVuaXRTaXplR2VvS2V5JyxcbiAgMjA1NDogJ0dlb2dBbmd1bGFyVW5pdHNHZW9LZXknLFxuICAyMDU1OiAnR2VvZ0FuZ3VsYXJVbml0U2l6ZUdlb0tleScsXG4gIDIwNTY6ICdHZW9nRWxsaXBzb2lkR2VvS2V5JyxcbiAgMjA1NzogJ0dlb2dTZW1pTWFqb3JBeGlzR2VvS2V5JyxcbiAgMjA1ODogJ0dlb2dTZW1pTWlub3JBeGlzR2VvS2V5JyxcbiAgMjA1OTogJ0dlb2dJbnZGbGF0dGVuaW5nR2VvS2V5JyxcbiAgMjA2MDogJ0dlb2dBemltdXRoVW5pdHNHZW9LZXknLFxuICAyMDYxOiAnR2VvZ1ByaW1lTWVyaWRpYW5Mb25nR2VvS2V5JyxcbiAgMjA2MjogJ0dlb2dUT1dHUzg0R2VvS2V5JyxcbiAgMzA3MjogJ1Byb2plY3RlZENTVHlwZUdlb0tleScsXG4gIDMwNzM6ICdQQ1NDaXRhdGlvbkdlb0tleScsXG4gIDMwNzQ6ICdQcm9qZWN0aW9uR2VvS2V5JyxcbiAgMzA3NTogJ1Byb2pDb29yZFRyYW5zR2VvS2V5JyxcbiAgMzA3NjogJ1Byb2pMaW5lYXJVbml0c0dlb0tleScsXG4gIDMwNzc6ICdQcm9qTGluZWFyVW5pdFNpemVHZW9LZXknLFxuICAzMDc4OiAnUHJvalN0ZFBhcmFsbGVsMUdlb0tleScsXG4gIDMwNzk6ICdQcm9qU3RkUGFyYWxsZWwyR2VvS2V5JyxcbiAgMzA4MDogJ1Byb2pOYXRPcmlnaW5Mb25nR2VvS2V5JyxcbiAgMzA4MTogJ1Byb2pOYXRPcmlnaW5MYXRHZW9LZXknLFxuICAzMDgyOiAnUHJvakZhbHNlRWFzdGluZ0dlb0tleScsXG4gIDMwODM6ICdQcm9qRmFsc2VOb3J0aGluZ0dlb0tleScsXG4gIDMwODQ6ICdQcm9qRmFsc2VPcmlnaW5Mb25nR2VvS2V5JyxcbiAgMzA4NTogJ1Byb2pGYWxzZU9yaWdpbkxhdEdlb0tleScsXG4gIDMwODY6ICdQcm9qRmFsc2VPcmlnaW5FYXN0aW5nR2VvS2V5JyxcbiAgMzA4NzogJ1Byb2pGYWxzZU9yaWdpbk5vcnRoaW5nR2VvS2V5JyxcbiAgMzA4ODogJ1Byb2pDZW50ZXJMb25nR2VvS2V5JyxcbiAgMzA4OTogJ1Byb2pDZW50ZXJMYXRHZW9LZXknLFxuICAzMDkwOiAnUHJvakNlbnRlckVhc3RpbmdHZW9LZXknLFxuICAzMDkxOiAnUHJvakNlbnRlck5vcnRoaW5nR2VvS2V5JyxcbiAgMzA5MjogJ1Byb2pTY2FsZUF0TmF0T3JpZ2luR2VvS2V5JyxcbiAgMzA5MzogJ1Byb2pTY2FsZUF0Q2VudGVyR2VvS2V5JyxcbiAgMzA5NDogJ1Byb2pBemltdXRoQW5nbGVHZW9LZXknLFxuICAzMDk1OiAnUHJvalN0cmFpZ2h0VmVydFBvbGVMb25nR2VvS2V5JyxcbiAgMzA5NjogJ1Byb2pSZWN0aWZpZWRHcmlkQW5nbGVHZW9LZXknLFxuICA0MDk2OiAnVmVydGljYWxDU1R5cGVHZW9LZXknLFxuICA0MDk3OiAnVmVydGljYWxDaXRhdGlvbkdlb0tleScsXG4gIDQwOTg6ICdWZXJ0aWNhbERhdHVtR2VvS2V5JyxcbiAgNDA5OTogJ1ZlcnRpY2FsVW5pdHNHZW9LZXknLFxufTtcblxuZXhwb3J0IGNvbnN0IGdlb0tleXMgPSB7fTtcbmZvciAoY29uc3Qga2V5IGluIGdlb0tleU5hbWVzKSB7XG4gIGlmIChnZW9LZXlOYW1lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgZ2VvS2V5c1tnZW9LZXlOYW1lc1trZXldXSA9IHBhcnNlSW50KGtleSwgMTApO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/globals.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/logging.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/logging.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   debug: function() { return /* binding */ debug; },\n/* harmony export */   error: function() { return /* binding */ error; },\n/* harmony export */   info: function() { return /* binding */ info; },\n/* harmony export */   log: function() { return /* binding */ log; },\n/* harmony export */   setLogger: function() { return /* binding */ setLogger; },\n/* harmony export */   time: function() { return /* binding */ time; },\n/* harmony export */   timeEnd: function() { return /* binding */ timeEnd; },\n/* harmony export */   warn: function() { return /* binding */ warn; }\n/* harmony export */ });\n/**\n * A no-op logger\n */\nclass DummyLogger {\n  log() {}\n\n  debug() {}\n\n  info() {}\n\n  warn() {}\n\n  error() {}\n\n  time() {}\n\n  timeEnd() {}\n}\n\nlet LOGGER = new DummyLogger();\n\n/**\n *\n * @param {object} logger the new logger. e.g `console`\n */\nfunction setLogger(logger = new DummyLogger()) {\n  LOGGER = logger;\n}\n\nfunction debug(...args) {\n  return LOGGER.debug(...args);\n}\n\nfunction log(...args) {\n  return LOGGER.log(...args);\n}\n\nfunction info(...args) {\n  return LOGGER.info(...args);\n}\n\nfunction warn(...args) {\n  return LOGGER.warn(...args);\n}\n\nfunction error(...args) {\n  return LOGGER.error(...args);\n}\n\nfunction time(...args) {\n  return LOGGER.time(...args);\n}\n\nfunction timeEnd(...args) {\n  return LOGGER.timeEnd(...args);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2xvZ2dpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvbG9nZ2luZy5qcz9jMTU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBuby1vcCBsb2dnZXJcbiAqL1xuY2xhc3MgRHVtbXlMb2dnZXIge1xuICBsb2coKSB7fVxuXG4gIGRlYnVnKCkge31cblxuICBpbmZvKCkge31cblxuICB3YXJuKCkge31cblxuICBlcnJvcigpIHt9XG5cbiAgdGltZSgpIHt9XG5cbiAgdGltZUVuZCgpIHt9XG59XG5cbmxldCBMT0dHRVIgPSBuZXcgRHVtbXlMb2dnZXIoKTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGxvZ2dlciB0aGUgbmV3IGxvZ2dlci4gZS5nIGBjb25zb2xlYFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0TG9nZ2VyKGxvZ2dlciA9IG5ldyBEdW1teUxvZ2dlcigpKSB7XG4gIExPR0dFUiA9IGxvZ2dlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIExPR0dFUi5kZWJ1ZyguLi5hcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIubG9nKC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5mbyguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIuaW5mbyguLi5hcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhcm4oLi4uYXJncykge1xuICByZXR1cm4gTE9HR0VSLndhcm4oLi4uYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvciguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIuZXJyb3IoLi4uYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIExPR0dFUi50aW1lKC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZUVuZCguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIudGltZUVuZCguLi5hcmdzKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/logging.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/pool.js":
/*!**************************************************!*\
  !*** ./node_modules/geotiff/dist-module/pool.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compression/index.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/compression/index.js\");\n\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 2) : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {\n        __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_geotiff_dist-module_worker_decoder_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./worker/decoder.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/worker/decoder.js\")).then((module) => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then((create) => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({ worker: create(), idle: true });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0\n      ? (0,_compression_index_js__WEBPACK_IMPORTED_MODULE_0__.getDecoder)(fileDirectory).then((decoder) => decoder.decode(fileDirectory, buffer))\n      : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle)\n          || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({ fileDirectory, buffer, id }, [buffer]);\n      });\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Pool);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3Bvb2wuanMiLCJtYXBwaW5ncyI6Ijs7QUFBb0Q7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5UUFBNkI7QUFDckM7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDLDhCQUE4Qiw4QkFBOEI7QUFDNUQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkJBQTJCO0FBQy9ELE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrREFBZSxJQUFJLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvcG9vbC5qcz9iOWM4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldERlY29kZXIgfSBmcm9tICcuL2NvbXByZXNzaW9uL2luZGV4LmpzJztcblxuY29uc3QgZGVmYXVsdFBvb2xTaXplID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyAobmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgfHwgMikgOiAyO1xuXG4vKipcbiAqIEBtb2R1bGUgcG9vbFxuICovXG5cbi8qKlxuICogUG9vbCBmb3Igd29ya2VycyB0byBkZWNvZGUgY2h1bmtzIG9mIHRoZSBpbWFnZXMuXG4gKi9cbmNsYXNzIFBvb2wge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc2l6ZV0gVGhlIHNpemUgb2YgdGhlIHBvb2wuIERlZmF1bHRzIHRvIHRoZSBudW1iZXIgb2YgQ1BVc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGUuIFdoZW4gdGhpcyBwYXJhbWV0ZXIgaXMgYG51bGxgIG9yIDAsIHRoZW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGRlY29kaW5nIHdpbGwgYmUgZG9uZSBpbiB0aGUgbWFpbiB0aHJlYWQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogV29ya2VyfSBbY3JlYXRlV29ya2VyXSBBIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGUgZGVjb2RlciB3b3JrZXIuXG4gICAqIERlZmF1bHRzIHRvIGEgd29ya2VyIHdpdGggYWxsIGRlY29kZXJzIHRoYXQgc2hpcCB3aXRoIGdlb3RpZmYuanMuIFRoZSBgY3JlYXRlV29ya2VyKClgXG4gICAqIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhIGBXb3JrZXJgIGNvbXBhdGlibGUgd2l0aCBXZWIgV29ya2Vycy4gRm9yIGNvZGUgdGhhdFxuICAgKiBydW5zIGluIE5vZGUsIFt3ZWItd29ya2VyXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS93ZWItd29ya2VyKSBpcyBhIGdvb2QgY2hvaWNlLlxuICAgKlxuICAgKiBBIHdvcmtlciB0aGF0IHVzZXMgYSBjdXN0b20gbHp3IGRlY29kZXIgd291bGQgbG9vayBsaWtlIHRoaXMgYG15LWN1c3RvbS13b3JrZXIuanNgIGZpbGU6XG4gICAqIGBgYGpzXG4gICAqIGltcG9ydCB7IGFkZERlY29kZXIsIGdldERlY29kZXIgfSBmcm9tICdnZW90aWZmJztcbiAgICogYWRkRGVjb2Rlcig1LCAoKSA9PiBpbXBvcnQgKCcuL215LWN1c3RvbS1sencnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbiAgICogc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgYXN5bmMgKGUpID0+IHtcbiAgICogICBjb25zdCB7IGlkLCBmaWxlRGlyZWN0b3J5LCBidWZmZXIgfSA9IGUuZGF0YTtcbiAgICogICBjb25zdCBkZWNvZGVyID0gYXdhaXQgZ2V0RGVjb2RlcihmaWxlRGlyZWN0b3J5KTtcbiAgICogICBjb25zdCBkZWNvZGVkID0gYXdhaXQgZGVjb2Rlci5kZWNvZGUoZmlsZURpcmVjdG9yeSwgYnVmZmVyKTtcbiAgICogICBzZWxmLnBvc3RNZXNzYWdlKHsgZGVjb2RlZCwgaWQgfSwgW2RlY29kZWRdKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBUaGUgd2F5IHRoZSBhYm92ZSBjb2RlIGlzIGJ1aWx0IGludG8gYSB3b3JrZXIgYnkgdGhlIGBjcmVhdGVXb3JrZXIoKWAgZnVuY3Rpb25cbiAgICogZGVwZW5kcyBvbiB0aGUgdXNlZCBidW5kbGVyLiBGb3IgbW9zdCBidW5kbGVycywgc29tZXRoaW5nIGxpa2UgdGhpcyB3aWxsIHdvcms6XG4gICAqIGBgYGpzXG4gICAqIGZ1bmN0aW9uIGNyZWF0ZVdvcmtlcigpIHtcbiAgICogICByZXR1cm4gbmV3IFdvcmtlcihuZXcgVVJMKCcuL215LWN1c3RvbS13b3JrZXIuanMnLCBpbXBvcnQubWV0YS51cmwpKTtcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNpemUgPSBkZWZhdWx0UG9vbFNpemUsIGNyZWF0ZVdvcmtlcikge1xuICAgIHRoaXMud29ya2VycyA9IG51bGw7XG4gICAgdGhpcy5fYXdhaXRpbmdEZWNvZGVyID0gbnVsbDtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMubWVzc2FnZUlkID0gMDtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgdGhpcy5fYXdhaXRpbmdEZWNvZGVyID0gY3JlYXRlV29ya2VyID8gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZVdvcmtlcikgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBpbXBvcnQoJy4vd29ya2VyL2RlY29kZXIuanMnKS50aGVuKChtb2R1bGUpID0+IHtcbiAgICAgICAgICByZXNvbHZlKG1vZHVsZS5jcmVhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fYXdhaXRpbmdEZWNvZGVyLnRoZW4oKGNyZWF0ZSkgPT4ge1xuICAgICAgICB0aGlzLl9hd2FpdGluZ0RlY29kZXIgPSBudWxsO1xuICAgICAgICB0aGlzLndvcmtlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICB0aGlzLndvcmtlcnMucHVzaCh7IHdvcmtlcjogY3JlYXRlKCksIGlkbGU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgdGhlIGdpdmVuIGJsb2NrIG9mIGJ5dGVzIHdpdGggdGhlIHNldCBjb21wcmVzc2lvbiBtZXRob2QuXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciB0aGUgYXJyYXkgYnVmZmVyIG9mIGJ5dGVzIHRvIGRlY29kZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXlCdWZmZXI+fSB0aGUgZGVjb2RlZCByZXN1bHQgYXMgYSBgUHJvbWlzZWBcbiAgICovXG4gIGFzeW5jIGRlY29kZShmaWxlRGlyZWN0b3J5LCBidWZmZXIpIHtcbiAgICBpZiAodGhpcy5fYXdhaXRpbmdEZWNvZGVyKSB7XG4gICAgICBhd2FpdCB0aGlzLl9hd2FpdGluZ0RlY29kZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpemUgPT09IDBcbiAgICAgID8gZ2V0RGVjb2RlcihmaWxlRGlyZWN0b3J5KS50aGVuKChkZWNvZGVyKSA9PiBkZWNvZGVyLmRlY29kZShmaWxlRGlyZWN0b3J5LCBidWZmZXIpKVxuICAgICAgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCB3b3JrZXIgPSB0aGlzLndvcmtlcnMuZmluZCgoY2FuZGlkYXRlKSA9PiBjYW5kaWRhdGUuaWRsZSlcbiAgICAgICAgICB8fCB0aGlzLndvcmtlcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5zaXplKV07XG4gICAgICAgIHdvcmtlci5pZGxlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5tZXNzYWdlSWQrKztcbiAgICAgICAgY29uc3Qgb25NZXNzYWdlID0gKGUpID0+IHtcbiAgICAgICAgICBpZiAoZS5kYXRhLmlkID09PSBpZCkge1xuICAgICAgICAgICAgd29ya2VyLmlkbGUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZShlLmRhdGEuZGVjb2RlZCk7XG4gICAgICAgICAgICB3b3JrZXIud29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd29ya2VyLndvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25NZXNzYWdlKTtcbiAgICAgICAgd29ya2VyLndvcmtlci5wb3N0TWVzc2FnZSh7IGZpbGVEaXJlY3RvcnksIGJ1ZmZlciwgaWQgfSwgW2J1ZmZlcl0pO1xuICAgICAgfSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLndvcmtlcnMpIHtcbiAgICAgIHRoaXMud29ya2Vycy5mb3JFYWNoKCh3b3JrZXIpID0+IHtcbiAgICAgICAgd29ya2VyLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy53b3JrZXJzID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9vbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/pool.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/predictor.js":
/*!*******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/predictor.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyPredictor: function() { return /* binding */ applyPredictor; }\n/* harmony export */ });\nfunction decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nfunction applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3ByZWRpY3Rvci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFO0FBQ0E7QUFDQSxNQUFNLDRCQUE0QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3ByZWRpY3Rvci5qcz9iZWE1Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGRlY29kZVJvd0FjYyhyb3csIHN0cmlkZSkge1xuICBsZXQgbGVuZ3RoID0gcm93Lmxlbmd0aCAtIHN0cmlkZTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGRvIHtcbiAgICBmb3IgKGxldCBpID0gc3RyaWRlOyBpID4gMDsgaS0tKSB7XG4gICAgICByb3dbb2Zmc2V0ICsgc3RyaWRlXSArPSByb3dbb2Zmc2V0XTtcbiAgICAgIG9mZnNldCsrO1xuICAgIH1cblxuICAgIGxlbmd0aCAtPSBzdHJpZGU7XG4gIH0gd2hpbGUgKGxlbmd0aCA+IDApO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVSb3dGbG9hdGluZ1BvaW50KHJvdywgc3RyaWRlLCBieXRlc1BlclNhbXBsZSkge1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgY291bnQgPSByb3cubGVuZ3RoO1xuICBjb25zdCB3YyA9IGNvdW50IC8gYnl0ZXNQZXJTYW1wbGU7XG5cbiAgd2hpbGUgKGNvdW50ID4gc3RyaWRlKSB7XG4gICAgZm9yIChsZXQgaSA9IHN0cmlkZTsgaSA+IDA7IC0taSkge1xuICAgICAgcm93W2luZGV4ICsgc3RyaWRlXSArPSByb3dbaW5kZXhdO1xuICAgICAgKytpbmRleDtcbiAgICB9XG4gICAgY291bnQgLT0gc3RyaWRlO1xuICB9XG5cbiAgY29uc3QgY29weSA9IHJvdy5zbGljZSgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHdjOyArK2kpIHtcbiAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJ5dGVzUGVyU2FtcGxlOyArK2IpIHtcbiAgICAgIHJvd1soYnl0ZXNQZXJTYW1wbGUgKiBpKSArIGJdID0gY29weVsoKGJ5dGVzUGVyU2FtcGxlIC0gYiAtIDEpICogd2MpICsgaV07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVByZWRpY3RvcihibG9jaywgcHJlZGljdG9yLCB3aWR0aCwgaGVpZ2h0LCBiaXRzUGVyU2FtcGxlLFxuICBwbGFuYXJDb25maWd1cmF0aW9uKSB7XG4gIGlmICghcHJlZGljdG9yIHx8IHByZWRpY3RvciA9PT0gMSkge1xuICAgIHJldHVybiBibG9jaztcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYml0c1BlclNhbXBsZS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChiaXRzUGVyU2FtcGxlW2ldICUgOCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaGVuIGRlY29kaW5nIHdpdGggcHJlZGljdG9yLCBvbmx5IG11bHRpcGxlIG9mIDggYml0cyBhcmUgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgICBpZiAoYml0c1BlclNhbXBsZVtpXSAhPT0gYml0c1BlclNhbXBsZVswXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaGVuIGRlY29kaW5nIHdpdGggcHJlZGljdG9yLCBhbGwgc2FtcGxlcyBtdXN0IGhhdmUgdGhlIHNhbWUgc2l6ZS4nKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBieXRlc1BlclNhbXBsZSA9IGJpdHNQZXJTYW1wbGVbMF0gLyA4O1xuICBjb25zdCBzdHJpZGUgPSBwbGFuYXJDb25maWd1cmF0aW9uID09PSAyID8gMSA6IGJpdHNQZXJTYW1wbGUubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyArK2kpIHtcbiAgICAvLyBMYXN0IHN0cmlwIHdpbGwgYmUgdHJ1bmNhdGVkIGlmIGhlaWdodCAlIHN0cmlwSGVpZ2h0ICE9IDBcbiAgICBpZiAoaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUgPj0gYmxvY2suYnl0ZUxlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCByb3c7XG4gICAgaWYgKHByZWRpY3RvciA9PT0gMikgeyAvLyBob3Jpem9udGFsIHByZWRpY3Rpb25cbiAgICAgIHN3aXRjaCAoYml0c1BlclNhbXBsZVswXSkge1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcm93ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICBibG9jaywgaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICByb3cgPSBuZXcgVWludDE2QXJyYXkoXG4gICAgICAgICAgICBibG9jaywgaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUgLyAyLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgcm93ID0gbmV3IFVpbnQzMkFycmF5KFxuICAgICAgICAgICAgYmxvY2ssIGkgKiBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLCBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlIC8gNCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJlZGljdG9yIDIgbm90IGFsbG93ZWQgd2l0aCAke2JpdHNQZXJTYW1wbGVbMF19IGJpdHMgcGVyIHNhbXBsZS5gKTtcbiAgICAgIH1cbiAgICAgIGRlY29kZVJvd0FjYyhyb3csIHN0cmlkZSwgYnl0ZXNQZXJTYW1wbGUpO1xuICAgIH0gZWxzZSBpZiAocHJlZGljdG9yID09PSAzKSB7IC8vIGhvcml6b250YWwgZmxvYXRpbmcgcG9pbnRcbiAgICAgIHJvdyA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICBibG9jaywgaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsXG4gICAgICApO1xuICAgICAgZGVjb2RlUm93RmxvYXRpbmdQb2ludChyb3csIHN0cmlkZSwgYnl0ZXNQZXJTYW1wbGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmxvY2s7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/predictor.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/resample.js":
/*!******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/resample.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resample: function() { return /* binding */ resample; },\n/* harmony export */   resampleBilinear: function() { return /* binding */ resampleBilinear; },\n/* harmony export */   resampleBilinearInterleaved: function() { return /* binding */ resampleBilinearInterleaved; },\n/* harmony export */   resampleInterleaved: function() { return /* binding */ resampleInterleaved; },\n/* harmony export */   resampleNearest: function() { return /* binding */ resampleNearest; },\n/* harmony export */   resampleNearestInterleaved: function() { return /* binding */ resampleNearestInterleaved; }\n/* harmony export */ });\n/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nfunction resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nfunction resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nfunction resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3Jlc2FtcGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxjQUFjO0FBQzNCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxjQUFjO0FBQzNCO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQzs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsY0FBYztBQUMzQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsT0FBTztBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQzs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFlBQVk7QUFDekI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsT0FBTztBQUNoRTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3Jlc2FtcGxlLmpzP2NiYmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIHJlc2FtcGxlXG4gKi9cblxuZnVuY3Rpb24gY29weU5ld1NpemUoYXJyYXksIHdpZHRoLCBoZWlnaHQsIHNhbXBsZXNQZXJQaXhlbCA9IDEpIHtcbiAgcmV0dXJuIG5ldyAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGFycmF5KS5jb25zdHJ1Y3Rvcikod2lkdGggKiBoZWlnaHQgKiBzYW1wbGVzUGVyUGl4ZWwpO1xufVxuXG4vKipcbiAqIFJlc2FtcGxlIHRoZSBpbnB1dCBhcnJheXMgdXNpbmcgbmVhcmVzdCBuZWlnaGJvciB2YWx1ZSBzZWxlY3Rpb24uXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXlbXX0gdmFsdWVBcnJheXMgVGhlIGlucHV0IGFycmF5cyB0byByZXNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5IZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dFdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dEhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcmV0dXJucyB7VHlwZWRBcnJheVtdfSBUaGUgcmVzYW1wbGVkIHJhc3RlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2FtcGxlTmVhcmVzdCh2YWx1ZUFycmF5cywgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQpIHtcbiAgY29uc3QgcmVsWCA9IGluV2lkdGggLyBvdXRXaWR0aDtcbiAgY29uc3QgcmVsWSA9IGluSGVpZ2h0IC8gb3V0SGVpZ2h0O1xuICByZXR1cm4gdmFsdWVBcnJheXMubWFwKChhcnJheSkgPT4ge1xuICAgIGNvbnN0IG5ld0FycmF5ID0gY29weU5ld1NpemUoYXJyYXksIG91dFdpZHRoLCBvdXRIZWlnaHQpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0SGVpZ2h0OyArK3kpIHtcbiAgICAgIGNvbnN0IGN5ID0gTWF0aC5taW4oTWF0aC5yb3VuZChyZWxZICogeSksIGluSGVpZ2h0IC0gMSk7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dFdpZHRoOyArK3gpIHtcbiAgICAgICAgY29uc3QgY3ggPSBNYXRoLm1pbihNYXRoLnJvdW5kKHJlbFggKiB4KSwgaW5XaWR0aCAtIDEpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFycmF5WyhjeSAqIGluV2lkdGgpICsgY3hdO1xuICAgICAgICBuZXdBcnJheVsoeSAqIG91dFdpZHRoKSArIHhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfSk7XG59XG5cbi8vIHNpbXBsZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiwgY29kZSBmcm9tOlxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb24jUHJvZ3JhbW1pbmdfbGFuZ3VhZ2Vfc3VwcG9ydFxuZnVuY3Rpb24gbGVycCh2MCwgdjEsIHQpIHtcbiAgcmV0dXJuICgoMSAtIHQpICogdjApICsgKHQgKiB2MSk7XG59XG5cbi8qKlxuICogUmVzYW1wbGUgdGhlIGlucHV0IGFycmF5cyB1c2luZyBiaWxpbmVhciBpbnRlcnBvbGF0aW9uLlxuICogQHBhcmFtIHtUeXBlZEFycmF5W119IHZhbHVlQXJyYXlzIFRoZSBpbnB1dCBhcnJheXMgdG8gcmVzYW1wbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbldpZHRoIFRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGluSGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRXaWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRIZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHJldHVybnMge1R5cGVkQXJyYXlbXX0gVGhlIHJlc2FtcGxlZCByYXN0ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNhbXBsZUJpbGluZWFyKHZhbHVlQXJyYXlzLCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCkge1xuICBjb25zdCByZWxYID0gaW5XaWR0aCAvIG91dFdpZHRoO1xuICBjb25zdCByZWxZID0gaW5IZWlnaHQgLyBvdXRIZWlnaHQ7XG5cbiAgcmV0dXJuIHZhbHVlQXJyYXlzLm1hcCgoYXJyYXkpID0+IHtcbiAgICBjb25zdCBuZXdBcnJheSA9IGNvcHlOZXdTaXplKGFycmF5LCBvdXRXaWR0aCwgb3V0SGVpZ2h0KTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dEhlaWdodDsgKyt5KSB7XG4gICAgICBjb25zdCByYXdZID0gcmVsWSAqIHk7XG5cbiAgICAgIGNvbnN0IHlsID0gTWF0aC5mbG9vcihyYXdZKTtcbiAgICAgIGNvbnN0IHloID0gTWF0aC5taW4oTWF0aC5jZWlsKHJhd1kpLCAoaW5IZWlnaHQgLSAxKSk7XG5cbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0V2lkdGg7ICsreCkge1xuICAgICAgICBjb25zdCByYXdYID0gcmVsWCAqIHg7XG4gICAgICAgIGNvbnN0IHR4ID0gcmF3WCAlIDE7XG5cbiAgICAgICAgY29uc3QgeGwgPSBNYXRoLmZsb29yKHJhd1gpO1xuICAgICAgICBjb25zdCB4aCA9IE1hdGgubWluKE1hdGguY2VpbChyYXdYKSwgKGluV2lkdGggLSAxKSk7XG5cbiAgICAgICAgY29uc3QgbGwgPSBhcnJheVsoeWwgKiBpbldpZHRoKSArIHhsXTtcbiAgICAgICAgY29uc3QgaGwgPSBhcnJheVsoeWwgKiBpbldpZHRoKSArIHhoXTtcbiAgICAgICAgY29uc3QgbGggPSBhcnJheVsoeWggKiBpbldpZHRoKSArIHhsXTtcbiAgICAgICAgY29uc3QgaGggPSBhcnJheVsoeWggKiBpbldpZHRoKSArIHhoXTtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGxlcnAoXG4gICAgICAgICAgbGVycChsbCwgaGwsIHR4KSxcbiAgICAgICAgICBsZXJwKGxoLCBoaCwgdHgpLFxuICAgICAgICAgIHJhd1kgJSAxLFxuICAgICAgICApO1xuICAgICAgICBuZXdBcnJheVsoeSAqIG91dFdpZHRoKSArIHhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVzYW1wbGUgdGhlIGlucHV0IGFycmF5cyB1c2luZyB0aGUgc2VsZWN0ZWQgcmVzYW1wbGluZyBtZXRob2QuXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXlbXX0gdmFsdWVBcnJheXMgVGhlIGlucHV0IGFycmF5cyB0byByZXNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5IZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dFdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dEhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZCA9ICduZWFyZXN0J10gVGhlIGRlc2lyZWQgcmVzYW1wbGluZyBtZXRob2RcbiAqIEByZXR1cm5zIHtUeXBlZEFycmF5W119IFRoZSByZXNhbXBsZWQgcmFzdGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzYW1wbGUodmFsdWVBcnJheXMsIGluV2lkdGgsIGluSGVpZ2h0LCBvdXRXaWR0aCwgb3V0SGVpZ2h0LCBtZXRob2QgPSAnbmVhcmVzdCcpIHtcbiAgc3dpdGNoIChtZXRob2QudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ25lYXJlc3QnOlxuICAgICAgcmV0dXJuIHJlc2FtcGxlTmVhcmVzdCh2YWx1ZUFycmF5cywgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQpO1xuICAgIGNhc2UgJ2JpbGluZWFyJzpcbiAgICBjYXNlICdsaW5lYXInOlxuICAgICAgcmV0dXJuIHJlc2FtcGxlQmlsaW5lYXIodmFsdWVBcnJheXMsIGluV2lkdGgsIGluSGVpZ2h0LCBvdXRXaWR0aCwgb3V0SGVpZ2h0KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCByZXNhbXBsaW5nIG1ldGhvZDogJyR7bWV0aG9kfSdgKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlc2FtcGxlIHRoZSBwaXhlbCBpbnRlcmxlYXZlZCBpbnB1dCBhcnJheSB1c2luZyBuZWFyZXN0IG5laWdoYm9yIHZhbHVlIHNlbGVjdGlvbi5cbiAqIEBwYXJhbSB7VHlwZWRBcnJheX0gdmFsdWVBcnJheXMgVGhlIGlucHV0IGFycmF5cyB0byByZXNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5IZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dFdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dEhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlcyBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgcGVyIHBpeGVsIGZvciBwaXhlbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJsZWF2ZWQgZGF0YVxuICogQHJldHVybnMge1R5cGVkQXJyYXl9IFRoZSByZXNhbXBsZWQgcmFzdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNhbXBsZU5lYXJlc3RJbnRlcmxlYXZlZChcbiAgdmFsdWVBcnJheSwgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMpIHtcbiAgY29uc3QgcmVsWCA9IGluV2lkdGggLyBvdXRXaWR0aDtcbiAgY29uc3QgcmVsWSA9IGluSGVpZ2h0IC8gb3V0SGVpZ2h0O1xuXG4gIGNvbnN0IG5ld0FycmF5ID0gY29weU5ld1NpemUodmFsdWVBcnJheSwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcyk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0SGVpZ2h0OyArK3kpIHtcbiAgICBjb25zdCBjeSA9IE1hdGgubWluKE1hdGgucm91bmQocmVsWSAqIHkpLCBpbkhlaWdodCAtIDEpO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0V2lkdGg7ICsreCkge1xuICAgICAgY29uc3QgY3ggPSBNYXRoLm1pbihNYXRoLnJvdW5kKHJlbFggKiB4KSwgaW5XaWR0aCAtIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzOyArK2kpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZUFycmF5WyhjeSAqIGluV2lkdGggKiBzYW1wbGVzKSArIChjeCAqIHNhbXBsZXMpICsgaV07XG4gICAgICAgIG5ld0FycmF5Wyh5ICogb3V0V2lkdGggKiBzYW1wbGVzKSArICh4ICogc2FtcGxlcykgKyBpXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3QXJyYXk7XG59XG5cbi8qKlxuICogUmVzYW1wbGUgdGhlIHBpeGVsIGludGVybGVhdmVkIGlucHV0IGFycmF5IHVzaW5nIGJpbGluZWFyIGludGVycG9sYXRpb24uXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9IHZhbHVlQXJyYXlzIFRoZSBpbnB1dCBhcnJheXMgdG8gcmVzYW1wbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbldpZHRoIFRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGluSGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRXaWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRIZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZXMgVGhlIG51bWJlciBvZiBzYW1wbGVzIHBlciBwaXhlbCBmb3IgcGl4ZWxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybGVhdmVkIGRhdGFcbiAqIEByZXR1cm5zIHtUeXBlZEFycmF5fSBUaGUgcmVzYW1wbGVkIHJhc3RlclxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzYW1wbGVCaWxpbmVhckludGVybGVhdmVkKFxuICB2YWx1ZUFycmF5LCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcykge1xuICBjb25zdCByZWxYID0gaW5XaWR0aCAvIG91dFdpZHRoO1xuICBjb25zdCByZWxZID0gaW5IZWlnaHQgLyBvdXRIZWlnaHQ7XG4gIGNvbnN0IG5ld0FycmF5ID0gY29weU5ld1NpemUodmFsdWVBcnJheSwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcyk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0SGVpZ2h0OyArK3kpIHtcbiAgICBjb25zdCByYXdZID0gcmVsWSAqIHk7XG5cbiAgICBjb25zdCB5bCA9IE1hdGguZmxvb3IocmF3WSk7XG4gICAgY29uc3QgeWggPSBNYXRoLm1pbihNYXRoLmNlaWwocmF3WSksIChpbkhlaWdodCAtIDEpKTtcblxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0V2lkdGg7ICsreCkge1xuICAgICAgY29uc3QgcmF3WCA9IHJlbFggKiB4O1xuICAgICAgY29uc3QgdHggPSByYXdYICUgMTtcblxuICAgICAgY29uc3QgeGwgPSBNYXRoLmZsb29yKHJhd1gpO1xuICAgICAgY29uc3QgeGggPSBNYXRoLm1pbihNYXRoLmNlaWwocmF3WCksIChpbldpZHRoIC0gMSkpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXM7ICsraSkge1xuICAgICAgICBjb25zdCBsbCA9IHZhbHVlQXJyYXlbKHlsICogaW5XaWR0aCAqIHNhbXBsZXMpICsgKHhsICogc2FtcGxlcykgKyBpXTtcbiAgICAgICAgY29uc3QgaGwgPSB2YWx1ZUFycmF5Wyh5bCAqIGluV2lkdGggKiBzYW1wbGVzKSArICh4aCAqIHNhbXBsZXMpICsgaV07XG4gICAgICAgIGNvbnN0IGxoID0gdmFsdWVBcnJheVsoeWggKiBpbldpZHRoICogc2FtcGxlcykgKyAoeGwgKiBzYW1wbGVzKSArIGldO1xuICAgICAgICBjb25zdCBoaCA9IHZhbHVlQXJyYXlbKHloICogaW5XaWR0aCAqIHNhbXBsZXMpICsgKHhoICogc2FtcGxlcykgKyBpXTtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGxlcnAoXG4gICAgICAgICAgbGVycChsbCwgaGwsIHR4KSxcbiAgICAgICAgICBsZXJwKGxoLCBoaCwgdHgpLFxuICAgICAgICAgIHJhd1kgJSAxLFxuICAgICAgICApO1xuICAgICAgICBuZXdBcnJheVsoeSAqIG91dFdpZHRoICogc2FtcGxlcykgKyAoeCAqIHNhbXBsZXMpICsgaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG4vKipcbiAqIFJlc2FtcGxlIHRoZSBwaXhlbCBpbnRlcmxlYXZlZCBpbnB1dCBhcnJheSB1c2luZyB0aGUgc2VsZWN0ZWQgcmVzYW1wbGluZyBtZXRob2QuXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9IHZhbHVlQXJyYXkgVGhlIGlucHV0IGFycmF5IHRvIHJlc2FtcGxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5XaWR0aCBUaGUgd2lkdGggb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbkhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0V2lkdGggVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0SGVpZ2h0IFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVzIFRoZSBudW1iZXIgb2Ygc2FtcGxlcyBwZXIgcGl4ZWwgZm9yIHBpeGVsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybGVhdmVkIGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kID0gJ25lYXJlc3QnXSBUaGUgZGVzaXJlZCByZXNhbXBsaW5nIG1ldGhvZFxuICogQHJldHVybnMge1R5cGVkQXJyYXl9IFRoZSByZXNhbXBsZWQgcmFzdGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzYW1wbGVJbnRlcmxlYXZlZCh2YWx1ZUFycmF5LCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcywgbWV0aG9kID0gJ25lYXJlc3QnKSB7XG4gIHN3aXRjaCAobWV0aG9kLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICduZWFyZXN0JzpcbiAgICAgIHJldHVybiByZXNhbXBsZU5lYXJlc3RJbnRlcmxlYXZlZChcbiAgICAgICAgdmFsdWVBcnJheSwgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMsXG4gICAgICApO1xuICAgIGNhc2UgJ2JpbGluZWFyJzpcbiAgICBjYXNlICdsaW5lYXInOlxuICAgICAgcmV0dXJuIHJlc2FtcGxlQmlsaW5lYXJJbnRlcmxlYXZlZChcbiAgICAgICAgdmFsdWVBcnJheSwgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMsXG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHJlc2FtcGxpbmcgbWV0aG9kOiAnJHttZXRob2R9J2ApO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/resample.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/rgb.js":
/*!*************************************************!*\
  !*** ./node_modules/geotiff/dist-module/rgb.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromBlackIsZero: function() { return /* binding */ fromBlackIsZero; },\n/* harmony export */   fromCIELab: function() { return /* binding */ fromCIELab; },\n/* harmony export */   fromCMYK: function() { return /* binding */ fromCMYK; },\n/* harmony export */   fromPalette: function() { return /* binding */ fromPalette; },\n/* harmony export */   fromWhiteIsZero: function() { return /* binding */ fromWhiteIsZero; },\n/* harmony export */   fromYCbCr: function() { return /* binding */ fromYCbCr; }\n/* harmony export */ });\nfunction fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nfunction fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nfunction fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nfunction fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nfunction fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nfunction fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3JnYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBTztBQUNQLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0EseUJBQXlCLHdCQUF3QjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTztBQUNQLFVBQVUsZ0JBQWdCO0FBQzFCOztBQUVBLHlCQUF5Qix5QkFBeUI7QUFDbEQ7QUFDQSxnREFBZ0Q7QUFDaEQsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3JnYi5qcz81OTE2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBmcm9tV2hpdGVJc1plcm8ocmFzdGVyLCBtYXgpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSByYXN0ZXI7XG4gIGNvbnN0IHJnYlJhc3RlciA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogMyk7XG4gIGxldCB2YWx1ZTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgcmFzdGVyLmxlbmd0aDsgKytpLCBqICs9IDMpIHtcbiAgICB2YWx1ZSA9IDI1NiAtIChyYXN0ZXJbaV0gLyBtYXggKiAyNTYpO1xuICAgIHJnYlJhc3RlcltqXSA9IHZhbHVlO1xuICAgIHJnYlJhc3RlcltqICsgMV0gPSB2YWx1ZTtcbiAgICByZ2JSYXN0ZXJbaiArIDJdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJnYlJhc3Rlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21CbGFja0lzWmVybyhyYXN0ZXIsIG1heCkge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHJhc3RlcjtcbiAgY29uc3QgcmdiUmFzdGVyID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiAzKTtcbiAgbGV0IHZhbHVlO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCByYXN0ZXIubGVuZ3RoOyArK2ksIGogKz0gMykge1xuICAgIHZhbHVlID0gcmFzdGVyW2ldIC8gbWF4ICogMjU2O1xuICAgIHJnYlJhc3RlcltqXSA9IHZhbHVlO1xuICAgIHJnYlJhc3RlcltqICsgMV0gPSB2YWx1ZTtcbiAgICByZ2JSYXN0ZXJbaiArIDJdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJnYlJhc3Rlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21QYWxldHRlKHJhc3RlciwgY29sb3JNYXApIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSByYXN0ZXI7XG4gIGNvbnN0IHJnYlJhc3RlciA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogMyk7XG4gIGNvbnN0IGdyZWVuT2Zmc2V0ID0gY29sb3JNYXAubGVuZ3RoIC8gMztcbiAgY29uc3QgYmx1ZU9mZnNldCA9IGNvbG9yTWFwLmxlbmd0aCAvIDMgKiAyO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCByYXN0ZXIubGVuZ3RoOyArK2ksIGogKz0gMykge1xuICAgIGNvbnN0IG1hcEluZGV4ID0gcmFzdGVyW2ldO1xuICAgIHJnYlJhc3RlcltqXSA9IGNvbG9yTWFwW21hcEluZGV4XSAvIDY1NTM2ICogMjU2O1xuICAgIHJnYlJhc3RlcltqICsgMV0gPSBjb2xvck1hcFttYXBJbmRleCArIGdyZWVuT2Zmc2V0XSAvIDY1NTM2ICogMjU2O1xuICAgIHJnYlJhc3RlcltqICsgMl0gPSBjb2xvck1hcFttYXBJbmRleCArIGJsdWVPZmZzZXRdIC8gNjU1MzYgKiAyNTY7XG4gIH1cbiAgcmV0dXJuIHJnYlJhc3Rlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21DTVlLKGNteWtSYXN0ZXIpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjbXlrUmFzdGVyO1xuICBjb25zdCByZ2JSYXN0ZXIgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDMpO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBjbXlrUmFzdGVyLmxlbmd0aDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICBjb25zdCBjID0gY215a1Jhc3RlcltpXTtcbiAgICBjb25zdCBtID0gY215a1Jhc3RlcltpICsgMV07XG4gICAgY29uc3QgeSA9IGNteWtSYXN0ZXJbaSArIDJdO1xuICAgIGNvbnN0IGsgPSBjbXlrUmFzdGVyW2kgKyAzXTtcblxuICAgIHJnYlJhc3RlcltqXSA9IDI1NSAqICgoMjU1IC0gYykgLyAyNTYpICogKCgyNTUgLSBrKSAvIDI1Nik7XG4gICAgcmdiUmFzdGVyW2ogKyAxXSA9IDI1NSAqICgoMjU1IC0gbSkgLyAyNTYpICogKCgyNTUgLSBrKSAvIDI1Nik7XG4gICAgcmdiUmFzdGVyW2ogKyAyXSA9IDI1NSAqICgoMjU1IC0geSkgLyAyNTYpICogKCgyNTUgLSBrKSAvIDI1Nik7XG4gIH1cbiAgcmV0dXJuIHJnYlJhc3Rlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21ZQ2JDcih5Q2JDclJhc3Rlcikge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHlDYkNyUmFzdGVyO1xuICBjb25zdCByZ2JSYXN0ZXIgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQgKiAzKTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgeUNiQ3JSYXN0ZXIubGVuZ3RoOyBpICs9IDMsIGogKz0gMykge1xuICAgIGNvbnN0IHkgPSB5Q2JDclJhc3RlcltpXTtcbiAgICBjb25zdCBjYiA9IHlDYkNyUmFzdGVyW2kgKyAxXTtcbiAgICBjb25zdCBjciA9IHlDYkNyUmFzdGVyW2kgKyAyXTtcblxuICAgIHJnYlJhc3RlcltqXSA9ICh5ICsgKDEuNDAyMDAgKiAoY3IgLSAweDgwKSkpO1xuICAgIHJnYlJhc3RlcltqICsgMV0gPSAoeSAtICgwLjM0NDE0ICogKGNiIC0gMHg4MCkpIC0gKDAuNzE0MTQgKiAoY3IgLSAweDgwKSkpO1xuICAgIHJnYlJhc3RlcltqICsgMl0gPSAoeSArICgxLjc3MjAwICogKGNiIC0gMHg4MCkpKTtcbiAgfVxuICByZXR1cm4gcmdiUmFzdGVyO1xufVxuXG5jb25zdCBYbiA9IDAuOTUwNDc7XG5jb25zdCBZbiA9IDEuMDAwMDA7XG5jb25zdCBabiA9IDEuMDg4ODM7XG5cbi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FudGltYXR0ZXIxNS9yZ2ItbGFiL2Jsb2IvbWFzdGVyL2NvbG9yLmpzXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQ0lFTGFiKGNpZUxhYlJhc3Rlcikge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNpZUxhYlJhc3RlcjtcbiAgY29uc3QgcmdiUmFzdGVyID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiAzKTtcblxuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBjaWVMYWJSYXN0ZXIubGVuZ3RoOyBpICs9IDMsIGogKz0gMykge1xuICAgIGNvbnN0IEwgPSBjaWVMYWJSYXN0ZXJbaSArIDBdO1xuICAgIGNvbnN0IGFfID0gY2llTGFiUmFzdGVyW2kgKyAxXSA8PCAyNCA+PiAyNDsgLy8gY29udmVyc2lvbiBmcm9tIHVpbnQ4IHRvIGludDhcbiAgICBjb25zdCBiXyA9IGNpZUxhYlJhc3RlcltpICsgMl0gPDwgMjQgPj4gMjQ7IC8vIHNhbWVcblxuICAgIGxldCB5ID0gKEwgKyAxNikgLyAxMTY7XG4gICAgbGV0IHggPSAoYV8gLyA1MDApICsgeTtcbiAgICBsZXQgeiA9IHkgLSAoYl8gLyAyMDApO1xuICAgIGxldCByO1xuICAgIGxldCBnO1xuICAgIGxldCBiO1xuXG4gICAgeCA9IFhuICogKCh4ICogeCAqIHggPiAwLjAwODg1NikgPyB4ICogeCAqIHggOiAoeCAtICgxNiAvIDExNikpIC8gNy43ODcpO1xuICAgIHkgPSBZbiAqICgoeSAqIHkgKiB5ID4gMC4wMDg4NTYpID8geSAqIHkgKiB5IDogKHkgLSAoMTYgLyAxMTYpKSAvIDcuNzg3KTtcbiAgICB6ID0gWm4gKiAoKHogKiB6ICogeiA+IDAuMDA4ODU2KSA/IHogKiB6ICogeiA6ICh6IC0gKDE2IC8gMTE2KSkgLyA3Ljc4Nyk7XG5cbiAgICByID0gKHggKiAzLjI0MDYpICsgKHkgKiAtMS41MzcyKSArICh6ICogLTAuNDk4Nik7XG4gICAgZyA9ICh4ICogLTAuOTY4OSkgKyAoeSAqIDEuODc1OCkgKyAoeiAqIDAuMDQxNSk7XG4gICAgYiA9ICh4ICogMC4wNTU3KSArICh5ICogLTAuMjA0MCkgKyAoeiAqIDEuMDU3MCk7XG5cbiAgICByID0gKHIgPiAwLjAwMzEzMDgpID8gKCgxLjA1NSAqIChyICoqICgxIC8gMi40KSkpIC0gMC4wNTUpIDogMTIuOTIgKiByO1xuICAgIGcgPSAoZyA+IDAuMDAzMTMwOCkgPyAoKDEuMDU1ICogKGcgKiogKDEgLyAyLjQpKSkgLSAwLjA1NSkgOiAxMi45MiAqIGc7XG4gICAgYiA9IChiID4gMC4wMDMxMzA4KSA/ICgoMS4wNTUgKiAoYiAqKiAoMSAvIDIuNCkpKSAtIDAuMDU1KSA6IDEyLjkyICogYjtcblxuICAgIHJnYlJhc3RlcltqXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHIpKSAqIDI1NTtcbiAgICByZ2JSYXN0ZXJbaiArIDFdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgZykpICogMjU1O1xuICAgIHJnYlJhc3RlcltqICsgMl0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBiKSkgKiAyNTU7XG4gIH1cbiAgcmV0dXJuIHJnYlJhc3Rlcjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/rgb.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/arraybuffer.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/arraybuffer.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeBufferSource: function() { return /* binding */ makeBufferSource; }\n/* harmony export */ });\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/utils.js\");\n\n\n\nclass ArrayBufferSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource {\n  constructor(arrayBuffer) {\n    super();\n    this.arrayBuffer = arrayBuffer;\n  }\n\n  fetchSlice(slice, signal) {\n    if (signal && signal.aborted) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_1__.AbortError('Request aborted');\n    }\n    return this.arrayBuffer.slice(slice.offset, slice.offset + slice.length);\n  }\n}\n\nfunction makeBufferSource(arrayBuffer) {\n  return new ArrayBufferSource(arrayBuffer);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9hcnJheWJ1ZmZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkM7QUFDSjs7QUFFekMsZ0NBQWdDLHNEQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9hcnJheWJ1ZmZlci5qcz9mMjk5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VTb3VyY2UgfSBmcm9tICcuL2Jhc2Vzb3VyY2UuanMnO1xuaW1wb3J0IHsgQWJvcnRFcnJvciB9IGZyb20gJy4uL3V0aWxzLmpzJztcblxuY2xhc3MgQXJyYXlCdWZmZXJTb3VyY2UgZXh0ZW5kcyBCYXNlU291cmNlIHtcbiAgY29uc3RydWN0b3IoYXJyYXlCdWZmZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBhcnJheUJ1ZmZlcjtcbiAgfVxuXG4gIGZldGNoU2xpY2Uoc2xpY2UsIHNpZ25hbCkge1xuICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlCdWZmZXIuc2xpY2Uoc2xpY2Uub2Zmc2V0LCBzbGljZS5vZmZzZXQgKyBzbGljZS5sZW5ndGgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQnVmZmVyU291cmNlKGFycmF5QnVmZmVyKSB7XG4gIHJldHVybiBuZXcgQXJyYXlCdWZmZXJTb3VyY2UoYXJyYXlCdWZmZXIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/arraybuffer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/basesource.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/basesource.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseSource: function() { return /* binding */ BaseSource; }\n/* harmony export */ });\n/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nclass BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9iYXNlc291cmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFTztBQUNQO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9iYXNlc291cmNlLmpzPzIyOGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiBTbGljZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlbmd0aFxuICovXG5cbmV4cG9ydCBjbGFzcyBCYXNlU291cmNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U2xpY2VbXX0gc2xpY2VzXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcltdfVxuICAgKi9cbiAgYXN5bmMgZmV0Y2goc2xpY2VzLCBzaWduYWwgPSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICBzbGljZXMubWFwKChzbGljZSkgPT4gdGhpcy5mZXRjaFNsaWNlKHNsaWNlLCBzaWduYWwpKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U2xpY2V9IHNsaWNlXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn1cbiAgICovXG4gIGFzeW5jIGZldGNoU2xpY2Uoc2xpY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGZldGNoaW5nIG9mIHNsaWNlICR7c2xpY2V9IG5vdCBwb3NzaWJsZSwgbm90IGltcGxlbWVudGVkYCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlsZXNpemUgaWYgYWxyZWFkeSBkZXRlcm1pbmVkIGFuZCBudWxsIG90aGVyd2lzZVxuICAgKi9cbiAgZ2V0IGZpbGVTaXplKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgLy8gbm8tb3AgYnkgZGVmYXVsdFxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/basesource.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/blockedsource.js":
/*!******************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/blockedsource.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockedSource: function() { return /* binding */ BlockedSource; }\n/* harmony export */ });\n/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! quick-lru */ \"(app-pages-browser)/./node_modules/quick-lru/index.js\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basesource.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/utils.js\");\n\n\n\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nclass BlockedSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_1__.BaseSource {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new quick_lru__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      },\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wait)();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_2__.AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_2__.AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.zip)(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9ibG9ja2Vkc291cmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUM7QUFDWTtBQUN1Qjs7QUFFcEU7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sNEJBQTRCLHNEQUFVO0FBQzdDO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSx3QkFBd0IscUNBQXFDLElBQUk7QUFDakU7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixpREFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTCxlQUFlLG9CQUFvQjtBQUNuQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDOztBQUVBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkNBQTJDLGVBQWU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsK0NBQUk7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQVU7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFjO0FBQzlCOztBQUVBO0FBQ0EsbUNBQW1DLDhDQUFHOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0JBQStCLDRCQUE0QjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxnQ0FBZ0M7QUFDN0MsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLHdCQUF3QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYmxvY2tlZHNvdXJjZS5qcz83MzJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBRdWlja0xSVSBmcm9tICdxdWljay1scnUnO1xuaW1wb3J0IHsgQmFzZVNvdXJjZSB9IGZyb20gJy4vYmFzZXNvdXJjZS5qcyc7XG5pbXBvcnQgeyBBYm9ydEVycm9yLCBBZ2dyZWdhdGVFcnJvciwgd2FpdCwgemlwIH0gZnJvbSAnLi4vdXRpbHMuanMnO1xuXG5jbGFzcyBCbG9jayB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gW2RhdGFdXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvZmZzZXQsIGxlbmd0aCwgZGF0YSA9IG51bGwpIHtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSB0b3AgYnl0ZSBib3JkZXJcbiAgICovXG4gIGdldCB0b3AoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0ICsgdGhpcy5sZW5ndGg7XG4gIH1cbn1cblxuY2xhc3MgQmxvY2tHcm91cCB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gYmxvY2tJZHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9mZnNldCwgbGVuZ3RoLCBibG9ja0lkcykge1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuYmxvY2tJZHMgPSBibG9ja0lkcztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmxvY2tlZFNvdXJjZSBleHRlbmRzIEJhc2VTb3VyY2Uge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtCYXNlU291cmNlfSBzb3VyY2UgVGhlIHVuZGVybHlpbmcgc291cmNlIHRoYXQgc2hhbGwgYmUgYmxvY2tlZCBhbmQgY2FjaGVkXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5ibG9ja1NpemVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jYWNoZVNpemVdXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHsgYmxvY2tTaXplID0gNjU1MzYsIGNhY2hlU2l6ZSA9IDEwMCB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuYmxvY2tTaXplID0gYmxvY2tTaXplO1xuXG4gICAgdGhpcy5ibG9ja0NhY2hlID0gbmV3IFF1aWNrTFJVKHtcbiAgICAgIG1heFNpemU6IGNhY2hlU2l6ZSxcbiAgICAgIG9uRXZpY3Rpb246IChibG9ja0lkLCBibG9jaykgPT4ge1xuICAgICAgICB0aGlzLmV2aWN0ZWRCbG9ja3Muc2V0KGJsb2NrSWQsIGJsb2NrKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvKiogQHR5cGUge01hcDxudW1iZXIsIEJsb2NrPn0gKi9cbiAgICB0aGlzLmV2aWN0ZWRCbG9ja3MgPSBuZXcgTWFwKCk7XG5cbiAgICAvLyBtYXBwaW5nIGJsb2NrSWQgLT4gQmxvY2sgaW5zdGFuY2VcbiAgICB0aGlzLmJsb2NrUmVxdWVzdHMgPSBuZXcgTWFwKCk7XG5cbiAgICAvLyBzZXQgb2YgYmxvY2tJZHMgbWlzc2luZyBmb3IgdGhlIGN1cnJlbnQgcmVxdWVzdHNcbiAgICB0aGlzLmJsb2NrSWRzVG9GZXRjaCA9IG5ldyBTZXQoKTtcblxuICAgIHRoaXMuYWJvcnRlZEJsb2NrSWRzID0gbmV3IFNldCgpO1xuICB9XG5cbiAgZ2V0IGZpbGVTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5maWxlU2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vYmFzZXNvdXJjZVwiKS5TbGljZVtdfSBzbGljZXNcbiAgICovXG4gIGFzeW5jIGZldGNoKHNsaWNlcywgc2lnbmFsKSB7XG4gICAgY29uc3QgYmxvY2tSZXF1ZXN0cyA9IFtdO1xuICAgIGNvbnN0IG1pc3NpbmdCbG9ja0lkcyA9IFtdO1xuICAgIGNvbnN0IGFsbEJsb2NrSWRzID0gW107XG4gICAgdGhpcy5ldmljdGVkQmxvY2tzLmNsZWFyKCk7XG5cbiAgICBmb3IgKGNvbnN0IHsgb2Zmc2V0LCBsZW5ndGggfSBvZiBzbGljZXMpIHtcbiAgICAgIGxldCB0b3AgPSBvZmZzZXQgKyBsZW5ndGg7XG5cbiAgICAgIGNvbnN0IHsgZmlsZVNpemUgfSA9IHRoaXM7XG4gICAgICBpZiAoZmlsZVNpemUgIT09IG51bGwpIHtcbiAgICAgICAgdG9wID0gTWF0aC5taW4odG9wLCBmaWxlU2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpcnN0QmxvY2tPZmZzZXQgPSBNYXRoLmZsb29yKG9mZnNldCAvIHRoaXMuYmxvY2tTaXplKSAqIHRoaXMuYmxvY2tTaXplO1xuXG4gICAgICBmb3IgKGxldCBjdXJyZW50ID0gZmlyc3RCbG9ja09mZnNldDsgY3VycmVudCA8IHRvcDsgY3VycmVudCArPSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICBjb25zdCBibG9ja0lkID0gTWF0aC5mbG9vcihjdXJyZW50IC8gdGhpcy5ibG9ja1NpemUpO1xuICAgICAgICBpZiAoIXRoaXMuYmxvY2tDYWNoZS5oYXMoYmxvY2tJZCkgJiYgIXRoaXMuYmxvY2tSZXF1ZXN0cy5oYXMoYmxvY2tJZCkpIHtcbiAgICAgICAgICB0aGlzLmJsb2NrSWRzVG9GZXRjaC5hZGQoYmxvY2tJZCk7XG4gICAgICAgICAgbWlzc2luZ0Jsb2NrSWRzLnB1c2goYmxvY2tJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYmxvY2tSZXF1ZXN0cy5oYXMoYmxvY2tJZCkpIHtcbiAgICAgICAgICBibG9ja1JlcXVlc3RzLnB1c2godGhpcy5ibG9ja1JlcXVlc3RzLmdldChibG9ja0lkKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWxsQmxvY2tJZHMucHVzaChibG9ja0lkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbGxvdyBhZGRpdGlvbmFsIGJsb2NrIHJlcXVlc3RzIHRvIGFjY3VtdWxhdGVcbiAgICBhd2FpdCB3YWl0KCk7XG4gICAgdGhpcy5mZXRjaEJsb2NrcyhzaWduYWwpO1xuXG4gICAgLy8gR2F0aGVyIGFsbCBvZiB0aGUgbmV3IHJlcXVlc3RzIHRoYXQgdGhpcyBmZXRjaCBjYWxsIGlzIGNvbnRyaWJ1dGluZyB0byBgZmV0Y2hgLlxuICAgIGNvbnN0IG1pc3NpbmdSZXF1ZXN0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgYmxvY2tJZCBvZiBtaXNzaW5nQmxvY2tJZHMpIHtcbiAgICAgIC8vIFRoZSByZXF1ZXN0ZWQgbWlzc2luZyBibG9jayBjb3VsZCBhbHJlYWR5IGJlIGluIHRoZSBjYWNoZVxuICAgICAgLy8gaW5zdGVhZCBvZiBoYXZpbmcgaXRzIHJlcXVlc3Qgc3RpbGwgYmUgb3V0c3RhbmRpbmcuXG4gICAgICBpZiAodGhpcy5ibG9ja1JlcXVlc3RzLmhhcyhibG9ja0lkKSkge1xuICAgICAgICBtaXNzaW5nUmVxdWVzdHMucHVzaCh0aGlzLmJsb2NrUmVxdWVzdHMuZ2V0KGJsb2NrSWQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBY3R1YWxseSBhd2FpdCBhbGwgcGVuZGluZyByZXF1ZXN0cyB0aGF0IGFyZSBuZWVkZWQgZm9yIHRoaXMgYGZldGNoYC5cbiAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoYmxvY2tSZXF1ZXN0cyk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKG1pc3NpbmdSZXF1ZXN0cyk7XG5cbiAgICAvLyBQZXJmb3JtIHJldHJpZXMgaWYgYSBibG9jayB3YXMgaW50ZXJydXB0ZWQgYnkgYSBwcmV2aW91cyBzaWduYWxcbiAgICBjb25zdCBhYm9ydGVkQmxvY2tSZXF1ZXN0cyA9IFtdO1xuICAgIGNvbnN0IGFib3J0ZWRCbG9ja0lkcyA9IGFsbEJsb2NrSWRzXG4gICAgICAuZmlsdGVyKChpZCkgPT4gdGhpcy5hYm9ydGVkQmxvY2tJZHMuaGFzKGlkKSB8fCAhdGhpcy5ibG9ja0NhY2hlLmhhcyhpZCkpO1xuICAgIGFib3J0ZWRCbG9ja0lkcy5mb3JFYWNoKChpZCkgPT4gdGhpcy5ibG9ja0lkc1RvRmV0Y2guYWRkKGlkKSk7XG4gICAgLy8gc3RhcnQgdGhlIHJldHJ5IG9mIHNvbWUgYmxvY2tzIGlmIHJlcXVpcmVkXG4gICAgaWYgKGFib3J0ZWRCbG9ja0lkcy5sZW5ndGggPiAwICYmIHNpZ25hbCAmJiAhc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRoaXMuZmV0Y2hCbG9ja3MobnVsbCk7XG4gICAgICBmb3IgKGNvbnN0IGJsb2NrSWQgb2YgYWJvcnRlZEJsb2NrSWRzKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5ibG9ja1JlcXVlc3RzLmdldChibG9ja0lkKTtcbiAgICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmxvY2sgJHtibG9ja0lkfSBpcyBub3QgaW4gdGhlIGJsb2NrIHJlcXVlc3RzYCk7XG4gICAgICAgIH1cbiAgICAgICAgYWJvcnRlZEJsb2NrUmVxdWVzdHMucHVzaChibG9jayk7XG4gICAgICB9XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoYWJvcnRlZEJsb2NrUmVxdWVzdHMpO1xuICAgIH1cblxuICAgIC8vIHRocm93IGFuICBhYm9ydCBlcnJvclxuICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKCdSZXF1ZXN0IHdhcyBhYm9ydGVkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYmxvY2tzID0gYWxsQmxvY2tJZHMubWFwKChpZCkgPT4gdGhpcy5ibG9ja0NhY2hlLmdldChpZCkgfHwgdGhpcy5ldmljdGVkQmxvY2tzLmdldChpZCkpO1xuICAgIGNvbnN0IGZhaWxlZEJsb2NrcyA9IGJsb2Nrcy5maWx0ZXIoKGkpID0+ICFpKTtcbiAgICBpZiAoZmFpbGVkQmxvY2tzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEFnZ3JlZ2F0ZUVycm9yKGZhaWxlZEJsb2NrcywgJ1JlcXVlc3QgZmFpbGVkJyk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGEgZmluYWwgTWFwLCB3aXRoIGFsbCByZXF1aXJlZCBibG9ja3MgZm9yIHRoaXMgcmVxdWVzdCB0byBzYXRpc2Z5XG4gICAgY29uc3QgcmVxdWlyZWRCbG9ja3MgPSBuZXcgTWFwKHppcChhbGxCbG9ja0lkcywgYmxvY2tzKSk7XG5cbiAgICAvLyBUT0RPOiBzYXRpc2Z5IGVhY2ggc2xpY2VcbiAgICByZXR1cm4gdGhpcy5yZWFkU2xpY2VEYXRhKHNsaWNlcywgcmVxdWlyZWRCbG9ja3MpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IHNpZ25hbFxuICAgKi9cbiAgZmV0Y2hCbG9ja3Moc2lnbmFsKSB7XG4gICAgLy8gY2hlY2sgaWYgd2Ugc3RpbGwgbmVlZCB0b1xuICAgIGlmICh0aGlzLmJsb2NrSWRzVG9GZXRjaC5zaXplID4gMCkge1xuICAgICAgY29uc3QgZ3JvdXBzID0gdGhpcy5ncm91cEJsb2Nrcyh0aGlzLmJsb2NrSWRzVG9GZXRjaCk7XG5cbiAgICAgIC8vIHN0YXJ0IHJlcXVlc3Rpbmcgc2xpY2VzIG9mIGRhdGFcbiAgICAgIGNvbnN0IGdyb3VwUmVxdWVzdHMgPSB0aGlzLnNvdXJjZS5mZXRjaChncm91cHMsIHNpZ25hbCk7XG5cbiAgICAgIGZvciAobGV0IGdyb3VwSW5kZXggPSAwOyBncm91cEluZGV4IDwgZ3JvdXBzLmxlbmd0aDsgKytncm91cEluZGV4KSB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBzW2dyb3VwSW5kZXhdO1xuXG4gICAgICAgIGZvciAoY29uc3QgYmxvY2tJZCBvZiBncm91cC5ibG9ja0lkcykge1xuICAgICAgICAgIC8vIG1ha2UgYW4gYXN5bmMgSUlGRSBmb3IgZWFjaCBibG9ja1xuICAgICAgICAgIHRoaXMuYmxvY2tSZXF1ZXN0cy5zZXQoYmxvY2tJZCwgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IGdyb3VwUmVxdWVzdHMpW2dyb3VwSW5kZXhdO1xuICAgICAgICAgICAgICBjb25zdCBibG9ja09mZnNldCA9IGJsb2NrSWQgKiB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgICAgICAgICAgY29uc3QgbyA9IGJsb2NrT2Zmc2V0IC0gcmVzcG9uc2Uub2Zmc2V0O1xuICAgICAgICAgICAgICBjb25zdCB0ID0gTWF0aC5taW4obyArIHRoaXMuYmxvY2tTaXplLCByZXNwb25zZS5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YS5zbGljZShvLCB0KTtcbiAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBuZXcgQmxvY2soXG4gICAgICAgICAgICAgICAgYmxvY2tPZmZzZXQsXG4gICAgICAgICAgICAgICAgZGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgYmxvY2tJZCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdGhpcy5ibG9ja0NhY2hlLnNldChibG9ja0lkLCBibG9jayk7XG4gICAgICAgICAgICAgIHRoaXMuYWJvcnRlZEJsb2NrSWRzLmRlbGV0ZShibG9ja0lkKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBpZiAoZXJyLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBzaWduYWwgaGVyZSwgd2UgbmVlZCBpdCB0byBkZXRlcm1pbmUgbGF0ZXIgaWYgYW5cbiAgICAgICAgICAgICAgICAvLyBlcnJvciB3YXMgY2F1c2VkIGJ5IHRoaXMgc2lnbmFsXG4gICAgICAgICAgICAgICAgZXJyLnNpZ25hbCA9IHNpZ25hbDtcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NrQ2FjaGUuZGVsZXRlKGJsb2NrSWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRlZEJsb2NrSWRzLmFkZChibG9ja0lkKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHRoaXMuYmxvY2tSZXF1ZXN0cy5kZWxldGUoYmxvY2tJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYmxvY2tJZHNUb0ZldGNoLmNsZWFyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U2V0fSBibG9ja0lkc1xuICAgKiBAcmV0dXJucyB7QmxvY2tHcm91cFtdfVxuICAgKi9cbiAgZ3JvdXBCbG9ja3MoYmxvY2tJZHMpIHtcbiAgICBjb25zdCBzb3J0ZWRCbG9ja0lkcyA9IEFycmF5LmZyb20oYmxvY2tJZHMpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICBpZiAoc29ydGVkQmxvY2tJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCBjdXJyZW50ID0gW107XG4gICAgbGV0IGxhc3RCbG9ja0lkID0gbnVsbDtcbiAgICBjb25zdCBncm91cHMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgYmxvY2tJZCBvZiBzb3J0ZWRCbG9ja0lkcykge1xuICAgICAgaWYgKGxhc3RCbG9ja0lkID09PSBudWxsIHx8IGxhc3RCbG9ja0lkICsgMSA9PT0gYmxvY2tJZCkge1xuICAgICAgICBjdXJyZW50LnB1c2goYmxvY2tJZCk7XG4gICAgICAgIGxhc3RCbG9ja0lkID0gYmxvY2tJZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyb3Vwcy5wdXNoKG5ldyBCbG9ja0dyb3VwKFxuICAgICAgICAgIGN1cnJlbnRbMF0gKiB0aGlzLmJsb2NrU2l6ZSxcbiAgICAgICAgICBjdXJyZW50Lmxlbmd0aCAqIHRoaXMuYmxvY2tTaXplLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICkpO1xuICAgICAgICBjdXJyZW50ID0gW2Jsb2NrSWRdO1xuICAgICAgICBsYXN0QmxvY2tJZCA9IGJsb2NrSWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ3JvdXBzLnB1c2gobmV3IEJsb2NrR3JvdXAoXG4gICAgICBjdXJyZW50WzBdICogdGhpcy5ibG9ja1NpemUsXG4gICAgICBjdXJyZW50Lmxlbmd0aCAqIHRoaXMuYmxvY2tTaXplLFxuICAgICAgY3VycmVudCxcbiAgICApKTtcblxuICAgIHJldHVybiBncm91cHM7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Jhc2Vzb3VyY2VcIikuU2xpY2VbXX0gc2xpY2VzXG4gICAqIEBwYXJhbSB7TWFwfSBibG9ja3NcbiAgICovXG4gIHJlYWRTbGljZURhdGEoc2xpY2VzLCBibG9ja3MpIHtcbiAgICByZXR1cm4gc2xpY2VzLm1hcCgoc2xpY2UpID0+IHtcbiAgICAgIGxldCB0b3AgPSBzbGljZS5vZmZzZXQgKyBzbGljZS5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5maWxlU2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICB0b3AgPSBNYXRoLm1pbih0aGlzLmZpbGVTaXplLCB0b3ApO1xuICAgICAgfVxuICAgICAgY29uc3QgYmxvY2tJZExvdyA9IE1hdGguZmxvb3Ioc2xpY2Uub2Zmc2V0IC8gdGhpcy5ibG9ja1NpemUpO1xuICAgICAgY29uc3QgYmxvY2tJZEhpZ2ggPSBNYXRoLmZsb29yKHRvcCAvIHRoaXMuYmxvY2tTaXplKTtcbiAgICAgIGNvbnN0IHNsaWNlRGF0YSA9IG5ldyBBcnJheUJ1ZmZlcihzbGljZS5sZW5ndGgpO1xuICAgICAgY29uc3Qgc2xpY2VWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoc2xpY2VEYXRhKTtcblxuICAgICAgZm9yIChsZXQgYmxvY2tJZCA9IGJsb2NrSWRMb3c7IGJsb2NrSWQgPD0gYmxvY2tJZEhpZ2g7ICsrYmxvY2tJZCkge1xuICAgICAgICBjb25zdCBibG9jayA9IGJsb2Nrcy5nZXQoYmxvY2tJZCk7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gYmxvY2sub2Zmc2V0IC0gc2xpY2Uub2Zmc2V0O1xuICAgICAgICBjb25zdCB0b3BEZWx0YSA9IGJsb2NrLnRvcCAtIHRvcDtcbiAgICAgICAgbGV0IGJsb2NrSW5uZXJPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgcmFuZ2VJbm5lck9mZnNldCA9IDA7XG4gICAgICAgIGxldCB1c2VkQmxvY2tMZW5ndGg7XG5cbiAgICAgICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgIGJsb2NrSW5uZXJPZmZzZXQgPSAtZGVsdGE7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgcmFuZ2VJbm5lck9mZnNldCA9IGRlbHRhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvcERlbHRhIDwgMCkge1xuICAgICAgICAgIHVzZWRCbG9ja0xlbmd0aCA9IGJsb2NrLmxlbmd0aCAtIGJsb2NrSW5uZXJPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXNlZEJsb2NrTGVuZ3RoID0gdG9wIC0gYmxvY2sub2Zmc2V0IC0gYmxvY2tJbm5lck9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJsb2NrVmlldyA9IG5ldyBVaW50OEFycmF5KGJsb2NrLmRhdGEsIGJsb2NrSW5uZXJPZmZzZXQsIHVzZWRCbG9ja0xlbmd0aCk7XG4gICAgICAgIHNsaWNlVmlldy5zZXQoYmxvY2tWaWV3LCByYW5nZUlubmVyT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNsaWNlRGF0YTtcbiAgICB9KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/blockedsource.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/base.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/base.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseClient: function() { return /* binding */ BaseClient; },\n/* harmony export */   BaseResponse: function() { return /* binding */ BaseResponse; }\n/* harmony export */ });\nclass BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nclass BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<BaseResponse>}\n   */\n  async request({ headers, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9jbGllbnQvYmFzZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsNENBQTRDLFdBQVc7QUFDckUsZUFBZTtBQUNmO0FBQ0Esa0JBQWtCLGtCQUFrQixJQUFJLElBQUk7QUFDNUM7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9jbGllbnQvYmFzZS5qcz9kZjZmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBCYXNlUmVzcG9uc2Uge1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSByZXNwb25zZSBoYXMgYW4gb2snaXNoIHN0YXR1cyBjb2RlXG4gICAqL1xuICBnZXQgb2soKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8PSAyOTk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhdHVzIGNvZGUgb2YgdGhlIHJlc3BvbnNlXG4gICAqL1xuICBnZXQgc3RhdHVzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBoZWFkZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlck5hbWUgdGhlIGhlYWRlciBuYW1lXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBoZWFkZXIgdmFsdWVcbiAgICovXG4gIGdldEhlYWRlcihoZWFkZXJOYW1lKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gdGhlIHJlc3BvbnNlIGRhdGEgb2YgdGhlIHJlcXVlc3RcbiAgICovXG4gIGFzeW5jIGdldERhdGEoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmFzZUNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKHVybCkge1xuICAgIHRoaXMudXJsID0gdXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSByZXF1ZXN0IHdpdGggdGhlIG9wdGlvbnNcbiAgICogQHBhcmFtIHt7aGVhZGVyczogSGVhZGVyc0luaXQsIHNpZ25hbDogQWJvcnRTaWduYWx9fSBbb3B0aW9ucz17fV1cbiAgICogQHJldHVybnMge1Byb21pc2U8QmFzZVJlc3BvbnNlPn1cbiAgICovXG4gIGFzeW5jIHJlcXVlc3QoeyBoZWFkZXJzLCBzaWduYWwgfSA9IHt9KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVlc3QgaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/base.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/fetch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/fetch.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchClient: function() { return /* binding */ FetchClient; }\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/base.js\");\n\n\nclass FetchResponse extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nclass FetchClient extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  /**\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<FetchResponse>}\n   */\n  async request({ headers, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials: this.credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9jbGllbnQvZmV0Y2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUQ7O0FBRXJELDRCQUE0QixrREFBWTtBQUN4QztBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTywwQkFBMEIsZ0RBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDRDQUE0QyxXQUFXO0FBQ3JFLGVBQWU7QUFDZjtBQUNBLGtCQUFrQixrQkFBa0IsSUFBSTtBQUN4QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2ZldGNoLmpzPzI5ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNsaWVudCwgQmFzZVJlc3BvbnNlIH0gZnJvbSAnLi9iYXNlLmpzJztcblxuY2xhc3MgRmV0Y2hSZXNwb25zZSBleHRlbmRzIEJhc2VSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBCYXNlUmVzcG9uc2UgZmFjYWRlIGZvciBmZXRjaCBBUEkgUmVzcG9uc2VcbiAgICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIH1cblxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLnN0YXR1cztcbiAgfVxuXG4gIGdldEhlYWRlcihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2UuaGVhZGVycy5nZXQobmFtZSk7XG4gIH1cblxuICBhc3luYyBnZXREYXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3BvbnNlLmFycmF5QnVmZmVyXG4gICAgICA/IGF3YWl0IHRoaXMucmVzcG9uc2UuYXJyYXlCdWZmZXIoKVxuICAgICAgOiAoYXdhaXQgdGhpcy5yZXNwb25zZS5idWZmZXIoKSkuYnVmZmVyO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBGZXRjaENsaWVudCBleHRlbmRzIEJhc2VDbGllbnQge1xuICBjb25zdHJ1Y3Rvcih1cmwsIGNyZWRlbnRpYWxzKSB7XG4gICAgc3VwZXIodXJsKTtcbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHt7aGVhZGVyczogSGVhZGVyc0luaXQsIHNpZ25hbDogQWJvcnRTaWduYWx9fSBbb3B0aW9ucz17fV1cbiAgICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hSZXNwb25zZT59XG4gICAqL1xuICBhc3luYyByZXF1ZXN0KHsgaGVhZGVycywgc2lnbmFsIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy51cmwsIHtcbiAgICAgIGhlYWRlcnMsIGNyZWRlbnRpYWxzOiB0aGlzLmNyZWRlbnRpYWxzLCBzaWduYWwsXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBGZXRjaFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/fetch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/http.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/http.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpClient: function() { return /* binding */ HttpClient; }\n/* harmony export */ });\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ \"?b5cf\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ \"?69f2\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ \"(app-pages-browser)/./node_modules/next/dist/compiled/native-url/index.js\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/utils.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\n\n\n\n\nclass HttpResponse extends _base_js__WEBPACK_IMPORTED_MODULE_3__.BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nclass HttpClient extends _base_js__WEBPACK_IMPORTED_MODULE_3__.BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = url__WEBPACK_IMPORTED_MODULE_2__.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http__WEBPACK_IMPORTED_MODULE_0__ : https__WEBPACK_IMPORTED_MODULE_1__);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new _utils_js__WEBPACK_IMPORTED_MODULE_4__.AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new _utils_js__WEBPACK_IMPORTED_MODULE_4__.AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9jbGllbnQvaHR0cC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXdCO0FBQ0U7QUFDRDs7QUFFNEI7QUFDVDs7QUFFNUMsMkJBQTJCLGtEQUFZO0FBQ3ZDO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLHlCQUF5QixnREFBVTtBQUMxQztBQUNBO0FBQ0EscUJBQXFCLHNDQUFZO0FBQ2pDLDBEQUEwRCxpQ0FBSSxHQUFHLGtDQUFLO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakM7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLGlEQUFVO0FBQ3hDO0FBQ0EsbUVBQW1FLGlEQUFVO0FBQzdFO0FBQ0EsS0FBSztBQUNMOztBQUVBLGtCQUFrQixrQkFBa0IsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2h0dHAuanM/Njc4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaHR0cCBmcm9tICdodHRwJztcbmltcG9ydCBodHRwcyBmcm9tICdodHRwcyc7XG5pbXBvcnQgdXJsTW9kIGZyb20gJ3VybCc7XG5cbmltcG9ydCB7IEJhc2VDbGllbnQsIEJhc2VSZXNwb25zZSB9IGZyb20gJy4vYmFzZS5qcyc7XG5pbXBvcnQgeyBBYm9ydEVycm9yIH0gZnJvbSAnLi4vLi4vdXRpbHMuanMnO1xuXG5jbGFzcyBIdHRwUmVzcG9uc2UgZXh0ZW5kcyBCYXNlUmVzcG9uc2Uge1xuICAvKipcbiAgICogQmFzZVJlc3BvbnNlIGZhY2FkZSBmb3Igbm9kZSBIVFRQL0hUVFBTIEFQSSBSZXNwb25zZVxuICAgKiBAcGFyYW0ge2h0dHAuU2VydmVyUmVzcG9uc2V9IHJlc3BvbnNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZXNwb25zZSwgZGF0YVByb21pc2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLmRhdGFQcm9taXNlID0gZGF0YVByb21pc2U7XG4gIH1cblxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gIH1cblxuICBnZXRIZWFkZXIobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLmhlYWRlcnNbbmFtZV07XG4gIH1cblxuICBhc3luYyBnZXREYXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmRhdGFQcm9taXNlO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBIdHRwQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKHVybCkge1xuICAgIHN1cGVyKHVybCk7XG4gICAgdGhpcy5wYXJzZWRVcmwgPSB1cmxNb2QucGFyc2UodGhpcy51cmwpO1xuICAgIHRoaXMuaHR0cEFwaSA9ICh0aGlzLnBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHA6JyA/IGh0dHAgOiBodHRwcyk7XG4gIH1cblxuICBjb25zdHJ1Y3RSZXF1ZXN0KGhlYWRlcnMsIHNpZ25hbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5odHRwQXBpLmdldChcbiAgICAgICAge1xuICAgICAgICAgIC4uLnRoaXMucGFyc2VkVXJsLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgIH0sXG4gICAgICAgIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGFQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmVEYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcblxuICAgICAgICAgICAgLy8gY29sbGVjdCBjaHVua3NcbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBjb25jYXRlbmF0ZSBhbGwgY2h1bmtzIGFuZCByZXNvbHZlIHRoZSBwcm9taXNlIHdpdGggdGhlIHJlc3VsdGluZyBidWZmZXJcbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuY29uY2F0KGNodW5rcykuYnVmZmVyO1xuICAgICAgICAgICAgICByZXNvbHZlRGF0YShkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzcG9uc2Uub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXNvbHZlKG5ldyBIdHRwUmVzcG9uc2UocmVzcG9uc2UsIGRhdGFQcm9taXNlKSk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgcmVxdWVzdC5vbignZXJyb3InLCByZWplY3QpO1xuXG4gICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJlcXVlc3QuZGVzdHJveShuZXcgQWJvcnRFcnJvcignUmVxdWVzdCBhYm9ydGVkJykpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHJlcXVlc3QuZGVzdHJveShuZXcgQWJvcnRFcnJvcignUmVxdWVzdCBhYm9ydGVkJykpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHJlcXVlc3QoeyBoZWFkZXJzLCBzaWduYWwgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNvbnN0cnVjdFJlcXVlc3QoaGVhZGVycywgc2lnbmFsKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/http.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/xhr.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/xhr.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   XHRClient: function() { return /* binding */ XHRClient; }\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/utils.js\");\n\n\n\nclass XHRResponse extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nclass XHRClient extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new _utils_js__WEBPACK_IMPORTED_MODULE_1__.AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9jbGllbnQveGhyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxRDtBQUNUOztBQUU1QywwQkFBMEIsa0RBQVk7QUFDdEM7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyx3QkFBd0IsZ0RBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaURBQVU7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLGtCQUFrQixrQkFBa0IsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L3hoci5qcz9lOTBiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDbGllbnQsIEJhc2VSZXNwb25zZSB9IGZyb20gJy4vYmFzZS5qcyc7XG5pbXBvcnQgeyBBYm9ydEVycm9yIH0gZnJvbSAnLi4vLi4vdXRpbHMuanMnO1xuXG5jbGFzcyBYSFJSZXNwb25zZSBleHRlbmRzIEJhc2VSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBCYXNlUmVzcG9uc2UgZmFjYWRlIGZvciBYTUxIdHRwUmVxdWVzdFxuICAgKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0fSB4aHJcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICAgKi9cbiAgY29uc3RydWN0b3IoeGhyLCBkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnhociA9IHhocjtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG5cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy54aHIuc3RhdHVzO1xuICB9XG5cbiAgZ2V0SGVhZGVyKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIobmFtZSk7XG4gIH1cblxuICBhc3luYyBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGE7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFhIUkNsaWVudCBleHRlbmRzIEJhc2VDbGllbnQge1xuICBjb25zdHJ1Y3RSZXF1ZXN0KGhlYWRlcnMsIHNpZ25hbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCB0aGlzLnVybCk7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBob29rIHNpZ25hbHNcbiAgICAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB4aHIucmVzcG9uc2U7XG4gICAgICAgIHJlc29sdmUobmV3IFhIUlJlc3BvbnNlKHhociwgZGF0YSkpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgeGhyLm9uYWJvcnQgPSAoKSA9PiByZWplY3QobmV3IEFib3J0RXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcpKTtcbiAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4geGhyLmFib3J0KCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgcmVxdWVzdCh7IGhlYWRlcnMsIHNpZ25hbCB9ID0ge30pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY29uc3RydWN0UmVxdWVzdChoZWFkZXJzLCBzaWduYWwpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/xhr.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/file.js":
/*!*********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/file.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeFileSource: function() { return /* binding */ makeFileSource; }\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"?5a99\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basesource.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/basesource.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\nfunction closeAsync(fd) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0__.close(fd, (err) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nfunction openAsync(path, flags, mode = undefined) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0__.open(path, flags, mode, (err, fd) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(fd);\n      }\n    });\n  });\n}\n\nfunction readAsync(...args) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0__.read(...args, (err, bytesRead, buffer) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({ bytesRead, buffer });\n      }\n    });\n  });\n}\n\nclass FileSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_1__.BaseSource {\n  constructor(path) {\n    super();\n    this.path = path;\n    this.openRequest = openAsync(path, 'r');\n  }\n\n  async fetchSlice(slice) {\n    // TODO: use `signal`\n    const fd = await this.openRequest;\n    const { buffer } = await readAsync(\n      fd,\n      Buffer.alloc(slice.length),\n      0,\n      slice.length,\n      slice.offset,\n    );\n    return buffer.buffer;\n  }\n\n  async close() {\n    const fd = await this.openRequest;\n    await closeAsync(fd);\n  }\n}\n\nfunction makeFileSource(path) {\n  return new FileSource(path);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9maWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBb0I7QUFDeUI7O0FBRTdDO0FBQ0E7QUFDQSxJQUFJLHFDQUFRO0FBQ1o7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxvQ0FBTztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLElBQUksb0NBQU87QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBLHlCQUF5QixzREFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLE1BQU0sTUFBTTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvZmlsZS5qcz84NDc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgeyBCYXNlU291cmNlIH0gZnJvbSAnLi9iYXNlc291cmNlLmpzJztcblxuZnVuY3Rpb24gY2xvc2VBc3luYyhmZCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZzLmNsb3NlKGZkLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb3BlbkFzeW5jKHBhdGgsIGZsYWdzLCBtb2RlID0gdW5kZWZpbmVkKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMub3BlbihwYXRoLCBmbGFncywgbW9kZSwgKGVyciwgZmQpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKGZkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRBc3luYyguLi5hcmdzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMucmVhZCguLi5hcmdzLCAoZXJyLCBieXRlc1JlYWQsIGJ1ZmZlcikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoeyBieXRlc1JlYWQsIGJ1ZmZlciB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmNsYXNzIEZpbGVTb3VyY2UgZXh0ZW5kcyBCYXNlU291cmNlIHtcbiAgY29uc3RydWN0b3IocGF0aCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLm9wZW5SZXF1ZXN0ID0gb3BlbkFzeW5jKHBhdGgsICdyJyk7XG4gIH1cblxuICBhc3luYyBmZXRjaFNsaWNlKHNsaWNlKSB7XG4gICAgLy8gVE9ETzogdXNlIGBzaWduYWxgXG4gICAgY29uc3QgZmQgPSBhd2FpdCB0aGlzLm9wZW5SZXF1ZXN0O1xuICAgIGNvbnN0IHsgYnVmZmVyIH0gPSBhd2FpdCByZWFkQXN5bmMoXG4gICAgICBmZCxcbiAgICAgIEJ1ZmZlci5hbGxvYyhzbGljZS5sZW5ndGgpLFxuICAgICAgMCxcbiAgICAgIHNsaWNlLmxlbmd0aCxcbiAgICAgIHNsaWNlLm9mZnNldCxcbiAgICApO1xuICAgIHJldHVybiBidWZmZXIuYnVmZmVyO1xuICB9XG5cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgY29uc3QgZmQgPSBhd2FpdCB0aGlzLm9wZW5SZXF1ZXN0O1xuICAgIGF3YWl0IGNsb3NlQXN5bmMoZmQpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRmlsZVNvdXJjZShwYXRoKSB7XG4gIHJldHVybiBuZXcgRmlsZVNvdXJjZShwYXRoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/file.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/filereader.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/filereader.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeFileReaderSource: function() { return /* binding */ makeFileReaderSource; }\n/* harmony export */ });\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/basesource.js\");\n\n\nclass FileReaderSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nfunction makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9maWxlcmVhZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTZDOztBQUU3QywrQkFBK0Isc0RBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvc291cmNlL2ZpbGVyZWFkZXIuanM/M2E5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlU291cmNlIH0gZnJvbSAnLi9iYXNlc291cmNlLmpzJztcblxuY2xhc3MgRmlsZVJlYWRlclNvdXJjZSBleHRlbmRzIEJhc2VTb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihmaWxlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICB9XG5cbiAgYXN5bmMgZmV0Y2hTbGljZShzbGljZSwgc2lnbmFsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGJsb2IgPSB0aGlzLmZpbGUuc2xpY2Uoc2xpY2Uub2Zmc2V0LCBzbGljZS5vZmZzZXQgKyBzbGljZS5sZW5ndGgpO1xuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSAoZXZlbnQpID0+IHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XG4gICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgIHJlYWRlci5vbmFib3J0ID0gcmVqZWN0O1xuICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuXG4gICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHJlYWRlci5hYm9ydCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzb3VyY2UgZnJvbSBhIGdpdmVuIGZpbGUvYmxvYi5cbiAqIEBwYXJhbSB7QmxvYn0gZmlsZSBUaGUgZmlsZSBvciBibG9iIHRvIHJlYWQgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBjb25zdHJ1Y3RlZCBzb3VyY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGaWxlUmVhZGVyU291cmNlKGZpbGUpIHtcbiAgcmV0dXJuIG5ldyBGaWxlUmVhZGVyU291cmNlKGZpbGUpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/filereader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/httputils.js":
/*!**************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/httputils.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseByteRanges: function() { return /* binding */ parseByteRanges; },\n/* harmony export */   parseContentRange: function() { return /* binding */ parseContentRange; },\n/* harmony export */   parseContentType: function() { return /* binding */ parseContentType; }\n/* harmony export */ });\nconst CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nfunction parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nfunction parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nfunction parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9odHRwdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNPO0FBQ1Asc0RBQXNEO0FBQ3REO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLFNBQVM7QUFDdEMseUJBQXlCLGNBQWM7O0FBRXZDO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksb0JBQW9COztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvaHR0cHV0aWxzLmpzPzA1NWMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ1JMRkNSTEYgPSAnXFxyXFxuXFxyXFxuJztcblxuLypcbiAqIFNoaW0gZm9yICdPYmplY3QuZnJvbUVudHJpZXMnXG4gKi9cbmZ1bmN0aW9uIGl0ZW1zVG9PYmplY3QoaXRlbXMpIHtcbiAgaWYgKHR5cGVvZiBPYmplY3QuZnJvbUVudHJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhpdGVtcyk7XG4gIH1cbiAgY29uc3Qgb2JqID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGl0ZW1zKSB7XG4gICAgb2JqW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogUGFyc2UgSFRUUCBoZWFkZXJzIGZyb20gYSBnaXZlbiBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0aGUgdGV4dCB0byBwYXJzZSB0aGUgaGVhZGVycyBmcm9tXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcGFyc2VkIGhlYWRlcnMgd2l0aCBsb3dlcmNhc2Uga2V5c1xuICovXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnModGV4dCkge1xuICBjb25zdCBpdGVtcyA9IHRleHRcbiAgICAuc3BsaXQoJ1xcclxcbicpXG4gICAgLm1hcCgobGluZSkgPT4ge1xuICAgICAgY29uc3Qga3YgPSBsaW5lLnNwbGl0KCc6JykubWFwKChzdHIpID0+IHN0ci50cmltKCkpO1xuICAgICAga3ZbMF0gPSBrdlswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIGt2O1xuICAgIH0pO1xuXG4gIHJldHVybiBpdGVtc1RvT2JqZWN0KGl0ZW1zKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhICdDb250ZW50LVR5cGUnIGhlYWRlciB2YWx1ZSB0byB0aGUgY29udGVudC10eXBlIGFuZCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29udGVudFR5cGUgdGhlIHJhdyBzdHJpbmcgdG8gcGFyc2UgZnJvbVxuICogQHJldHVybnMge09iamVjdH0gdGhlIHBhcnNlZCBjb250ZW50IHR5cGUgd2l0aCB0aGUgZmllbGRzOiB0eXBlIGFuZCBwYXJhbXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29udGVudFR5cGUocmF3Q29udGVudFR5cGUpIHtcbiAgY29uc3QgW3R5cGUsIC4uLnJhd1BhcmFtc10gPSByYXdDb250ZW50VHlwZS5zcGxpdCgnOycpLm1hcCgocykgPT4gcy50cmltKCkpO1xuICBjb25zdCBwYXJhbXNJdGVtcyA9IHJhd1BhcmFtcy5tYXAoKHBhcmFtKSA9PiBwYXJhbS5zcGxpdCgnPScpKTtcbiAgcmV0dXJuIHsgdHlwZSwgcGFyYW1zOiBpdGVtc1RvT2JqZWN0KHBhcmFtc0l0ZW1zKSB9O1xufVxuXG4vKipcbiAqIFBhcnNlIGEgJ0NvbnRlbnQtUmFuZ2UnIGhlYWRlciB2YWx1ZSB0byBpdHMgc3RhcnQsIGVuZCwgYW5kIHRvdGFsIHBhcnRzXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29udGVudFJhbmdlIHRoZSByYXcgc3RyaW5nIHRvIHBhcnNlIGZyb21cbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBwYXJzZWQgcGFydHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29udGVudFJhbmdlKHJhd0NvbnRlbnRSYW5nZSkge1xuICBsZXQgc3RhcnQ7XG4gIGxldCBlbmQ7XG4gIGxldCB0b3RhbDtcblxuICBpZiAocmF3Q29udGVudFJhbmdlKSB7XG4gICAgWywgc3RhcnQsIGVuZCwgdG90YWxdID0gcmF3Q29udGVudFJhbmdlLm1hdGNoKC9ieXRlcyAoXFxkKyktKFxcZCspXFwvKFxcZCspLyk7XG4gICAgc3RhcnQgPSBwYXJzZUludChzdGFydCwgMTApO1xuICAgIGVuZCA9IHBhcnNlSW50KGVuZCwgMTApO1xuICAgIHRvdGFsID0gcGFyc2VJbnQodG90YWwsIDEwKTtcbiAgfVxuXG4gIHJldHVybiB7IHN0YXJ0LCBlbmQsIHRvdGFsIH07XG59XG5cbi8qKlxuICogUGFyc2VzIGEgbGlzdCBvZiBieXRlcmFuZ2VzIGZyb20gdGhlIGdpdmVuICdtdWx0aXBhcnQvYnl0ZXJhbmdlcycgSFRUUCByZXNwb25zZS5cbiAqIEVhY2ggaXRlbSBpbiB0aGUgbGlzdCBoYXMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogLSBoZWFkZXJzOiB0aGUgSFRUUCBoZWFkZXJzXG4gKiAtIGRhdGE6IHRoZSBzbGljZWQgQXJyYXlCdWZmZXIgZm9yIHRoYXQgc3BlY2lmaWMgcGFydFxuICogLSBvZmZzZXQ6IHRoZSBvZmZzZXQgb2YgdGhlIGJ5dGVyYW5nZSB3aXRoaW4gaXRzIG9yaWdpbmF0aW5nIGZpbGVcbiAqIC0gbGVuZ3RoOiB0aGUgbGVuZ3RoIG9mIHRoZSBieXRlcmFuZ2VcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IHJlc3BvbnNlQXJyYXlCdWZmZXIgdGhlIHJlc3BvbnNlIHRvIGJlIHBhcnNlZCBhbmQgc3BsaXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBib3VuZGFyeSB0aGUgYm91bmRhcnkgc3RyaW5nIHVzZWQgdG8gc3BsaXQgdGhlIHNlY3Rpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0W119IHRoZSBwYXJzZWQgYnl0ZXJhbmdlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VCeXRlUmFuZ2VzKHJlc3BvbnNlQXJyYXlCdWZmZXIsIGJvdW5kYXJ5KSB7XG4gIGxldCBvZmZzZXQgPSBudWxsO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCdhc2NpaScpO1xuICBjb25zdCBvdXQgPSBbXTtcblxuICBjb25zdCBzdGFydEJvdW5kYXJ5ID0gYC0tJHtib3VuZGFyeX1gO1xuICBjb25zdCBlbmRCb3VuZGFyeSA9IGAke3N0YXJ0Qm91bmRhcnl9LS1gO1xuXG4gIC8vIHNlYXJjaCBmb3IgdGhlIGluaXRpYWwgYm91bmRhcnksIG1heSBiZSBvZmZzZXQgYnkgc29tZSBieXRlc1xuICAvLyBUT0RPOiBtb3JlIGVmZmljaWVudCB0byBjaGVjayBmb3IgYC0tYCBpbiBieXRlcyBkaXJlY3RseVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyArK2kpIHtcbiAgICBjb25zdCB0ZXh0ID0gZGVjb2Rlci5kZWNvZGUoXG4gICAgICBuZXcgVWludDhBcnJheShyZXNwb25zZUFycmF5QnVmZmVyLCBpLCBzdGFydEJvdW5kYXJ5Lmxlbmd0aCksXG4gICAgKTtcbiAgICBpZiAodGV4dCA9PT0gc3RhcnRCb3VuZGFyeSkge1xuICAgICAgb2Zmc2V0ID0gaTtcbiAgICB9XG4gIH1cblxuICBpZiAob2Zmc2V0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBpbml0aWFsIGJvdW5kYXJ5Jyk7XG4gIH1cblxuICB3aGlsZSAob2Zmc2V0IDwgcmVzcG9uc2VBcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgY29uc3QgdGV4dCA9IGRlY29kZXIuZGVjb2RlKFxuICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2VBcnJheUJ1ZmZlciwgb2Zmc2V0LFxuICAgICAgICBNYXRoLm1pbihzdGFydEJvdW5kYXJ5Lmxlbmd0aCArIDEwMjQsIHJlc3BvbnNlQXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCAtIG9mZnNldCksXG4gICAgICApLFxuICAgICk7XG5cbiAgICAvLyBicmVhayBpZiB3ZSBhcnJpdmVkIGF0IHRoZSBlbmRcbiAgICBpZiAodGV4dC5sZW5ndGggPT09IDAgfHwgdGV4dC5zdGFydHNXaXRoKGVuZEJvdW5kYXJ5KSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gYXNzZXJ0IHRoYXQgd2UgYXJlIGFjdHVhbGx5IGRlYWxpbmcgd2l0aCBhIGJ5dGVyYW5nZSBhbmQgYXJlIGF0IHRoZSBjb3JyZWN0IG9mZnNldFxuICAgIGlmICghdGV4dC5zdGFydHNXaXRoKHN0YXJ0Qm91bmRhcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnQgZG9lcyBub3Qgc3RhcnQgd2l0aCBib3VuZGFyeScpO1xuICAgIH1cblxuICAgIC8vIGdldCBhIHN1YnN0cmluZyBmcm9tIHdoZXJlIHdlIHJlYWQgdGhlIGhlYWRlcnNcbiAgICBjb25zdCBpbm5lclRleHQgPSB0ZXh0LnN1YnN0cihzdGFydEJvdW5kYXJ5Lmxlbmd0aCArIDIpO1xuXG4gICAgaWYgKGlubmVyVGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGZpbmQgdGhlIGRvdWJsZSBsaW5lYnJlYWsgdGhhdCBkZW5vdGVzIHRoZSBlbmQgb2YgdGhlIGhlYWRlcnNcbiAgICBjb25zdCBlbmRPZkhlYWRlcnMgPSBpbm5lclRleHQuaW5kZXhPZihDUkxGQ1JMRik7XG5cbiAgICAvLyBwYXJzZSB0aGUgaGVhZGVycyB0byBnZXQgdGhlIGNvbnRlbnQgcmFuZ2Ugc2l6ZVxuICAgIGNvbnN0IGhlYWRlcnMgPSBwYXJzZUhlYWRlcnMoaW5uZXJUZXh0LnN1YnN0cigwLCBlbmRPZkhlYWRlcnMpKTtcbiAgICBjb25zdCB7IHN0YXJ0LCBlbmQsIHRvdGFsIH0gPSBwYXJzZUNvbnRlbnRSYW5nZShoZWFkZXJzWydjb250ZW50LXJhbmdlJ10pO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgdGhlIHNsaWNlIGFuZCB0aGUgbmV4dCBvZmZzZXRcbiAgICBjb25zdCBzdGFydE9mRGF0YSA9IG9mZnNldCArIHN0YXJ0Qm91bmRhcnkubGVuZ3RoICsgZW5kT2ZIZWFkZXJzICsgQ1JMRkNSTEYubGVuZ3RoO1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGVuZCwgMTApICsgMSAtIHBhcnNlSW50KHN0YXJ0LCAxMCk7XG4gICAgb3V0LnB1c2goe1xuICAgICAgaGVhZGVycyxcbiAgICAgIGRhdGE6IHJlc3BvbnNlQXJyYXlCdWZmZXIuc2xpY2Uoc3RhcnRPZkRhdGEsIHN0YXJ0T2ZEYXRhICsgbGVuZ3RoKSxcbiAgICAgIG9mZnNldDogc3RhcnQsXG4gICAgICBsZW5ndGgsXG4gICAgICBmaWxlU2l6ZTogdG90YWwsXG4gICAgfSk7XG5cbiAgICBvZmZzZXQgPSBzdGFydE9mRGF0YSArIGxlbmd0aCArIDQ7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/httputils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/source/remote.js":
/*!***********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/remote.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeCustomSource: function() { return /* binding */ makeCustomSource; },\n/* harmony export */   makeFetchSource: function() { return /* binding */ makeFetchSource; },\n/* harmony export */   makeHttpSource: function() { return /* binding */ makeHttpSource; },\n/* harmony export */   makeRemoteSource: function() { return /* binding */ makeRemoteSource; },\n/* harmony export */   makeXHRSource: function() { return /* binding */ makeXHRSource; }\n/* harmony export */ });\n/* harmony import */ var _httputils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./httputils.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/httputils.js\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _blockedsource_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blockedsource.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/blockedsource.js\");\n/* harmony import */ var _client_fetch_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./client/fetch.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/fetch.js\");\n/* harmony import */ var _client_xhr_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./client/xhr.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/xhr.js\");\n/* harmony import */ var _client_http_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./client/http.js */ \"(app-pages-browser)/./node_modules/geotiff/dist-module/source/client/http.js\");\n\n\n\n\n\n\n\n\nclass RemoteSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseContentType)(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseByteRanges)(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseContentRange)(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseContentRange)(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new _blockedsource_js__WEBPACK_IMPORTED_MODULE_2__.BlockedSource(source, { blockSize, cacheSize });\n}\n\nfunction makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_fetch_js__WEBPACK_IMPORTED_MODULE_3__.FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_xhr_js__WEBPACK_IMPORTED_MODULE_4__.XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_http_js__WEBPACK_IMPORTED_MODULE_5__.HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeCustomSource(client, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nfunction makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9yZW1vdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBc0Y7QUFDekM7QUFDTTs7QUFFSDtBQUNKO0FBQ0U7O0FBRTlDLDJCQUEyQixzREFBVTtBQUNyQztBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsa0JBQWtCLGdCQUFnQixRQUFRLE9BQU8sR0FBRyxnQkFBZ0I7QUFDcEU7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBTTtBQUNOLGNBQWMsZUFBZSxFQUFFLCtEQUFnQjtBQUMvQztBQUNBLDJCQUEyQiw4REFBZTtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxvQkFBb0IsRUFBRSxnRUFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPLEdBQUcsZ0JBQWdCO0FBQ2xELE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBLGNBQWMsUUFBUSxFQUFFLGdFQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDREQUFhLFdBQVcsc0JBQXNCO0FBQzNEOztBQUVPLGdDQUFnQyxZQUFZLHVFQUF1RSxJQUFJO0FBQzlILHFCQUFxQix5REFBVztBQUNoQztBQUNBO0FBQ0E7O0FBRU8sOEJBQThCLFlBQVksMERBQTBELElBQUk7QUFDL0cscUJBQXFCLHFEQUFTO0FBQzlCO0FBQ0E7QUFDQTs7QUFFTywrQkFBK0IsWUFBWSwwREFBMEQsSUFBSTtBQUNoSCxxQkFBcUIsdURBQVU7QUFDL0I7QUFDQTtBQUNBOztBQUVPLG9DQUFvQyxZQUFZLDBEQUEwRCxJQUFJO0FBQ3JIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNPLGlDQUFpQyxxQ0FBcUMsSUFBSTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9yZW1vdGUuanM/YjM4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZUJ5dGVSYW5nZXMsIHBhcnNlQ29udGVudFJhbmdlLCBwYXJzZUNvbnRlbnRUeXBlIH0gZnJvbSAnLi9odHRwdXRpbHMuanMnO1xuaW1wb3J0IHsgQmFzZVNvdXJjZSB9IGZyb20gJy4vYmFzZXNvdXJjZS5qcyc7XG5pbXBvcnQgeyBCbG9ja2VkU291cmNlIH0gZnJvbSAnLi9ibG9ja2Vkc291cmNlLmpzJztcblxuaW1wb3J0IHsgRmV0Y2hDbGllbnQgfSBmcm9tICcuL2NsaWVudC9mZXRjaC5qcyc7XG5pbXBvcnQgeyBYSFJDbGllbnQgfSBmcm9tICcuL2NsaWVudC94aHIuanMnO1xuaW1wb3J0IHsgSHR0cENsaWVudCB9IGZyb20gJy4vY2xpZW50L2h0dHAuanMnO1xuXG5jbGFzcyBSZW1vdGVTb3VyY2UgZXh0ZW5kcyBCYXNlU291cmNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7QmFzZUNsaWVudH0gY2xpZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoZWFkZXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyc30gbWF4UmFuZ2VzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxsb3dGdWxsRmlsZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY2xpZW50LCBoZWFkZXJzLCBtYXhSYW5nZXMsIGFsbG93RnVsbEZpbGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgdGhpcy5tYXhSYW5nZXMgPSBtYXhSYW5nZXM7XG4gICAgdGhpcy5hbGxvd0Z1bGxGaWxlID0gYWxsb3dGdWxsRmlsZTtcbiAgICB0aGlzLl9maWxlU2l6ZSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtTbGljZVtdfSBzbGljZXNcbiAgICovXG4gIGFzeW5jIGZldGNoKHNsaWNlcywgc2lnbmFsKSB7XG4gICAgLy8gaWYgd2UgYWxsb3cgbXVsdGktcmFuZ2VzLCBzcGxpdCB0aGUgaW5jb21pbmcgcmVxdWVzdCBpbnRvIHRoYXQgbWFueSBzdWItcmVxdWVzdHNcbiAgICAvLyBhbmQgam9pbiB0aGVtIGFmdGVyd2FyZHNcbiAgICBpZiAodGhpcy5tYXhSYW5nZXMgPj0gc2xpY2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hTbGljZXMoc2xpY2VzLCBzaWduYWwpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXhSYW5nZXMgPiAwICYmIHNsaWNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBUT0RPOiBzcGxpdCBpbnRvIG11bHRpcGxlIG11bHRpLXJhbmdlIHJlcXVlc3RzXG5cbiAgICAgIC8vIGNvbnN0IHN1YlNsaWNlc1JlcXVlc3RzID0gW107XG4gICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWNlcy5sZW5ndGg7IGkgKz0gdGhpcy5tYXhSYW5nZXMpIHtcbiAgICAgIC8vICAgc3ViU2xpY2VzUmVxdWVzdHMucHVzaChcbiAgICAgIC8vICAgICB0aGlzLmZldGNoU2xpY2VzKHNsaWNlcy5zbGljZShpLCBpICsgdGhpcy5tYXhSYW5nZXMpLCBzaWduYWwpLFxuICAgICAgLy8gICApO1xuICAgICAgLy8gfVxuICAgICAgLy8gcmV0dXJuIChhd2FpdCBQcm9taXNlLmFsbChzdWJTbGljZXNSZXF1ZXN0cykpLmZsYXQoKTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgbWFrZSBhIHNpbmdsZSByZXF1ZXN0IGZvciBlYWNoIHNsaWNlXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgc2xpY2VzLm1hcCgoc2xpY2UpID0+IHRoaXMuZmV0Y2hTbGljZShzbGljZSwgc2lnbmFsKSksXG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIGZldGNoU2xpY2VzKHNsaWNlcywgc2lnbmFsKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4udGhpcy5oZWFkZXJzLFxuICAgICAgICBSYW5nZTogYGJ5dGVzPSR7c2xpY2VzXG4gICAgICAgICAgLm1hcCgoeyBvZmZzZXQsIGxlbmd0aCB9KSA9PiBgJHtvZmZzZXR9LSR7b2Zmc2V0ICsgbGVuZ3RofWApXG4gICAgICAgICAgLmpvaW4oJywnKVxuICAgICAgICB9YCxcbiAgICAgIH0sXG4gICAgICBzaWduYWwsXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGZldGNoaW5nIGRhdGEuJyk7XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNikge1xuICAgICAgY29uc3QgeyB0eXBlLCBwYXJhbXMgfSA9IHBhcnNlQ29udGVudFR5cGUocmVzcG9uc2UuZ2V0SGVhZGVyKCdjb250ZW50LXR5cGUnKSk7XG4gICAgICBpZiAodHlwZSA9PT0gJ211bHRpcGFydC9ieXRlcmFuZ2VzJykge1xuICAgICAgICBjb25zdCBieXRlUmFuZ2VzID0gcGFyc2VCeXRlUmFuZ2VzKGF3YWl0IHJlc3BvbnNlLmdldERhdGEoKSwgcGFyYW1zLmJvdW5kYXJ5KTtcbiAgICAgICAgdGhpcy5fZmlsZVNpemUgPSBieXRlUmFuZ2VzWzBdLmZpbGVTaXplIHx8IG51bGw7XG4gICAgICAgIHJldHVybiBieXRlUmFuZ2VzO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuZ2V0RGF0YSgpO1xuXG4gICAgICBjb25zdCB7IHN0YXJ0LCBlbmQsIHRvdGFsIH0gPSBwYXJzZUNvbnRlbnRSYW5nZShyZXNwb25zZS5nZXRIZWFkZXIoJ2NvbnRlbnQtcmFuZ2UnKSk7XG4gICAgICB0aGlzLl9maWxlU2l6ZSA9IHRvdGFsIHx8IG51bGw7XG4gICAgICBjb25zdCBmaXJzdCA9IFt7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIG9mZnNldDogc3RhcnQsXG4gICAgICAgIGxlbmd0aDogZW5kIC0gc3RhcnQsXG4gICAgICB9XTtcblxuICAgICAgaWYgKHNsaWNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIHdlIHJlcXVlc3RlZCBtb3JlIHRoYW4gb25lIHNsaWNlLCBidXQgZ290IG9ubHkgdGhlIGZpcnN0XG4gICAgICAgIC8vIHVuZm9ydHVuYXRlbHksIHNvbWUgSFRUUCBTZXJ2ZXJzIGRvbid0IHN1cHBvcnQgbXVsdGktcmFuZ2VzXG4gICAgICAgIC8vIGFuZCByZXR1cm4gb25seSB0aGUgZmlyc3RcblxuICAgICAgICAvLyBnZXQgdGhlIHJlc3Qgb2YgdGhlIHNsaWNlcyBhbmQgZmV0Y2ggdGhlbSBpdGVyYXRpdmVseVxuICAgICAgICBjb25zdCBvdGhlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChzbGljZXMuc2xpY2UoMSkubWFwKChzbGljZSkgPT4gdGhpcy5mZXRjaFNsaWNlKHNsaWNlLCBzaWduYWwpKSk7XG4gICAgICAgIHJldHVybiBmaXJzdC5jb25jYXQob3RoZXJzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaXJzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLmFsbG93RnVsbEZpbGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggZnVsbCBmaWxlJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuZ2V0RGF0YSgpO1xuICAgICAgdGhpcy5fZmlsZVNpemUgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgZGF0YSxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBsZW5ndGg6IGRhdGEuYnl0ZUxlbmd0aCxcbiAgICAgIH1dO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZldGNoU2xpY2Uoc2xpY2UsIHNpZ25hbCkge1xuICAgIGNvbnN0IHsgb2Zmc2V0LCBsZW5ndGggfSA9IHNsaWNlO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgUmFuZ2U6IGBieXRlcz0ke29mZnNldH0tJHtvZmZzZXQgKyBsZW5ndGh9YCxcbiAgICAgIH0sXG4gICAgICBzaWduYWwsXG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayB0aGUgcmVzcG9uc2Ugd2FzIG9rYXkgYW5kIGlmIHRoZSBzZXJ2ZXIgYWN0dWFsbHkgdW5kZXJzdGFuZHMgcmFuZ2UgcmVxdWVzdHNcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGZldGNoaW5nIGRhdGEuJyk7XG4gICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNikge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmdldERhdGEoKTtcblxuICAgICAgY29uc3QgeyB0b3RhbCB9ID0gcGFyc2VDb250ZW50UmFuZ2UocmVzcG9uc2UuZ2V0SGVhZGVyKCdjb250ZW50LXJhbmdlJykpO1xuICAgICAgdGhpcy5fZmlsZVNpemUgPSB0b3RhbCB8fCBudWxsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBsZW5ndGgsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuYWxsb3dGdWxsRmlsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciByZXNwb25kZWQgd2l0aCBmdWxsIGZpbGUnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmdldERhdGEoKTtcblxuICAgICAgdGhpcy5fZmlsZVNpemUgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGxlbmd0aDogZGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBnZXQgZmlsZVNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVTaXplO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlV3JhcEluQmxvY2tlZFNvdXJjZShzb3VyY2UsIHsgYmxvY2tTaXplLCBjYWNoZVNpemUgfSkge1xuICBpZiAoYmxvY2tTaXplID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuICByZXR1cm4gbmV3IEJsb2NrZWRTb3VyY2Uoc291cmNlLCB7IGJsb2NrU2l6ZSwgY2FjaGVTaXplIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUZldGNoU291cmNlKHVybCwgeyBoZWFkZXJzID0ge30sIGNyZWRlbnRpYWxzLCBtYXhSYW5nZXMgPSAwLCBhbGxvd0Z1bGxGaWxlID0gZmFsc2UsIC4uLmJsb2NrT3B0aW9ucyB9ID0ge30pIHtcbiAgY29uc3QgY2xpZW50ID0gbmV3IEZldGNoQ2xpZW50KHVybCwgY3JlZGVudGlhbHMpO1xuICBjb25zdCBzb3VyY2UgPSBuZXcgUmVtb3RlU291cmNlKGNsaWVudCwgaGVhZGVycywgbWF4UmFuZ2VzLCBhbGxvd0Z1bGxGaWxlKTtcbiAgcmV0dXJuIG1heWJlV3JhcEluQmxvY2tlZFNvdXJjZShzb3VyY2UsIGJsb2NrT3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlWEhSU291cmNlKHVybCwgeyBoZWFkZXJzID0ge30sIG1heFJhbmdlcyA9IDAsIGFsbG93RnVsbEZpbGUgPSBmYWxzZSwgLi4uYmxvY2tPcHRpb25zIH0gPSB7fSkge1xuICBjb25zdCBjbGllbnQgPSBuZXcgWEhSQ2xpZW50KHVybCk7XG4gIGNvbnN0IHNvdXJjZSA9IG5ldyBSZW1vdGVTb3VyY2UoY2xpZW50LCBoZWFkZXJzLCBtYXhSYW5nZXMsIGFsbG93RnVsbEZpbGUpO1xuICByZXR1cm4gbWF5YmVXcmFwSW5CbG9ja2VkU291cmNlKHNvdXJjZSwgYmxvY2tPcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VIdHRwU291cmNlKHVybCwgeyBoZWFkZXJzID0ge30sIG1heFJhbmdlcyA9IDAsIGFsbG93RnVsbEZpbGUgPSBmYWxzZSwgLi4uYmxvY2tPcHRpb25zIH0gPSB7fSkge1xuICBjb25zdCBjbGllbnQgPSBuZXcgSHR0cENsaWVudCh1cmwpO1xuICBjb25zdCBzb3VyY2UgPSBuZXcgUmVtb3RlU291cmNlKGNsaWVudCwgaGVhZGVycywgbWF4UmFuZ2VzLCBhbGxvd0Z1bGxGaWxlKTtcbiAgcmV0dXJuIG1heWJlV3JhcEluQmxvY2tlZFNvdXJjZShzb3VyY2UsIGJsb2NrT3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQ3VzdG9tU291cmNlKGNsaWVudCwgeyBoZWFkZXJzID0ge30sIG1heFJhbmdlcyA9IDAsIGFsbG93RnVsbEZpbGUgPSBmYWxzZSwgLi4uYmxvY2tPcHRpb25zIH0gPSB7fSkge1xuICBjb25zdCBzb3VyY2UgPSBuZXcgUmVtb3RlU291cmNlKGNsaWVudCwgaGVhZGVycywgbWF4UmFuZ2VzLCBhbGxvd0Z1bGxGaWxlKTtcbiAgcmV0dXJuIG1heWJlV3JhcEluQmxvY2tlZFNvdXJjZShzb3VyY2UsIGJsb2NrT3B0aW9ucyk7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUmVtb3RlU291cmNlKHVybCwgeyBmb3JjZVhIUiA9IGZhbHNlLCAuLi5jbGllbnRPcHRpb25zIH0gPSB7fSkge1xuICBpZiAodHlwZW9mIGZldGNoID09PSAnZnVuY3Rpb24nICYmICFmb3JjZVhIUikge1xuICAgIHJldHVybiBtYWtlRmV0Y2hTb3VyY2UodXJsLCBjbGllbnRPcHRpb25zKTtcbiAgfVxuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBtYWtlWEhSU291cmNlKHVybCwgY2xpZW50T3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIG1ha2VIdHRwU291cmNlKHVybCwgY2xpZW50T3B0aW9ucyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/source/remote.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/geotiff/dist-module/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/geotiff/dist-module/utils.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: function() { return /* binding */ AbortError; },\n/* harmony export */   AggregateError: function() { return /* binding */ AggregateError; },\n/* harmony export */   CustomAggregateError: function() { return /* binding */ CustomAggregateError; },\n/* harmony export */   assign: function() { return /* binding */ assign; },\n/* harmony export */   chunk: function() { return /* binding */ chunk; },\n/* harmony export */   endsWith: function() { return /* binding */ endsWith; },\n/* harmony export */   forEach: function() { return /* binding */ forEach; },\n/* harmony export */   invert: function() { return /* binding */ invert; },\n/* harmony export */   parseContentRange: function() { return /* binding */ parseContentRange; },\n/* harmony export */   range: function() { return /* binding */ range; },\n/* harmony export */   times: function() { return /* binding */ times; },\n/* harmony export */   toArray: function() { return /* binding */ toArray; },\n/* harmony export */   toArrayRecursively: function() { return /* binding */ toArrayRecursively; },\n/* harmony export */   wait: function() { return /* binding */ wait; },\n/* harmony export */   zip: function() { return /* binding */ zip; }\n/* harmony export */ });\nfunction assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nfunction chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nfunction endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nfunction forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nfunction invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nfunction range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nfunction times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nfunction toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nfunction toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nfunction parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nasync function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nfunction zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nclass AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nclass CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nconst AggregateError = CustomAggregateError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFVBQVUsU0FBUztBQUNuQixrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EsVUFBVSxTQUFTO0FBQ25CLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3V0aWxzLmpzPzMyMWEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaHVuayhpdGVyYWJsZSwgbGVuZ3RoKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgY29uc3QgbGVuZ3RoT2ZJdGVyYWJsZSA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGhPZkl0ZXJhYmxlOyBpICs9IGxlbmd0aCkge1xuICAgIGNvbnN0IGNodW5rZWQgPSBbXTtcbiAgICBmb3IgKGxldCBjaSA9IGk7IGNpIDwgaSArIGxlbmd0aDsgY2krKykge1xuICAgICAgY2h1bmtlZC5wdXNoKGl0ZXJhYmxlW2NpXSk7XG4gICAgfVxuICAgIHJlc3VsdHMucHVzaChjaHVua2VkKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgZXhwZWN0ZWRFbmRpbmcpIHtcbiAgaWYgKHN0cmluZy5sZW5ndGggPCBleHBlY3RlZEVuZGluZy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYWN0dWFsRW5kaW5nID0gc3RyaW5nLnN1YnN0cihzdHJpbmcubGVuZ3RoIC0gZXhwZWN0ZWRFbmRpbmcubGVuZ3RoKTtcbiAgcmV0dXJuIGFjdHVhbEVuZGluZyA9PT0gZXhwZWN0ZWRFbmRpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoKGl0ZXJhYmxlLCBmdW5jKSB7XG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBpdGVyYWJsZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGZ1bmMoaXRlcmFibGVbaV0sIGkpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob2xkT2JqKSB7XG4gIGNvbnN0IG5ld09iaiA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvbGRPYmopIHtcbiAgICBpZiAob2xkT2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2xkT2JqW2tleV07XG4gICAgICBuZXdPYmpbdmFsdWVdID0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3T2JqO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2Uobikge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgcmVzdWx0cy5wdXNoKGkpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZXMobnVtVGltZXMsIGZ1bmMpIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRpbWVzOyBpKyspIHtcbiAgICByZXN1bHRzLnB1c2goZnVuYyhpKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5KGl0ZXJhYmxlKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgY29uc3QgeyBsZW5ndGggfSA9IGl0ZXJhYmxlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0cy5wdXNoKGl0ZXJhYmxlW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvQXJyYXlSZWN1cnNpdmVseShpbnB1dCkge1xuICBpZiAoaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRvQXJyYXkoaW5wdXQpLm1hcCh0b0FycmF5UmVjdXJzaXZlbHkpO1xuICB9XG4gIHJldHVybiBpbnB1dDtcbn1cblxuLy8gY29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FjYWRlbWlhLWRlLWNvZGlnby9wYXJzZS1jb250ZW50LXJhbmdlLWhlYWRlci9ibG9iL21hc3Rlci9pbmRleC5qc1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29udGVudFJhbmdlKGhlYWRlclZhbHVlKSB7XG4gIGlmICghaGVhZGVyVmFsdWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGVhZGVyVmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBjb25zdCBwYXJzZUludCA9IChudW1iZXIpID0+IE51bWJlci5wYXJzZUludChudW1iZXIsIDEwKTtcblxuICAvLyBDaGVjayBmb3IgcHJlc2VuY2Ugb2YgdW5pdFxuICBsZXQgbWF0Y2hlcyA9IGhlYWRlclZhbHVlLm1hdGNoKC9eKFxcdyopIC8pO1xuICBjb25zdCB1bml0ID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzFdO1xuXG4gIC8vIGNoZWNrIGZvciBzdGFydC1lbmQvc2l6ZSBoZWFkZXIgZm9ybWF0XG4gIG1hdGNoZXMgPSBoZWFkZXJWYWx1ZS5tYXRjaCgvKFxcZCspLShcXGQrKVxcLyhcXGQrfFxcKikvKTtcbiAgaWYgKG1hdGNoZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pdCxcbiAgICAgIGZpcnN0OiBwYXJzZUludChtYXRjaGVzWzFdKSxcbiAgICAgIGxhc3Q6IHBhcnNlSW50KG1hdGNoZXNbMl0pLFxuICAgICAgbGVuZ3RoOiBtYXRjaGVzWzNdID09PSAnKicgPyBudWxsIDogcGFyc2VJbnQobWF0Y2hlc1szXSksXG4gICAgfTtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBzaXplIGhlYWRlciBmb3JtYXRcbiAgbWF0Y2hlcyA9IGhlYWRlclZhbHVlLm1hdGNoKC8oXFxkK3xcXCopLyk7XG4gIGlmIChtYXRjaGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuaXQsXG4gICAgICBmaXJzdDogbnVsbCxcbiAgICAgIGxhc3Q6IG51bGwsXG4gICAgICBsZW5ndGg6IG1hdGNoZXNbMV0gPT09ICcqJyA/IG51bGwgOiBwYXJzZUludChtYXRjaGVzWzFdKSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qXG4gKiBQcm9taXNpZmllZCB3cmFwcGVyIGFyb3VuZCAnc2V0VGltZW91dCcgdG8gYWxsb3cgJ2F3YWl0J1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FpdChtaWxsaXNlY29uZHMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1pbGxpc2Vjb25kcykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gemlwKGEsIGIpIHtcbiAgY29uc3QgQSA9IEFycmF5LmlzQXJyYXkoYSkgPyBhIDogQXJyYXkuZnJvbShhKTtcbiAgY29uc3QgQiA9IEFycmF5LmlzQXJyYXkoYikgPyBiIDogQXJyYXkuZnJvbShiKTtcbiAgcmV0dXJuIEEubWFwKChrLCBpKSA9PiBbaywgQltpXV0pO1xufVxuXG4vLyBCYXNlZCBvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvclxuZXhwb3J0IGNsYXNzIEFib3J0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIC8vIFBhc3MgcmVtYWluaW5nIGFyZ3VtZW50cyAoaW5jbHVkaW5nIHZlbmRvciBzcGVjaWZpYyBvbmVzKSB0byBwYXJlbnQgY29uc3RydWN0b3JcbiAgICBzdXBlcihwYXJhbXMpO1xuXG4gICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24gKG9ubHkgYXZhaWxhYmxlIG9uIFY4KVxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQWJvcnRFcnJvcik7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lID0gJ0Fib3J0RXJyb3InO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDdXN0b21BZ2dyZWdhdGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZXJyb3JzLCBtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm5hbWUgPSAnQWdncmVnYXRlRXJyb3InO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBBZ2dyZWdhdGVFcnJvciA9IEN1c3RvbUFnZ3JlZ2F0ZUVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/geotiff/dist-module/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/quick-lru/index.js":
/*!*****************************************!*\
  !*** ./node_modules/quick-lru/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ QuickLRU; }\n/* harmony export */ });\nclass QuickLRU extends Map {\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tif (typeof options.maxAge === 'number' && options.maxAge === 0) {\n\t\t\tthrow new TypeError('`maxAge` must be a number greater than 0');\n\t\t}\n\n\t\t// TODO: Use private class fields when ESLint supports them.\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.maxAge = options.maxAge || Number.POSITIVE_INFINITY;\n\t\tthis.onEviction = options.onEviction;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t// TODO: Use private class methods when targeting Node.js 16.\n\t_emitEvictions(cache) {\n\t\tif (typeof this.onEviction !== 'function') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [key, item] of cache) {\n\t\t\tthis.onEviction(key, item.value);\n\t\t}\n\t}\n\n\t_deleteIfExpired(key, item) {\n\t\tif (typeof item.expiry === 'number' && item.expiry <= Date.now()) {\n\t\t\tif (typeof this.onEviction === 'function') {\n\t\t\t\tthis.onEviction(key, item.value);\n\t\t\t}\n\n\t\t\treturn this.delete(key);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_getOrDeleteIfExpired(key, item) {\n\t\tconst deleted = this._deleteIfExpired(key, item);\n\t\tif (deleted === false) {\n\t\t\treturn item.value;\n\t\t}\n\t}\n\n\t_getItemValue(key, item) {\n\t\treturn item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;\n\t}\n\n\t_peek(key, cache) {\n\t\tconst item = cache.get(key);\n\n\t\treturn this._getItemValue(key, item);\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\t\t\tthis._emitEvictions(this.oldCache);\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\t_moveToRecent(key, item) {\n\t\tthis.oldCache.delete(key);\n\t\tthis._set(key, item);\n\t}\n\n\t* _entriesAscending() {\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\tconst item = this.cache.get(key);\n\n\t\t\treturn this._getItemValue(key, item);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst item = this.oldCache.get(key);\n\t\t\tif (this._deleteIfExpired(key, item) === false) {\n\t\t\t\tthis._moveToRecent(key, item);\n\t\t\t\treturn item.value;\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key, value, {maxAge = this.maxAge} = {}) {\n\t\tconst expiry =\n\t\t\ttypeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY ?\n\t\t\t\tDate.now() + maxAge :\n\t\t\t\tundefined;\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, {\n\t\t\t\tvalue,\n\t\t\t\texpiry\n\t\t\t});\n\t\t} else {\n\t\t\tthis._set(key, {value, expiry});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.cache.get(key));\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.oldCache.get(key));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this._peek(key, this.cache);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this._peek(key, this.oldCache);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\tresize(newSize) {\n\t\tif (!(newSize && newSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tconst items = [...this._entriesAscending()];\n\t\tconst removeCount = items.length - newSize;\n\t\tif (removeCount < 0) {\n\t\t\tthis.cache = new Map(items);\n\t\t\tthis.oldCache = new Map();\n\t\t\tthis._size = items.length;\n\t\t} else {\n\t\t\tif (removeCount > 0) {\n\t\t\t\tthis._emitEvictions(items.slice(0, removeCount));\n\t\t\t}\n\n\t\t\tthis.oldCache = new Map(items.slice(removeCount));\n\t\t\tthis.cache = new Map();\n\t\t\tthis._size = 0;\n\t\t}\n\n\t\tthis.maxSize = newSize;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesDescending() {\n\t\tlet items = [...this.cache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\titems = [...this.oldCache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesAscending() {\n\t\tfor (const [key, value] of this._entriesAscending()) {\n\t\t\tyield [key, value.value];\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (!this._size) {\n\t\t\treturn this.oldCache.size;\n\t\t}\n\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(this._size + oldCacheSize, this.maxSize);\n\t}\n\n\tentries() {\n\t\treturn this.entriesAscending();\n\t}\n\n\tforEach(callbackFunction, thisArgument = this) {\n\t\tfor (const [key, value] of this.entriesAscending()) {\n\t\t\tcallbackFunction.call(thisArgument, value, key, this);\n\t\t}\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn JSON.stringify([...this.entriesAscending()]);\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9xdWljay1scnUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2YseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQixJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKLG1CQUFtQixjQUFjO0FBQ2pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3F1aWNrLWxydS9pbmRleC5qcz83ODE2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1aWNrTFJVIGV4dGVuZHMgTWFwIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdGlmICghKG9wdGlvbnMubWF4U2l6ZSAmJiBvcHRpb25zLm1heFNpemUgPiAwKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYG1heFNpemVgIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAnKTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIG9wdGlvbnMubWF4QWdlID09PSAnbnVtYmVyJyAmJiBvcHRpb25zLm1heEFnZSA9PT0gMCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYG1heEFnZWAgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCcpO1xuXHRcdH1cblxuXHRcdC8vIFRPRE86IFVzZSBwcml2YXRlIGNsYXNzIGZpZWxkcyB3aGVuIEVTTGludCBzdXBwb3J0cyB0aGVtLlxuXHRcdHRoaXMubWF4U2l6ZSA9IG9wdGlvbnMubWF4U2l6ZTtcblx0XHR0aGlzLm1heEFnZSA9IG9wdGlvbnMubWF4QWdlIHx8IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0XHR0aGlzLm9uRXZpY3Rpb24gPSBvcHRpb25zLm9uRXZpY3Rpb247XG5cdFx0dGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLm9sZENhY2hlID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMuX3NpemUgPSAwO1xuXHR9XG5cblx0Ly8gVE9ETzogVXNlIHByaXZhdGUgY2xhc3MgbWV0aG9kcyB3aGVuIHRhcmdldGluZyBOb2RlLmpzIDE2LlxuXHRfZW1pdEV2aWN0aW9ucyhjYWNoZSkge1xuXHRcdGlmICh0eXBlb2YgdGhpcy5vbkV2aWN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBjYWNoZSkge1xuXHRcdFx0dGhpcy5vbkV2aWN0aW9uKGtleSwgaXRlbS52YWx1ZSk7XG5cdFx0fVxuXHR9XG5cblx0X2RlbGV0ZUlmRXhwaXJlZChrZXksIGl0ZW0pIHtcblx0XHRpZiAodHlwZW9mIGl0ZW0uZXhwaXJ5ID09PSAnbnVtYmVyJyAmJiBpdGVtLmV4cGlyeSA8PSBEYXRlLm5vdygpKSB7XG5cdFx0XHRpZiAodHlwZW9mIHRoaXMub25FdmljdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0aGlzLm9uRXZpY3Rpb24oa2V5LCBpdGVtLnZhbHVlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZGVsZXRlKGtleSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0X2dldE9yRGVsZXRlSWZFeHBpcmVkKGtleSwgaXRlbSkge1xuXHRcdGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCBpdGVtKTtcblx0XHRpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybiBpdGVtLnZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdF9nZXRJdGVtVmFsdWUoa2V5LCBpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0uZXhwaXJ5ID8gdGhpcy5fZ2V0T3JEZWxldGVJZkV4cGlyZWQoa2V5LCBpdGVtKSA6IGl0ZW0udmFsdWU7XG5cdH1cblxuXHRfcGVlayhrZXksIGNhY2hlKSB7XG5cdFx0Y29uc3QgaXRlbSA9IGNhY2hlLmdldChrZXkpO1xuXG5cdFx0cmV0dXJuIHRoaXMuX2dldEl0ZW1WYWx1ZShrZXksIGl0ZW0pO1xuXHR9XG5cblx0X3NldChrZXksIHZhbHVlKSB7XG5cdFx0dGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG5cdFx0dGhpcy5fc2l6ZSsrO1xuXG5cdFx0aWYgKHRoaXMuX3NpemUgPj0gdGhpcy5tYXhTaXplKSB7XG5cdFx0XHR0aGlzLl9zaXplID0gMDtcblx0XHRcdHRoaXMuX2VtaXRFdmljdGlvbnModGhpcy5vbGRDYWNoZSk7XG5cdFx0XHR0aGlzLm9sZENhY2hlID0gdGhpcy5jYWNoZTtcblx0XHRcdHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG5cdFx0fVxuXHR9XG5cblx0X21vdmVUb1JlY2VudChrZXksIGl0ZW0pIHtcblx0XHR0aGlzLm9sZENhY2hlLmRlbGV0ZShrZXkpO1xuXHRcdHRoaXMuX3NldChrZXksIGl0ZW0pO1xuXHR9XG5cblx0KiBfZW50cmllc0FzY2VuZGluZygpIHtcblx0XHRmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5vbGRDYWNoZSkge1xuXHRcdFx0Y29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTtcblx0XHRcdGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0XHRjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpO1xuXHRcdFx0XHRpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHR5aWVsZCBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBpdGVtIG9mIHRoaXMuY2FjaGUpIHtcblx0XHRcdGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZW07XG5cdFx0XHRjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpO1xuXHRcdFx0aWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHlpZWxkIGl0ZW07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Z2V0KGtleSkge1xuXHRcdGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG5cdFx0XHRjb25zdCBpdGVtID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX2dldEl0ZW1WYWx1ZShrZXksIGl0ZW0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9sZENhY2hlLmhhcyhrZXkpKSB7XG5cdFx0XHRjb25zdCBpdGVtID0gdGhpcy5vbGRDYWNoZS5nZXQoa2V5KTtcblx0XHRcdGlmICh0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCBpdGVtKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5fbW92ZVRvUmVjZW50KGtleSwgaXRlbSk7XG5cdFx0XHRcdHJldHVybiBpdGVtLnZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHNldChrZXksIHZhbHVlLCB7bWF4QWdlID0gdGhpcy5tYXhBZ2V9ID0ge30pIHtcblx0XHRjb25zdCBleHBpcnkgPVxuXHRcdFx0dHlwZW9mIG1heEFnZSA9PT0gJ251bWJlcicgJiYgbWF4QWdlICE9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgP1xuXHRcdFx0XHREYXRlLm5vdygpICsgbWF4QWdlIDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG5cdFx0XHR0aGlzLmNhY2hlLnNldChrZXksIHtcblx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdGV4cGlyeVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3NldChrZXksIHt2YWx1ZSwgZXhwaXJ5fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRoYXMoa2V5KSB7XG5cdFx0aWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHtcblx0XHRcdHJldHVybiAhdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdGhpcy5jYWNoZS5nZXQoa2V5KSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub2xkQ2FjaGUuaGFzKGtleSkpIHtcblx0XHRcdHJldHVybiAhdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdGhpcy5vbGRDYWNoZS5nZXQoa2V5KSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cGVlayhrZXkpIHtcblx0XHRpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3BlZWsoa2V5LCB0aGlzLmNhY2hlKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vbGRDYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3BlZWsoa2V5LCB0aGlzLm9sZENhY2hlKTtcblx0XHR9XG5cdH1cblxuXHRkZWxldGUoa2V5KSB7XG5cdFx0Y29uc3QgZGVsZXRlZCA9IHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7XG5cdFx0aWYgKGRlbGV0ZWQpIHtcblx0XHRcdHRoaXMuX3NpemUtLTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5vbGRDYWNoZS5kZWxldGUoa2V5KSB8fCBkZWxldGVkO1xuXHR9XG5cblx0Y2xlYXIoKSB7XG5cdFx0dGhpcy5jYWNoZS5jbGVhcigpO1xuXHRcdHRoaXMub2xkQ2FjaGUuY2xlYXIoKTtcblx0XHR0aGlzLl9zaXplID0gMDtcblx0fVxuXG5cdHJlc2l6ZShuZXdTaXplKSB7XG5cdFx0aWYgKCEobmV3U2l6ZSAmJiBuZXdTaXplID4gMCkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2BtYXhTaXplYCBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwJyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaXRlbXMgPSBbLi4udGhpcy5fZW50cmllc0FzY2VuZGluZygpXTtcblx0XHRjb25zdCByZW1vdmVDb3VudCA9IGl0ZW1zLmxlbmd0aCAtIG5ld1NpemU7XG5cdFx0aWYgKHJlbW92ZUNvdW50IDwgMCkge1xuXHRcdFx0dGhpcy5jYWNoZSA9IG5ldyBNYXAoaXRlbXMpO1xuXHRcdFx0dGhpcy5vbGRDYWNoZSA9IG5ldyBNYXAoKTtcblx0XHRcdHRoaXMuX3NpemUgPSBpdGVtcy5sZW5ndGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChyZW1vdmVDb3VudCA+IDApIHtcblx0XHRcdFx0dGhpcy5fZW1pdEV2aWN0aW9ucyhpdGVtcy5zbGljZSgwLCByZW1vdmVDb3VudCkpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm9sZENhY2hlID0gbmV3IE1hcChpdGVtcy5zbGljZShyZW1vdmVDb3VudCkpO1xuXHRcdFx0dGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcblx0XHRcdHRoaXMuX3NpemUgPSAwO1xuXHRcdH1cblxuXHRcdHRoaXMubWF4U2l6ZSA9IG5ld1NpemU7XG5cdH1cblxuXHQqIGtleXMoKSB7XG5cdFx0Zm9yIChjb25zdCBba2V5XSBvZiB0aGlzKSB7XG5cdFx0XHR5aWVsZCBrZXk7XG5cdFx0fVxuXHR9XG5cblx0KiB2YWx1ZXMoKSB7XG5cdFx0Zm9yIChjb25zdCBbLCB2YWx1ZV0gb2YgdGhpcykge1xuXHRcdFx0eWllbGQgdmFsdWU7XG5cdFx0fVxuXHR9XG5cblx0KiBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcblx0XHRmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5jYWNoZSkge1xuXHRcdFx0Y29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTtcblx0XHRcdGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0eWllbGQgW2tleSwgdmFsdWUudmFsdWVdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLm9sZENhY2hlKSB7XG5cdFx0XHRjb25zdCBba2V5LCB2YWx1ZV0gPSBpdGVtO1xuXHRcdFx0aWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG5cdFx0XHRcdGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdGlmIChkZWxldGVkID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdHlpZWxkIFtrZXksIHZhbHVlLnZhbHVlXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdCogZW50cmllc0Rlc2NlbmRpbmcoKSB7XG5cdFx0bGV0IGl0ZW1zID0gWy4uLnRoaXMuY2FjaGVdO1xuXHRcdGZvciAobGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuXHRcdFx0Y29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0Y29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTtcblx0XHRcdGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0eWllbGQgW2tleSwgdmFsdWUudmFsdWVdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGl0ZW1zID0gWy4uLnRoaXMub2xkQ2FjaGVdO1xuXHRcdGZvciAobGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuXHRcdFx0Y29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0Y29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTtcblx0XHRcdGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0XHRjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpO1xuXHRcdFx0XHRpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHR5aWVsZCBba2V5LCB2YWx1ZS52YWx1ZV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQqIGVudHJpZXNBc2NlbmRpbmcoKSB7XG5cdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fZW50cmllc0FzY2VuZGluZygpKSB7XG5cdFx0XHR5aWVsZCBba2V5LCB2YWx1ZS52YWx1ZV07XG5cdFx0fVxuXHR9XG5cblx0Z2V0IHNpemUoKSB7XG5cdFx0aWYgKCF0aGlzLl9zaXplKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vbGRDYWNoZS5zaXplO1xuXHRcdH1cblxuXHRcdGxldCBvbGRDYWNoZVNpemUgPSAwO1xuXHRcdGZvciAoY29uc3Qga2V5IG9mIHRoaXMub2xkQ2FjaGUua2V5cygpKSB7XG5cdFx0XHRpZiAoIXRoaXMuY2FjaGUuaGFzKGtleSkpIHtcblx0XHRcdFx0b2xkQ2FjaGVTaXplKys7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIE1hdGgubWluKHRoaXMuX3NpemUgKyBvbGRDYWNoZVNpemUsIHRoaXMubWF4U2l6ZSk7XG5cdH1cblxuXHRlbnRyaWVzKCkge1xuXHRcdHJldHVybiB0aGlzLmVudHJpZXNBc2NlbmRpbmcoKTtcblx0fVxuXG5cdGZvckVhY2goY2FsbGJhY2tGdW5jdGlvbiwgdGhpc0FyZ3VtZW50ID0gdGhpcykge1xuXHRcdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuZW50cmllc0FzY2VuZGluZygpKSB7XG5cdFx0XHRjYWxsYmFja0Z1bmN0aW9uLmNhbGwodGhpc0FyZ3VtZW50LCB2YWx1ZSwga2V5LCB0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KFsuLi50aGlzLmVudHJpZXNBc2NlbmRpbmcoKV0pO1xuXHR9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/quick-lru/index.js\n"));

/***/ })

});